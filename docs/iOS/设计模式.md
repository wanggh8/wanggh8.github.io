---
title: 设计模式
date: 2021-02-12
updated: 2021-02-12 
tags: 
  - Android
  - iOS
categories: iOS
description: 设计模式
cover: /images/Xcode.png
top_img: /images/Xcode.png
typora-root-url: ../../../source
---



## 面向对象程序技术

> - 面向对象就是构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。 易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护。
> - 面向过程分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候依次调用。性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源。 

### 抽象

抽象是一种反映真实世界对象或现象中特定内容的模型，它能高精度地反映所有与特定内容相关的详细信息，同时忽略其他内容。

### 封装

**封装是指一个对象对其他对象隐藏其部分状态和行为，而仅向程序其他部分暴露有限的接口的能力。**封装某个内容意味着使用关键字 private 私有来对其进行修饰，这样仅有其所在类中的方法才能访问这些内容。 还有一种限制程度较小的关键字 protected 保护 ，其所修饰的对象仅允许父类访问其类中的成员。封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。

### 继承

继承是指在根据已有类创建新类的能力。 继承最主要的好处是代码复用。**继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为**。使用继承后，子类将拥有与其父类相同的接口。 如果父类中 声明了某个方法，那么你将无法在子类中隐藏该方法。你还 必须实现所有的抽象方法，即使它们对于你的子类而言没有 意义。

### 多态

多态是指程序能够检测对象所属的实际类， 并在当前上下文不知道其真实类型的情况下调用其实现的能力。**多态是同一个行为具有多个不同表现形式或形态的能力。多态就是同一个接口，使用不同的实例而执行不同操作**

## 对象之间的关系

- 依赖：对类 B 进行修改会影响到类 A 。
- 关联：对象 A 知道对象 B。 类 A 依赖于类 B。
- 聚合：对象 A 知道对象 B 且由 B 构成。 类 A 依赖于类 B。
- 组合：对象 A 知道对象 B、由 B 构成而且管理着 B 的生命周 期。 类 A 依赖于类 B。
- 实现：类 A 定义的方法由接口 B 声明。 对象 A 可被视为对象 B。 类 A 依赖于类 B。
- 继承： 类 A 继承类 B 的接口和实现， 但是可以对其进行扩 展。 对象 A 可被视为对象 B。 类 A 依赖于类 B。

## 设计原则

### 封装变化的内容

找到程序中的变化内容并将其与不变的内容区分开

### 面向接口进行开发， 而不是面向实现

面向接口进行开发， 而不是面向实现； 依赖于抽象类型， 而不是具体类。

### 组合优于继承

> 组合是代替继承的一种方法。 继承代表类之间的“是”关系

- 子类不能减少超类的接口。 你必须实现父类中所有的抽象方法， 即使它们没什么用。
- 在重写方法时， 你需要确保新行为与其基类中的版本兼容这一点很重要， 因为子类的所有对象都可能被传递给以超类对象为参数的任何代码， 相信你不会希望这些代码崩溃的。
- 继承打破了超类的封装， 因为子类拥有访问父类内部详细内容的权限。 此外还可能会有相反的情况出现， 那就是程序员 为了进一步扩展的方便而让超类知晓子类的内部详细内容。
- 子类与超类紧密耦合。超类中的任何修改都可能会破坏子类的功能。
- 通过继承复用代码可能导致平行继承体系的产生。继承通常仅发生在一个维度中。只要出现了两个以上的维度，你就必须创建数量巨大的类组合，从而使类层次结构膨胀到不可思议的程度。

## SOLID原则

### 单一职责原则 Single Responsibility Principle

尽量让每个类只负责软件中的一个功能， 并将该功能完全封装（你也可称之为隐藏）在该类中。

### 开闭原则 Open/closed Principle

对于扩展， 类应该是“开放”的；对于修改， 类则应是“封闭”的。本原则的主要理念是在实现新功能时能保持已有代码不变。这条原则并不能应用于所有对类进行的修改中。 如果你发现 类中存在缺陷， 直接对其进行修复即可， 不要为它创建子类。 子类不应该对其父类的问题负责。

### 里氏替换原则 Liskov Substitution Principle

当你扩展一个类时， 记住你应该要能在不修改客户端代码的情况下将子类的对象作为父类对象进行传递。这意味着子类必须保持与父类行为的兼容。 在重写一个方法时， 你要对基类行为进行扩展， 而不是将其完全替换。

> - 子类方法的参数类型必须与其超类的参数类型相匹配或更加抽象。
> - 子类方法的返回值类型必须与超类方法的返回值类型或是其子类别相匹配。
> - 子类中的方法不应抛出基础方法预期之外的异常类型。
> - 子类不应该加强其前置条件。（条件范围不能变小）
> - 子类不能削弱其后置条件。（条件范围不能变大）
> - 超类的不变量必须保留。
> - 子类不能修改超类中私有成员变量的值。

### 接口隔离原则 Interface Segregation Principle

客户端不应被强迫依赖于其不使用的方法。尽量缩小接口的范围， 使得客户端的类不必实现其不需要的行为。根据接口隔离原则， 你必须将“臃肿”的方法拆分为多个颗粒度更小的具体方法。 客户端必须仅实现其实际需要的方法。

### 依赖倒置原则 Dependency Inversion Principle

高层次的类不应该依赖于低层次的类。 两者都应该依赖于抽象接口。 抽象接口不应依赖于具体实现。 具体实现应该依赖于抽象接口。

## 设计模式

### 创建型模式

#### 工厂方法 Factory Method

##### 结构

- 产品（Product）将会对接口进行声明。 对于所有由创建者及 其子类构建的对象， 这些接口都是通用的。
- 具体产品（Concrete Products）是产品接口的不同实现。
- 创建者（Creator）类声明返回产品对象的工厂方法。 该方法的返回对象类型必须与产品接口相匹配。你可以将工厂方法声明为抽象方法， 强制要求每个子类以不同方式实现该方法。 或者，你也可以在基础工厂方法中返回 默认产品类型
- 具体创建者（Concrete Creators） 将会重写基础工厂方法，使其返回不同类型的产品。

##### 使用场景

- 当你在编写代码的过程中， 如果无法预知对象确切类别及其依赖关系时， 可使用工厂方法。工厂方法将创建产品的代码与实际使用产品的代码分离， 从 而能在不影响其他代码的情况下扩展产品创建部分代码。

- 如果你希望用户能扩展你软件库或框架的内部组件， 可使用工厂方法。

  > 假设你使用开源 UI 框架编写 自己的应用。 你希望在应用中使用圆形按钮， 但是原框架仅 支持矩形按钮。 你可以使用 圆形按钮 RoundButton 子类来 继承标准的 按钮 Button 类。 但是， 你需要告诉 UI 框架 UIFramework 类使用新的子类按钮代替默认按钮。 
  >
  > 为 了 实 现 这 个 功 能， 你 可 以 根 据 基 础 框 架 类 开 发 子 类 圆形按钮 UI UIWithRoundButtons ， 并 且 重 写 其 createButton 创建按钮 方法。 基类中的该方法返回 按钮 对象， 而你开发的子类返回 圆形按钮 对象。 现在， 你就可 以使用 圆形按钮 UI 类代替 UI框架类

- 如果你希望复用现有对象来节省系统资源， 而不是每次都重新创建对象， 可使用工厂方法。

##### 实现方式

1. 让所有产品都遵循同一接口。 该接口必须声明对所有产品都 有意义的方法。
2. 在创建类中添加一个空的工厂方法。 该方法的返回类型必须 遵循通用的产品接口。
3. 在创建者代码中找到对于产品构造函数的所有引用。 将它们 、依次替换为对于工厂方法的调用， 同时将创建产品的代码移 入工厂方法。 你可能需要在工厂方法中添加临时参数来控制 返回的产品类型。
4. 现在， 为工厂方法中的每种产品编写一个创建者子类， 然后 在子类中重写工厂方法， 并将基本方法中的相关创建代码移 动到工厂方法中。
5. 如果应用中的产品类型太多， 那么为每个产品创建子类并无 太大必要， 这时你也可以在子类中复用基类中的控制参数。
6. 如果代码经过上述移动后， 基础工厂方法中已经没有任何代码， 你可以将其转变为抽象类。 如果基础工厂方法中还有其 他语句， 你可以将其设置为该方法的默认行为。

#### 抽象工厂 Abstract Factory

##### 结构

- 抽象产品（Abstract Product）为构成系列产品的一组不同但相关的产品声明接口。
- 具体产品（Concrete Product）是抽象产品的多种不同类型实现。 所有变体（维多利亚/现代）都必须实现相应的抽象产品 （椅子/沙发）。
- 抽象工厂（Abstract Factory）接口声明了一组创建各种抽象产品的方法。
- 具体工厂（Concrete Factory）实现抽象工厂的构建方法。 每个具体工厂都对应特定产品变体， 且仅创建此种产品变体。
- 尽管具体工厂会对具体产品进行初始化， 其构建方法签名必 须返回相应的抽象产品。 这样， 使用工厂类的客户端代码就 不会与工厂创建的特定产品变体耦合。 客户端（Client）只 需通过抽象接口调用工厂和产品对象， 就能与任何具体工厂/ 产品变体交互。



#### 生成器

#### 原型

#### 单例

### 结构型模式

#### 适配器

#### 桥接

#### 组合

#### 装饰

#### 外观

#### 享元

#### 代理

### 行为模式

#### 责任链

#### 命令

#### 迭代器

#### 中介者

#### 备忘录

#### 观察者

#### 状态

#### 策略

#### 模板方法

#### 访问者

