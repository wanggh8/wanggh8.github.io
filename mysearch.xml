<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>iOS 技能图谱</title>
      <link href="/IOS/iOS%E6%8A%80%E8%83%BD%E5%9B%BE%E8%B0%B1/"/>
      <url>/IOS/iOS%E6%8A%80%E8%83%BD%E5%9B%BE%E8%B0%B1/</url>
      
        <content type="html"><![CDATA[<h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><ul><li>Swift</li><li>Objective-C</li><li>C++/C</li><li>JavaScript</li></ul><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ul><li>Mac OSX</li><li>iOS</li><li>watchOS</li><li>tvOS</li><li>Linux 常用命令</li></ul><h2 id="开发基础"><a href="#开发基础" class="headerlink" title="开发基础"></a>开发基础</h2><ul><li>UI 控件</li><li>Storyboard &amp; Xib</li><li>Core Data &amp; Sqlite</li><li>Core Graphics</li><li>Animation</li><li>Block &amp; GCD</li><li>Test Case 编写</li><li>Framework</li><li>Autolayout</li><li>手势识别，重力感应</li></ul><h2 id="开发进阶"><a href="#开发进阶" class="headerlink" title="开发进阶"></a>开发进阶</h2><ul><li>引用计数</li><li>Runtime</li><li>Runloop</li><li>对象模型</li><li>Hybrid</li><li>沙盒机制</li><li>AVFoundation</li><li>Core Text</li><li>逆向与安全<ul><li>class dump</li><li>IDA Pro</li><li>Hopper</li><li>iOS Class Guard</li></ul></li></ul><p>##设计模式</p><ul><li>MVC</li><li>MVVM</li><li>通知</li><li>代理</li><li>KVO</li><li>工厂模式</li><li>命令模式</li></ul><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><ul><li>ReactiveCocoa</li><li>RxSwift</li></ul><h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><ul><li>IDE<ul><li>Xcode</li><li>AppCode</li></ul></li><li>调试工具<ul><li>Charles、Wireshark</li><li>Reveal</li><li>Instruments</li></ul></li><li>插件<ul><li>Alcatraz</li><li>VVDocument</li><li>XVim</li><li>FuzzyAutocompletePlugin</li><li>KSImageNamed-Xcode</li></ul></li><li>辅助工具<ul><li>xScope</li><li>ImageOptim</li><li>马克鳗</li><li>Dash</li><li>Deploymate</li><li>FauxPas</li><li>PaintCode</li></ul></li><li>命令行工具<ul><li>xcodebuild、xcode-select</li><li>nomad</li><li>xctool</li><li>fastlane</li></ul></li><li>持续集成<ul><li>Jenkins</li><li>Travis CI</li><li>Bot</li></ul></li></ul><h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h2><ul><li>AFNetworking &amp; Alamofire</li><li>Masonry</li><li>SDWebImage</li><li>SwiftyJSON</li><li>JSPatch</li><li>React Native</li></ul><h2 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h2><ul><li>CocoaPods</li><li>Carthage</li><li>Swift Package Manager</li></ul><h2 id="App-打包上传与审核"><a href="#App-打包上传与审核" class="headerlink" title="App 打包上传与审核"></a>App 打包上传与审核</h2><ul><li>Apple Developer 网站</li><li>Itunes Connect 网站</li><li>IAP</li><li>加急审核申请</li><li>打包脚本</li></ul><h2 id="第三方服务"><a href="#第三方服务" class="headerlink" title="第三方服务"></a>第三方服务</h2><ul><li>崩溃收集<ul><li>Bugly</li><li>Crashlytics</li><li>BugHD</li></ul></li><li>数据统计<ul><li>Google Analytics</li><li>友盟</li><li>MTA</li><li>Flurry</li><li>App Annie</li></ul></li><li>应用分发<ul><li>TestFlight</li><li>蒲公英</li><li>FIR</li></ul></li></ul><p><a href="https://github.com/TeamStuQ/skill-map">附极客时间iOS开发工程师技能图谱</a></p><p><a href="https://github.com/TeamStuQ/skill-map/issues/14">附iOS 开发工程师学习资源</a></p><p><img src= "/img/loading.gif" data-lazy-src="/assets/png-iOSDev-by-StuQ.png" alt="附极客时间iOS开发工程师技能图谱"></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Objective-C </tag>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android技术选型</title>
      <link href="/Android/Android%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/"/>
      <url>/Android/Android%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<ul><li>架构模式：MVVM</li><li>底层框架：<a href="https://github.com/wanggh8/PureMVVM">PureMVVM</a></li><li>日志： <a href="https://github.com/orhanobut/logger">Logger</a></li><li>josn处理：<a href="https://github.com/google/gson">Gson</a></li><li>网络请求：okhttp3、retrofit2、rxjava</li><li>吐司弹窗：<a href="https://github.com/getActivity/ToastUtils">ToastUtils</a></li><li>图片加载：<a href="https://github.com/bumptech/glide">Glide</a></li><li>TitleBar：<a href="https://github.com/wuhenzhizao/android-titlebar">CommonTitleBar</a></li><li>上拉加载下拉刷新：<a href="https://github.com/huxq17/XRefreshView">XRefreshView</a></li><li>文档加载：TBS</li><li>进度条：<a href="https://github.com/daimajia/NumberProgressBar">NumberProgressBar</a></li><li>圆形进度：<a href="https://github.com/rahatarmanahmed/CircularProgressView">CircularProgressView</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Gradle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Bintray打包JCenter</title>
      <link href="/Android/Bintray/"/>
      <url>/Android/Bintray/</url>
      
        <content type="html"><![CDATA[<p>项目根 <code>Build.gradle</code> 中设置 <code>classpath</code>, <code>bintray-release</code> 最新版本最高支持 Gradle Version 5.4.1，Android Gradle Plugin Version 3.5.4。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs groovy">buildscript &#123;<br>    repositories &#123;<br>        google()<br>        jcenter()<br>    &#125;<br>    dependencies &#123;<br>        classpath <span class="hljs-string">&quot;com.android.tools.build:gradle:3.5.4&quot;</span><br>        classpath <span class="hljs-string">&#x27;com.novoda:bintray-release:0.9.2&#x27;</span><br>        <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> Do not place your application dependencies here; they belong</span><br>        <span class="hljs-comment">// in the individual module build.gradle files</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>新建 <code>bintray.gradle</code> 文件，添加以下内容：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs groovy">apply <span class="hljs-attr">plugin:</span> <span class="hljs-string">&#x27;com.novoda.bintray-release&#x27;</span><br><br><span class="hljs-comment">//生成源文件</span><br>task sourcesJar(<span class="hljs-attr">type:</span> Jar) &#123;<br>    from android.sourceSets.main.java.srcDirs<br>    classifier = <span class="hljs-string">&#x27;sources&#x27;</span><br>&#125;<br><br><span class="hljs-comment">//生成Javadoc文档</span><br>task javadoc(<span class="hljs-attr">type:</span> Javadoc) &#123;<br>    source = android.sourceSets.main.java.srcDirs<br>    classpath += project.files(android.getBootClasspath().join(File.pathSeparator))<br>&#125;<br><br><span class="hljs-comment">//文档打包成jar</span><br>task javadocJar(<span class="hljs-attr">type:</span> Jar, <span class="hljs-attr">dependsOn:</span> javadoc) &#123;<br>    classifier = <span class="hljs-string">&#x27;javadoc&#x27;</span><br>    from javadoc.destinationDir<br>&#125;<br><br><span class="hljs-comment">//拷贝javadoc文件</span><br>task copyDoc(<span class="hljs-attr">type:</span> Copy) &#123;<br>    from <span class="hljs-string">&quot;$&#123;buildDir&#125;/docs/&quot;</span><br>    into <span class="hljs-string">&quot;docs&quot;</span><br>&#125;<br><br><span class="hljs-comment">//解决 JavaDoc 中文注释生成失败的问题</span><br>tasks.withType(Javadoc) &#123;<br>    options.addStringOption(<span class="hljs-string">&#x27;Xdoclint:none&#x27;</span>, <span class="hljs-string">&#x27;-quiet&#x27;</span>)<br>    options.addStringOption(<span class="hljs-string">&#x27;encoding&#x27;</span>, <span class="hljs-string">&#x27;UTF-8&#x27;</span>)<br>    options.addStringOption(<span class="hljs-string">&#x27;charSet&#x27;</span>, <span class="hljs-string">&#x27;UTF-8&#x27;</span>)<br>&#125;<br><br><span class="hljs-comment">//上传到JCenter所需要的源码文件</span><br>artifacts &#123;<br>    archives javadocJar<br>    archives sourcesJar<br>&#125;<br><br><span class="hljs-comment">// 获取 local.properties 属性值</span><br>Properties properties = <span class="hljs-keyword">new</span> Properties()<br>properties.load(project.rootProject.file(<span class="hljs-string">&#x27;local.properties&#x27;</span>).newDataInputStream())<br><br><span class="hljs-comment">//发布到 Bintray</span><br>publish &#123;<br>    userOrg = <span class="hljs-string">&#x27;user&#x27;</span>           <span class="hljs-comment">//bintray.com 注册的用户名</span><br>    repoName = <span class="hljs-string">&#x27;pure&#x27;</span><br>    groupId = <span class="hljs-string">&#x27;com.user.repo&#x27;</span>   <span class="hljs-comment">//以后访问 jcenter上此项目的路径，一般和库项目的包名一致</span><br>    artifactId = <span class="hljs-string">&#x27;PackageName&#x27;</span>       <span class="hljs-comment">//bintray.com 创建的 Package 名</span><br>    publishVersion = <span class="hljs-string">&#x27;0.0.1&#x27;</span>         <span class="hljs-comment">//版本号</span><br>    desc = <span class="hljs-string">&#x27;desc&#x27;</span> <span class="hljs-comment">//版本说明，随意</span><br>    website = <span class="hljs-string">&#x27;https://github.com/wanggh8&#x27;</span>    <span class="hljs-comment">//关于这个开源项目的网站，随意</span><br>    licences = [<span class="hljs-string">&#x27;Apache-2.0&#x27;</span>]<br>    bintrayUser = properties.getProperty(<span class="hljs-string">&#x27;BINTRAY_USER&#x27;</span>)<br>    bintrayKey = properties.getProperty(<span class="hljs-string">&#x27;BINTRAY_KEY&#x27;</span>)<br>    dryRun = <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在 library 的 <code>Build.gradle</code> 中最后添加：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">apply <span class="hljs-attr">from:</span> <span class="hljs-string">&#x27;./bintray.gradle&#x27;</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Gradle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UIKit</title>
      <link href="/IOS/UIKit/"/>
      <url>/IOS/UIKit/</url>
      
        <content type="html"><![CDATA[<h3 id="UIView"><a href="#UIView" class="headerlink" title="UIView"></a>UIView</h3><h3 id="UIWindow"><a href="#UIWindow" class="headerlink" title="UIWindow"></a>UIWindow</h3><p>提供 App 中展示内容的基础窗口</p><p>只作为容器，与 ViewController 一起协同工作</p><p>通常屏幕上只存在、展示一个 UIWindow</p><h4 id="App结构"><a href="#App结构" class="headerlink" title="App结构"></a>App结构</h4><p><img src= "/img/loading.gif" data-lazy-src="/assets/image-20201203174517382.png" alt="image-20201203174517382"></p><p><img src= "/img/loading.gif" data-lazy-src="/assets/image-20201203174551163.png" alt="image-20201203174551163"></p><h4 id="创建-UIWindow"><a href="#创建-UIWindow" class="headerlink" title="创建 UIWindow"></a>创建 UIWindow</h4><ol><li>创建 UIWindow</li><li>设置 rootViewController</li><li>makeKeyAndVisible</li></ol><h3 id="UITabbarController"><a href="#UITabbarController" class="headerlink" title="UITabbarController"></a>UITabbarController</h3><p>底部导航页</p><ul><li>开源：Tabbar / TabbarController</li></ul><h3 id="UINavigationBar"><a href="#UINavigationBar" class="headerlink" title="UINavigationBar"></a>UINavigationBar</h3><p>页面跳转管理</p><h3 id="delegate设计模式"><a href="#delegate设计模式" class="headerlink" title="delegate设计模式"></a>delegate设计模式</h3><h3 id="UITableView"><a href="#UITableView" class="headerlink" title="UITableView"></a>UITableView</h3><ol><li>提供最基础的列表类型视图组件</li><li>提供默认基础的UITableViewCell 样式、header和 footer 的管理</li><li>提供针对 UITableViewCell 的复用回收逻辑</li><li>提供列表基础功能，如点击、删除、插入等</li></ol><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><ol><li>创建 UITableView 设置 delegate 和 DataSource，通过两个 delegate</li><li>选择实现 UITableViewDataSource 中方法，行数、cell复用</li><li>选择实现 UITableViewDelegate 中方法（高度、headerFooter、点击）</li></ol><h4 id="UITableViewDataSource"><a href="#UITableViewDataSource" class="headerlink" title="UITableViewDataSource"></a>UITableViewDataSource</h4><h4 id="UITableViewCell重用"><a href="#UITableViewCell重用" class="headerlink" title="UITableViewCell重用"></a>UITableViewCell重用</h4><p>系统提供复用回收池，根据reuseIdentifier作为标识</p><p>dequeueReusableCellWithIdentifier</p><p><img src= "/img/loading.gif" data-lazy-src="/assets/image-20201203202245145.png" alt="image-20201203202245145"></p><h4 id="UITableViewDelegate"><a href="#UITableViewDelegate" class="headerlink" title="UITableViewDelegate"></a>UITableViewDelegate</h4><ol><li>提供滚动过程中，UITableViewCell 的出现、消失时机</li><li>提供 UITableViewCell 的高度、Header 以及 footers 设置</li><li>提供 UITableViewCell 各种行为的回调（点击、删除等）</li></ol><h3 id="UICollectionView"><a href="#UICollectionView" class="headerlink" title="UICollectionView"></a>UICollectionView</h3><p>和 UITableView 有相同的 Api 设计理念：基于 datasource 以及 delegate 驱动</p><h4 id="UICollectionViewCell"><a href="#UICollectionViewCell" class="headerlink" title="UICollectionViewCell"></a>UICollectionViewCell</h4><ol><li>继承自 UICollectionReusableView</li><li>只有 contentView / backgroundView</li><li>不是以行为设计继承</li><li>必须先注册 Cell 类型用于重用</li></ol><h3 id="UIScrollView"><a href="#UIScrollView" class="headerlink" title="UIScrollView"></a>UIScrollView</h3>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pure Play技术选型</title>
      <link href="/IOS/PurePlay/"/>
      <url>/IOS/PurePlay/</url>
      
        <content type="html"><![CDATA[<h3 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h3><ul><li><a href="https://github.com/Alamofire/Alamofire">Alamofire</a> - 非常赞👍👍👍 Alamofire是AFNetworking的作者mattt新写的网络请求的swift库。[Alamofire 最佳实践](<a href="https://github.com/ipader/SwiftGuide/wiki/Alamofire">https://github.com/ipader/SwiftGuide/wiki/Alamofire</a> 最佳实践)</li></ul><h4 id="网络解析"><a href="#网络解析" class="headerlink" title="网络解析"></a>网络解析</h4><ul><li><p><a href="https://github.com/SwiftyJSON/SwiftyJSON">SwiftyJSON</a> - The better way to deal with JSON data in Swift. 🔶.</p></li><li><p><a href="https://github.com/tadija/AEXML">AEXML</a> - Simple and lightweight XML parser written in Swift. </p></li></ul><h3 id="图像缓存"><a href="#图像缓存" class="headerlink" title="图像缓存"></a>图像缓存</h3><ul><li><a href="https://github.com/onevcat/Kingfisher">Kingfisher</a> - 👍👍👍 一个轻量级的纯粹的用于从web下载和缓存图片的Swift库.</li></ul><h3 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h3><ul><li><a href="https://github.com/SnapKit/SnapKit">Snap</a> - Snap是Masonry Auto Layout DSL的Swift版本，是一款轻量级的布局框架，使用了更良好的语法封装了AutoLayout。Snap支持iOS和OS X.</li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/Android/Untitled/"/>
      <url>/Android/Untitled/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS Objective-C UI</title>
      <link href="/IOS/UI/"/>
      <url>/IOS/UI/</url>
      
        <content type="html"><![CDATA[<h2 id="常用控件"><a href="#常用控件" class="headerlink" title="常用控件"></a>常用控件</h2><a id="more"></a><p><img src= "/img/loading.gif" data-lazy-src="/assets/image-20210127152009433.png" alt="image-20210127152009433"></p><h3 id="UILabel"><a href="#UILabel" class="headerlink" title="UILabel"></a>UILabel</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">&#x2F;&#x2F; 创建对象<br>UILabel *label &#x3D; [[UILabel alloc] init];<br>&#x2F;&#x2F; frame<br>label.frame &#x3D; CGRectMake(100, 100, 300, 75);<br>&#x2F;&#x2F; 颜色<br>label.backgroundColor &#x3D; [UIColor redColor];<br>&#x2F;&#x2F; 内容<br>label.text &#x3D; @&quot;dashuaibi&quot;;<br>&#x2F;&#x2F; 对齐方式<br>label.textAlignment &#x3D;  NSTextAlignmentLeft;<br>&#x2F;&#x2F; 字体大小<br>label.font &#x3D; [UIFont systemFontOfSize:20.f];<br>label.font &#x3D; [UIFont boldSystemFontOfSize:20.f];<br>label.font &#x3D; [UIFont italicSystemFontOfSize:20.f];<br>&#x2F;&#x2F; 文字颜色<br>label.textColor &#x3D; [UIColor purpleColor];<br>&#x2F;&#x2F; 设置阴影<br>label.shadowColor &#x3D; [UIColor blueColor];<br>label.shadowOffset &#x3D; CGSizeMake(-2, 1);<br>&#x2F;&#x2F; 行数 0为自动换行<br>label.numberOfLines &#x3D; 0;<br>&#x2F;&#x2F; 显示模式<br>label.lineBreakMode &#x3D; NSLineBreakByWordWrapping;<br><br>    UILabel *label &#x3D; [[UILabel alloc] initWithFrame:CGRectMake(20, 100, 300, 100)];<br>    label.text &#x3D; @&quot;UILabel是继承自UIView的一个显示控件，基本是除了UIView之外使用最广泛的控件&quot;;<br>    label.numberOfLines &#x3D; 3;<br>    label.textAlignment &#x3D; NSTextAlignmentCenter;<br>    label.font &#x3D; [UIFont boldSystemFontOfSize:16];<br>    label.textColor &#x3D; [UIColor blueColor];<br>    label.backgroundColor &#x3D; [UIColor grayColor];<br>    [label sizeToFit];<br>    [self.view addSubview:label];<br>&#x2F;&#x2F;超文本<br>    UILabel *label &#x3D; [[UILabel alloc] initWithFrame:CGRectMake(20, 100, 300, 100)];<br>    UIFont *bigFont &#x3D; [UIFont boldSystemFontOfSize:36];<br>    UIFont *smallFont &#x3D; [UIFont boldSystemFontOfSize:bigFont.pointSize &#x2F; 2];<br>    NSMutableAttributedString *attributeString6 &#x3D; [[NSMutableAttributedString alloc] init];<br>    NSAttributedString *string1 &#x3D; [[NSAttributedString alloc] initWithString:@&quot;￥&quot;<br>                                                                  attributes:@&#123;NSFontAttributeName:smallFont,<br>                                                                               NSForegroundColorAttributeName:[UIColor blackColor],<br>                                                                               NSBaselineOffsetAttributeName:@(0)&#125;];<br>    NSAttributedString *string2 &#x3D; [[NSAttributedString alloc] initWithString:@&quot;9&quot;<br>                                                                  attributes:@&#123;NSFontAttributeName:bigFont,<br>                                                                               NSForegroundColorAttributeName:[UIColor blueColor],<br>                                                                               NSBaselineOffsetAttributeName:@(0)&#125;];<br>    NSAttributedString *string3 &#x3D; [[NSAttributedString alloc] initWithString:@&quot;.99&quot;<br>                                                                  attributes:@&#123;NSFontAttributeName:smallFont,<br>                                                                               NSForegroundColorAttributeName:[UIColor blackColor],<br>                                                                               NSBaselineOffsetAttributeName : @(0)&#125;];<br>    [attributeString6 appendAttributedString:string1];<br>    [attributeString6 appendAttributedString:string2];<br>    [attributeString6 appendAttributedString:string3];<br>    label.attributedText &#x3D; attributeString6;<br>    [self.view addSubview:label];<br></code></pre></td></tr></table></figure><h3 id="UIImageView"><a href="#UIImageView" class="headerlink" title="UIImageView"></a>UIImageView</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">&#x2F;&#x2F;初始化<br>UIImage *image &#x3D; [UIImage imageNamed:@&quot;test.png&quot;];<br>UIImageView  *imageView&#x3D;[[UIImageView alloc] initWithImage:image];                       <br>imageView.frame &#x3D; CGRectMake(100, 200, 120, 120);<br> <br>&#x2F;&#x2F;设置图片 UIImage<br> <br>&#x2F;&#x2F;第一种：<br>[imageView setImage:[UIImage imageNamed:@&quot;1.jpeg&quot;]];<br> <br>&#x2F;&#x2F;第二种：<br>NSString *filePath&#x3D;[[NSBundle mainBundle] pathForResource:@&quot;1&quot; ofType:@&quot;jpeg&quot;];<br>UIImage *images&#x3D;[UIImage imageWithContentsOfFile:filePath];<br>[imageView setImage:images]; <br> <br>&#x2F;&#x2F;第三种：<br>NSData *data&#x3D;[NSData dataWithContentsOfFile:filePath];<br>UIImage *image2&#x3D;[UIImage imageWithData:data];<br>[imageView setImage:image2];<br><br>UIImage *image &#x3D; [UIImage imageNamed:@&quot;test.png&quot;];<br>    &#123;<br>        UIImageView *imageView &#x3D; [[UIImageView alloc] initWithImage:image];<br>        imageView.frame &#x3D; CGRectMake(20, 100, 200, 200);<br>        &#x2F;&#x2F;    imageView.contentMode &#x3D; UIViewContentModeScaleAspectFill;<br>        imageView.clipsToBounds &#x3D; YES;<br>        imageView.backgroundColor &#x3D; [UIColor grayColor];<br>        [self.view addSubview:imageView];<br>    &#125;<br>    <br>    &#123;<br>        UIImageView *imageView &#x3D; [[UIImageView alloc] initWithImage:image];<br>        imageView.frame &#x3D; CGRectMake(20, 100+200+10, 200, 200);<br>        imageView.contentMode &#x3D; UIViewContentModeScaleAspectFit;<br>        imageView.clipsToBounds &#x3D; YES;<br>        imageView.backgroundColor &#x3D; [UIColor grayColor];<br>        [self.view addSubview:imageView];<br>    &#125;<br>    <br>    &#123;<br>        UIImageView *imageView &#x3D; [[UIImageView alloc] initWithImage:image];<br>        imageView.frame &#x3D; CGRectMake(20, 100+200+10 + 200 + 10, 200, 200);<br>        imageView.contentMode &#x3D; UIViewContentModeScaleAspectFill;<br>        imageView.clipsToBounds &#x3D; YES;<br>        imageView.backgroundColor &#x3D; [UIColor grayColor];<br>        [self.view addSubview:imageView];<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="图片资源加载规格"><a href="#图片资源加载规格" class="headerlink" title="图片资源加载规格"></a>图片资源加载规格</h4><ul><li>test.png 一倍屏加载</li><li><a href="mailto:&#x74;&#101;&#115;&#x74;&#64;&#50;&#120;&#46;&#112;&#x6e;&#103;">&#x74;&#101;&#115;&#x74;&#64;&#50;&#120;&#46;&#112;&#x6e;&#103;</a> 二倍屏加载</li><li><a href="mailto:&#x74;&#x65;&#115;&#116;&#x40;&#51;&#x78;&#46;&#x70;&#x6e;&#103;">&#x74;&#x65;&#115;&#116;&#x40;&#51;&#x78;&#46;&#x70;&#x6e;&#103;</a> 三倍屏加载</li></ul><p>优先查找相应的规格，否则查找最接近规格的资源</p><h4 id="contentMode-内容布局方式"><a href="#contentMode-内容布局方式" class="headerlink" title="contentMode 内容布局方式"></a>contentMode 内容布局方式</h4><ul><li>UIViewContentModeScaleToFill 完全填充（拉伸）</li><li>UIViewContentModeScaleAspectFit 等比例填充(不裁剪)</li><li>UIViewContentModeScaleAspectFill 等比例填满(会裁剪）</li></ul><h4 id="动态图"><a href="#动态图" class="headerlink" title="动态图"></a>动态图</h4><ul><li><strong>animationImages</strong> 动画的图片组</li><li><strong>animationDurations</strong> 动画时长</li><li><strong>anmationsRepeatCount</strong> 重复次数</li><li><strong>startAnimating</strong> 开始动画</li><li><strong>stopAnimating</strong> 停止动画</li><li><strong>isAnimating</strong>  是否正在动画</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">UIImage *image1 &#x3D; [UIImage imageNamed:@&quot;animation1.jpg&quot;];<br>  UIImage *image2 &#x3D; [UIImage imageNamed:@&quot;animation2.jpg&quot;];<br>  UIImage *image3 &#x3D; [UIImage imageNamed:@&quot;animation3.jpg&quot;];<br>  UIImageView *imageView &#x3D; [[UIImageView alloc] initWithImage:image1];<br>  imageView.animationImages &#x3D; @[image1, image2, image3];<br>  imageView.animationDuration &#x3D; 2;<br>  imageView.animationRepeatCount &#x3D; 100;<br>  imageView.frame &#x3D; CGRectMake(20, 100, 200, 200);<br>  [self.view addSubview:imageView];<br>  <br>  [imageView startAnimating];<br></code></pre></td></tr></table></figure><h3 id="UIButton"><a href="#UIButton" class="headerlink" title="UIButton"></a>UIButton</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">UISwitch *switchVie2 &#x3D; [[UISwitch alloc] initWithFrame:CGRectZero];<br>    switchVie2.center &#x3D; CGPointMake(200, 100);<br>    switchVie2.on &#x3D; YES;<br>    switchVie2.tintColor &#x3D; [UIColor blueColor];<br>    switchVie2.onTintColor &#x3D; [UIColor grayColor];<br>    switchVie2.thumbTintColor &#x3D; [UIColor purpleColor];<br>    [switchVie2 addTarget:self action:@selector(onSwitchChanged:) forControlEvents:UIControlEventValueChanged];<br>    [self.view addSubview:switchVie2];<br><br>- (void)viewDidLoad &#123;<br>    [super viewDidLoad];<br><br>    &#x2F;&#x2F;初始化按钮，设置按钮类型<br>    self.btn &#x3D; [UIButton buttonWithType:UIButtonTypeSystem];<br>    &#x2F;*<br>     Type:<br>     UIButtonTypeCustom &#x3D; 0, &#x2F;&#x2F; 自定义类型<br>     UIButtonTypeSystem NS_ENUM_AVAILABLE_IOS(7_0),  &#x2F;&#x2F; 系统类型<br>     UIButtonTypeDetailDisclosure,&#x2F;&#x2F;详细描述样式，圆圈中间加个i<br>     UIButtonTypeInfoLight, &#x2F;&#x2F;浅色的详细描述样式<br>     UIButtonTypeInfoDark,&#x2F;&#x2F;深色的详细描述样式<br>     UIButtonTypeContactAdd,&#x2F;&#x2F;加号样式<br>     UIButtonTypeRoundedRect &#x3D; UIButtonTypeSystem,   &#x2F;&#x2F; 圆角矩形<br>     *&#x2F;<br>    <br>    &#x2F;&#x2F;设置按钮位置和尺寸<br>    self.btn.frame &#x3D; CGRectMake(50, 50, 300, 50);<br><br>    &#x2F;&#x2F;设置按钮文字标题<br>    [self.btn setTitle:@&quot;我是一个按钮&quot; forState:UIControlStateNormal];<br>    &#x2F;*<br>     State:前三个较为常用<br>     UIControlStateNormal &#x2F;&#x2F;正常状态下<br>     UIControlStateHighlighted &#x2F;&#x2F;高亮状态下，按钮按下还未抬起的时候<br>     UIControlStateDisabled  &#x2F;&#x2F;按钮禁用状态下，不能使用<br>     UIControlStateSelected  &#x2F;&#x2F;选中状态下<br>     UIControlStateApplication &#x2F;&#x2F;当应用程序标志时<br>     UIControlStateReserved  &#x2F;&#x2F;为内部框架预留<br>     *&#x2F;<br>    <br>    &#x2F;&#x2F;设置按钮文字颜色<br>    [self.btn setTitleColor:[UIColor orangeColor] forState:UIControlStateNormal];<br>    <br>    &#x2F;&#x2F;设置背景图片（需要注意按钮类型最好为自定义，系统类型的会使图片变暗）<br>&#x2F;&#x2F;    [self.btn setImage:[UIImage imageNamed:@&quot;tupian&quot;] forState:UIControlStateNormal];<br>    <br>    &#x2F;&#x2F;设置按钮文字大小<br>    self.btn.titleLabel.font &#x3D; [UIFont systemFontOfSize:20];<br>    <br>    &#x2F;&#x2F;设按钮背景颜色<br>    self.btn.backgroundColor &#x3D; [UIColor cyanColor];<br>    <br>    &#x2F;&#x2F;设置按钮文字阴影颜色<br>    [self.btn setTitleShadowColor:[UIColor yellowColor] forState:UIControlStateNormal];<br>    <br>    &#x2F;&#x2F;默认情况下，在按钮被禁用时，图像会被画的颜色深一些。要禁用此功能，可以将这个属性设置为NO<br>    self.btn.adjustsImageWhenHighlighted &#x3D; NO;<br>    <br>    &#x2F;&#x2F;默认情况下，按钮在被禁用时，图像会被画的颜色淡一些。要禁用此功能，可以将这个属性设置为NO<br>    self.btn.adjustsImageWhenDisabled &#x3D; NO;<br>    <br>    &#x2F;&#x2F;下面的这个属性设置为yes的状态下，按钮按下会发光，这可以用于信息按钮或者有些重要的按钮<br>    self.btn.showsTouchWhenHighlighted &#x3D; YES;<br>    <br>    &#x2F;&#x2F;按钮响应点击事件，最常用的方法：第一个参数是目标对象，一般都是self； 第二个参数是一个SEL类型的方法；第三个参数是按钮点击事件<br>    [self.btn addTarget:self action:@selector(Method) forControlEvents:UIControlEventTouchUpInside];<br>    <br>    &#x2F;&#x2F;将控件添加到当前视图上<br>    [self.view addSubview:self.btn];<br>  <br>   &#x2F;&#x2F;setBackgroundImage:forState: 设置背景图片<br>  &#x2F;&#x2F;setImage:forState: 设置icon（默认左icon右文字,可通过imageEdgeInsets和titleEdgeInsets调整位置）<br>&#x2F;&#x2F;enabled和userInteractionEnabled  设置按钮是否禁用<br>&#125;<br>&#x2F;&#x2F;按钮响应事件<br>-(void)onButtonClick:(UIButton*)sender &#123;<br>  <br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="UISwitch"><a href="#UISwitch" class="headerlink" title="UISwitch"></a>UISwitch</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">onTintColor            UIColor          开状态下的颜色<br>tintColor              UIColor          关状态下的颜色<br>thumbTintColor          UIColor          滑块颜色<br>onImage                  UIImage          无效<br>offImage                UIImage          无效<br>on（ isOn）              BOOL             isOn是用来获取状态的是get方法，on可以用来设置开关<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">   &#x2F;&#x2F;2. create switch<br>    self.mainSwitch &#x3D; [[UISwitch alloc] initWithFrame:CGRectMake(100, 70, 0, 0)];<br>    [self.view addSubview:self.mainSwitch];<br><br>    &#x2F;&#x2F;缩小或者放大switch的size<br>    self.mainSwitch.transform &#x3D; CGAffineTransformMakeScale(0.5, 0.5);<br>    self.mainSwitch.layer.anchorPoint &#x3D; CGPointMake(0, 0.3);<br><br>&#x2F;&#x2F;    self.mainSwitch.onImage &#x3D; [UIImage imageNamed:@&quot;on.png&quot;];   &#x2F;&#x2F;无效<br>&#x2F;&#x2F;    self.mainSwitch.offImage &#x3D; [UIImage imageNamed:@&quot;off.png&quot;]; &#x2F;&#x2F;无效<br><br>&#x2F;&#x2F;    self.mainSwitch.backgroundColor &#x3D; [UIColor yellowColor];    &#x2F;&#x2F;它是矩形的<br><br>    &#x2F;&#x2F; 设置开关状态(默认是 关)<br>&#x2F;&#x2F;    self.mainSwitch.on &#x3D; YES;<br>    [self.mainSwitch setOn:YES animated:true];  &#x2F;&#x2F;animated<br><br>    &#x2F;&#x2F;判断开关的状态<br>    if (self.mainSwitch.on) &#123;<br>        NSLog(@&quot;switch is on&quot;);<br>    &#125; else &#123;<br>        NSLog(@&quot;switch is off&quot;);<br>    &#125;<br><br>    &#x2F;&#x2F;添加事件监听<br>    [self.mainSwitch addTarget:self action:@selector(switchAction:) forControlEvents:UIControlEventValueChanged];<br><br>    &#x2F;&#x2F;定制开关颜色UI<br>    &#x2F;&#x2F;tintColor 关状态下的背景颜色<br>    self.mainSwitch.tintColor &#x3D; [UIColor redColor];<br>    &#x2F;&#x2F;onTintColor 开状态下的背景颜色<br>    self.mainSwitch.onTintColor &#x3D; [UIColor yellowColor];<br>    &#x2F;&#x2F;thumbTintColor 滑块的背景颜色<br>    self.mainSwitch.thumbTintColor &#x3D; [UIColor blueColor];<br>UISwitch *switchView &#x3D; [[UISwitch alloc] initWithFrame:CGRectZero];<br>    switchView.center &#x3D; CGPointMake(100, 100);<br>    switchView.tintColor &#x3D; [UIColor blueColor];<br>    switchView.onTintColor &#x3D; [UIColor grayColor];<br>    switchView.thumbTintColor &#x3D; [UIColor purpleColor];<br>    [switchView addTarget:self action:@selector(onSwitchChanged:) forControlEvents:UIControlEventValueChanged];<br>    [self.view addSubview:switchView];<br><br>UISwitch *switchVie2 &#x3D; [[UISwitch alloc] initWithFrame:CGRectZero];<br>    switchVie2.center &#x3D; CGPointMake(200, 100);<br>    switchVie2.on &#x3D; YES;<br>    switchVie2.tintColor &#x3D; [UIColor blueColor];<br>    switchVie2.onTintColor &#x3D; [UIColor grayColor];<br>    switchVie2.thumbTintColor &#x3D; [UIColor purpleColor];<br>    [switchVie2 addTarget:self action:@selector(onSwitchChanged:) forControlEvents:UIControlEventValueChanged];<br>    [self.view addSubview:switchVie2];<br></code></pre></td></tr></table></figure><h3 id="UITextField"><a href="#UITextField" class="headerlink" title="UITextField"></a>UITextField</h3><h4 id="常用属性介绍"><a href="#常用属性介绍" class="headerlink" title="常用属性介绍"></a>常用属性介绍</h4><ul><li>placeHolder 占位文本</li><li>returnkeyType 回车类型</li><li>keyboardType  键盘类型</li><li>clearButtonMode 清空按钮模式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">UITextField *textField &#x3D; [[UITextField alloc] initWithFrame:CGRectMake(20, 100, 200, 30)];<br>  textField.placeholder &#x3D; @&quot;输入点什么吧&quot;;<br>  textField.borderStyle &#x3D; UITextBorderStyleRoundedRect;<br>  textField.autocorrectionType &#x3D; UITextAutocorrectionTypeYes;<br>  textField.returnKeyType &#x3D; UIReturnKeyDone;<br>  textField.keyboardType &#x3D; UIKeyboardTypePhonePad;<br>  textField.clearButtonMode &#x3D; UITextFieldViewModeWhileEditing;<br>  textField.delegate &#x3D; self;<br>  [self.view addSubview:textField];<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@optional<br><br>- (BOOL)textFieldShouldBeginEditing:(UITextField *)textField;        &#x2F;&#x2F; return NO to disallow editing.是否允许开始编辑<br>- (void)textFieldDidBeginEditing:(UITextField *)textField;           &#x2F;&#x2F; became first responder是否完成编辑<br>- (BOOL)textFieldShouldEndEditing:(UITextField *)textField;          &#x2F;&#x2F; return YES to allow editing to stop and to resign first responder status. NO to disallow the editing session to end是否允许结束编辑<br>- (void)textFieldDidEndEditing:(UITextField *)textField;             &#x2F;&#x2F; may be called if forced even if shouldEndEditing returns NO (e.g. view removed from window) or endEditing:YES called完成结束编辑<br>- (void)textFieldDidEndEditing:(UITextField *)textField reason:(UITextFieldDidEndEditingReason)reason NS_AVAILABLE_IOS(10_0); &#x2F;&#x2F; if implemented, called in place of textFieldDidEndEditing:<br><br>- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string;   &#x2F;&#x2F; return NO to not change text是否改变字符串<br><br>- (BOOL)textFieldShouldClear:(UITextField *)textField;               &#x2F;&#x2F; called when clear button pressed. return NO to ignore (no notifications)是否允许清空<br>- (BOOL)textFieldShouldReturn:(UITextField *)textField;              &#x2F;&#x2F; called when &#39;return&#39; key pressed. return NO to ignore.是否允许回车<br><br>@end<br></code></pre></td></tr></table></figure><h3 id="UITextView"><a href="#UITextView" class="headerlink" title="UITextView"></a>UITextView</h3><h4 id="常用属性介绍-1"><a href="#常用属性介绍-1" class="headerlink" title="常用属性介绍"></a>常用属性介绍</h4><ul><li>scrollEnabled 是否允许滚动</li><li>textAlignment 字符对齐方式</li><li>text 普通文本</li><li>attributedText 富文本</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">UITextView *textView &#x3D; [[UITextView alloc] initWithFrame:CGRectMake(10, 100, 400, 400)];<br>  textView.text &#x3D; @&quot;欢迎来到UITextView的世界！欢迎来到UITextView的世界！欢迎来到UITextView的世界！&quot;;<br>  textView.font &#x3D; [UIFont systemFontOfSize:20];<br>  textView.textColor &#x3D; [UIColor blackColor];<br>  textView.backgroundColor &#x3D; [UIColor grayColor];<br>  textView.scrollEnabled &#x3D; YES;<br>  textView.textAlignment &#x3D; NSTextAlignmentLeft;<br>  textView.delegate &#x3D; self;<br>  [self.view addSubview:textView];<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@protocol UITextViewDelegate &lt;NSObject, UIScrollViewDelegate&gt;<br><br>@optional<br><br>- (BOOL)textViewShouldBeginEditing:(UITextView *)textView;&#x2F;&#x2F;是否允许开始编辑<br>- (BOOL)textViewShouldEndEditing:(UITextView *)textView;&#x2F;&#x2F;是否允许结束编辑<br><br>- (void)textViewDidBeginEditing:(UITextView *)textView;&#x2F;&#x2F;完成开始编辑<br>- (void)textViewDidEndEditing:(UITextView *)textView;&#x2F;&#x2F;结束开始编辑<br><br>- (BOOL)textView:(UITextView *)textView shouldChangeTextInRange:(NSRange)range replacementText:(NSString *)text;&#x2F;&#x2F;是否允许替换文本<br>- (void)textViewDidChange:(UITextView *)textView;&#x2F;&#x2F;文本发生改变<br><br>- (void)textViewDidChangeSelection:(UITextView *)textView;&#x2F;&#x2F;某个范围文本发生改变<br></code></pre></td></tr></table></figure><h2 id="UITableView"><a href="#UITableView" class="headerlink" title="UITableView"></a>UITableView</h2><p>UITableView是一个列表控件，广泛运用于App的各个界面。其本质是垂直方向滚动的ScrollView。<a href="https://www.cnblogs.com/zhenzhen123/p/5071743.html">参考博客</a></p><p>UITableView有两种风格：</p><ul><li>UITableViewStylePlain</li><li>UITableViewStyleGrouped</li></ul><h3 id="UITableView结构"><a href="#UITableView结构" class="headerlink" title="UITableView结构"></a>UITableView结构</h3><ul><li><p>TableHeader（绿色区域）</p></li><li><p>Section 分组</p></li><li><ul><li>Header 头部</li><li>Row 行内容</li><li>Footer 尾部</li></ul></li><li><p>Section 分组</p></li><li><ul><li>Header</li><li>Row 行内容</li><li>Footer</li></ul></li><li><p>TableFooter (蓝色区域)</p></li></ul><h3 id="tableView如何展示数据："><a href="#tableView如何展示数据：" class="headerlink" title="tableView如何展示数据："></a>tableView如何展示数据：</h3><ul><li>UITableView需要一个数据源(dataSource)来显示数据</li><li>UITableView会向数据源查询一共有多少行数据以及每一行显示什么数据等</li><li>没有设置数据源的UITableView只是个空壳</li><li>凡是遵守UITableViewDataSource协议的OC对象，都可以是UITableView的数据源</li></ul><h2 id="Cell的重用原理："><a href="#Cell的重用原理：" class="headerlink" title="Cell的重用原理："></a>Cell的重用原理：</h2><p>iOS设备的内存有限，如果用UITableView显示成千上万条数据，就需要成千上万个UITableViewCell对象的话，那将会耗尽iOS设备的内存。要解决该问题，需要重用UITableViewCell对象。</p><p><strong>重用原理：</strong>当滚动列表时，部分UITableViewCell会移出窗口，UITableView会将窗口外的UITableViewCell放入一个缓存池中，等待重用。当UITableView要求dataSource返回UITableViewCell时，dataSource会先查看这个缓存池，如果池中有未使用的UITableViewCell，dataSource会用新的数据配置这个UITableViewCell，然后返回给UITableView，重新显示到窗口中，从而避免创建新对象。</p><h3 id="通过代码自定义cell-cell的高度不一致-："><a href="#通过代码自定义cell-cell的高度不一致-：" class="headerlink" title="通过代码自定义cell(cell的高度不一致)："></a>通过代码自定义cell(cell的高度不一致)：</h3><p>这里提供的思路并未使用自动布局，是纯手码计算frame。</p><ul><li>1.新建一个继承自UITableViewCell的类。</li><li>2.重写initWithStyle:reuseIdentifier:方法<ul><li>添加所有需要显示的子控件(不需要设置子控件的数据和frame, 子控件要添加到contentView中)</li><li>进行子控件一次性的属性设置(有些属性只需要设置一次, 比如字体、固定的图片)</li></ul></li><li>3.提供2个模型<ul><li>数据模型: 存放文字数据、图片数据</li><li>frame模型: 存放数据模型、所有子控件的frame、cell的高度</li></ul></li><li>4.cell拥有一个frame模型(不要直接拥有数据模型)</li><li>5.重写frame模型属性的setter方法: 在这个方法中设置子控件的显示数据和frame</li><li>6.frame模型数据的初始化已经采取懒加载的方式(每一个cell对应的frame模型数据只加载一次)</li></ul><h3 id="UITableView的常见属性："><a href="#UITableView的常见属性：" class="headerlink" title="UITableView的常见属性："></a>UITableView的常见属性：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">&#x2F;* tableView的样式 *&#x2F;<br>@property (nonatomic, readonly) UITableViewStyle style;<br>&#x2F;&#x2F; tableView有两种样式<br>&#x2F;&#x2F;     UITableViewStylePlain  普通的表格样式<br>&#x2F;&#x2F;    UITableViewStyleGrouped  分组模式<br><br>&#x2F;* tableView的数据源 *&#x2F;<br>@property (nonatomic, weak, nullable) id &lt;UITableViewDataSource&gt; dataSource;<br>&#x2F;* tableView的代理 *&#x2F;<br>@property (nonatomic, weak, nullable) id &lt;UITableViewDelegate&gt; delegate;<br><br>#pragma mark - 高度相关<br>&#x2F;* tableView每一行的高度，默认为44 *&#x2F;<br>@property (nonatomic) CGFloat rowHeight;<br>&#x2F;* tableView统一的每一组头部的高度 *&#x2F;<br>@property (nonatomic) CGFloat sectionHeaderHeight;<br>&#x2F;* tableView统一的每一组头部的高度 *&#x2F;<br>@property (nonatomic) CGFloat sectionFooterHeight;<br>&#x2F;* 估算的tableView的统一的每一行行高 *&#x2F;<br>@property (nonatomic) CGFloat estimatedRowHeight;<br>&#x2F;* 估算的统一的每一组头部高度，设置估算高度可以优化性能 *&#x2F;<br>@property (nonatomic) CGFloat estimatedSectionHeaderHeight;<br>&#x2F;* 估算的统一的每一组的尾部高度 *&#x2F;<br>@property (nonatomic) CGFloat estimatedSectionFooterHeight;<br><br>&#x2F;* 总共有多少组 *&#x2F;<br>@property (nonatomic, readonly) NSInteger numberOfSections;<br>&#x2F;* 选中行的indexPath *&#x2F;<br>@property (nonatomic, readonly, nullable) NSIndexPath *indexPathForSelectedRow;<br><br>#pragma mark - 索引条<br>&#x2F;* 索引条文字的颜色 *&#x2F;<br>@property (nonatomic, strong, nullable) UIColor *sectionIndexColor;<br>&#x2F;* 索引条的背景色 *&#x2F;<br>@property (nonatomic, strong, nullable) UIColor *sectionIndexBackgroundColor;<br><br>#pragma mark - 分隔线<br>&#x2F;* 分隔线的样式 *&#x2F;<br>@property (nonatomic) UITableViewCellSeparatorStyle separatorStyle;<br>&#x2F;&#x2F; 分隔线的样式有：<br>&#x2F;&#x2F; UITableViewCellSeparatorStyleNone,  没有分隔线<br>&#x2F;&#x2F; UITableViewCellSeparatorStyleSingleLine, 正常分隔线<br>@property (nonatomic, strong, nullable) UIColor *separatorColor; &#x2F;&#x2F; 分隔线的颜色<br><br>#pragma mark - 头尾部控件<br>&#x2F;* tableView的头部控件，只能设置高度，宽度默认填充表格 *&#x2F;<br>@property (nonatomic, strong, nullable) UIView *tableHeaderView;<br>&#x2F;* tableView的尾部控件，只能设置高度，宽度默认填充表格*&#x2F;<br>@property (nonatomic, strong, nullable) UIView *tableFooterView;<br><br>#pragma mark - 编辑模式<br>&#x2F;* 是否是编辑模式，默认是NO *&#x2F;<br>@property (nonatomic, getter&#x3D;isEditing) BOOL editing;<br>&#x2F;* tableView处在编辑模式的时候是否允许选中行，默认是NO *&#x2F;<br>@property (nonatomic) BOOL allowsSelectionDuringEditing;<br>&#x2F;* tableView处在编辑模式的时候是否允许选中多行数据，默认是NO *&#x2F;<br>@property (nonatomic) BOOL allowsMultipleSelectionDuringEditing;<br></code></pre></td></tr></table></figure><h3 id="UITableViewCell的常见属性："><a href="#UITableViewCell的常见属性：" class="headerlink" title="UITableViewCell的常见属性："></a>UITableViewCell的常见属性：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">#pragma mark - Cell内部子控件<br>&#x2F;*  默认为nil，imageView是懒加载，用到时才加载 *&#x2F;<br>@property (nonatomic, readonly, strong, nullable) UIImageView *imageView;<br>&#x2F;* 默认为nil，是懒加载，用到时才加载 *&#x2F;<br>@property (nonatomic, readonly, strong, nullable) UILabel *textLabel;<br>&#x2F;* 只有当Cell的样式为UITableViewCellStyleSubtitle时才会显示出来，默认为nil，是懒加载，用到时才加载 *&#x2F;<br>@property (nonatomic, readonly, strong, nullable) UILabel *detailTextLabel;<br><br>&#x2F;* 当你想要自定义一个cell的时候，子控件最好添加到cell的contentView上，方便编辑表格 *&#x2F;<br>@property (nonatomic, readonly, strong) UIView *contentView;<br><br>&#x2F;* cell的复用标识 *&#x2F;<br>@property (nonatomic, readonly, copy, nullable) NSString *reuseIdentifier;<br><br>&#x2F;* cell的选中样式 *&#x2F;<br>@property (nonatomic) UITableViewCellSelectionStyle   selectionStyle;<br>&#x2F;* cell是否是选中状态 *&#x2F;<br>@property (nonatomic, getter&#x3D;isSelected) BOOL         selected;<br><br>&#x2F;* cell的编辑样式，默认是UITableViewCellEditingStyleNone *&#x2F;<br>@property (nonatomic, readonly) UITableViewCellEditingStyle editingStyle;<br>&#x2F;&#x2F; cell的编辑样式有：<br>&#x2F;&#x2F; UITableViewCellEditingStyleNone,<br>&#x2F;&#x2F; UITableViewCellEditingStyleDelete, 删除模式<br>&#x2F;&#x2F; UITableViewCellEditingStyleInsert   插入模式<br><br>&#x2F;* 指示器的样式，默认是UITableViewCellAccessoryNone *&#x2F;<br>@property (nonatomic) UITableViewCellAccessoryType    accessoryType;<br>&#x2F;&#x2F; 指示器的样式有：<br>&#x2F;&#x2F; UITableViewCellAccessoryNone   不显示指示器<br>&#x2F;&#x2F; UITableViewCellAccessoryDisclosureIndicator cell右侧显示一个箭头<br>&#x2F;&#x2F; UITableViewCellAccessoryDetailDisclosureButton cell右侧显示一个箭头和一个详情图标<br>&#x2F;&#x2F; UITableViewCellAccessoryCheckmark cell右侧显示一个对勾<br>&#x2F;&#x2F; UITableViewCellAccessoryDetailButton cell右侧显示一个详情图标<br><br>&#x2F;* cell右侧指示器view，设置了以后，cell的accessoryType就会失效  *&#x2F;<br>@property (nonatomic, strong, nullable) UIView       *accessoryView;<br></code></pre></td></tr></table></figure><h3 id="UITableView的常用方法："><a href="#UITableView的常用方法：" class="headerlink" title="UITableView的常用方法："></a>UITableView的常用方法：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">&#x2F;* 全局刷新 *&#x2F;<br>- (void)reloadData;<br>&#x2F;* 刷新索引条 *&#x2F;<br>- (void)reloadSectionIndexTitles;<br><br>&#x2F;* 返回第section组有多少行 *&#x2F;<br>- (NSInteger)numberOfRowsInSection:(NSInteger)section;<br>&#x2F;* 返回indexPath对应的那一行的cell *&#x2F;<br>- (nullable __kindof UITableViewCell *)cellForRowAtIndexPath:(NSIndexPath *)indexPath;<br><br>&#x2F;* 返回第section组的头部view *&#x2F;<br>- (nullable UITableViewHeaderFooterView *)headerViewForSection:(NSInteger)section;<br>&#x2F;* 返回第section组的尾部view *&#x2F;<br>- (nullable UITableViewHeaderFooterView *)footerViewForSection:(NSInteger)section;<br><br>&#x2F;**<br> *  插入数据,刷新数据<br> *  @param indexPaths 插入在哪个位置<br> *  @param animation  动画效果，枚举UITableViewRowAnimation<br> *&#x2F;<br>- (void)insertRowsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;<br><br>&#x2F;**<br> *  删除数据<br> *  @param indexPaths 删除数据的位置<br> *  @param animation  动画效果，枚举UITableViewRowAnimation<br> *&#x2F;<br>- (void)deleteRowsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;<br>&#x2F;&#x2F; 枚举UITableViewRowAnimation包括：<br>&#x2F;&#x2F; UITableViewRowAnimationFade,  淡入淡出<br>&#x2F;&#x2F; UITableViewRowAnimationRight,  向右滑动<br>&#x2F;&#x2F; UITableViewRowAnimationLeft,  向左滑动<br>&#x2F;&#x2F; UITableViewRowAnimationTop,  向上滑动<br>&#x2F;&#x2F; UITableViewRowAnimationBottom,  向下滑动<br>&#x2F;&#x2F; UITableViewRowAnimationNone,  无动画效果,iOS 3.0以后可用<br>&#x2F;&#x2F; UITableViewRowAnimationMiddle,  保持cell的中间，iOS 3.2以后可用<br>&#x2F;&#x2F; UITableViewRowAnimationAutomatic  自动选择一个合适的动画效果<br><br>&#x2F;**<br> *  刷新某一行的数据<br> *  @param indexPaths 刷新数据的位置<br> *  @param animation  动画效果，枚举UITableViewRowAnimation<br> *&#x2F;<br>- (void)reloadRowsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;<br><br>&#x2F;** 动画开启&#x2F;关闭编辑模式 *&#x2F;<br>- (void)setEditing:(BOOL)editing animated:(BOOL)animated;<br><br>&#x2F;** 返回一个带有复用标识的cell *&#x2F;<br>- (nullable __kindof UITableViewCell *)dequeueReusableCellWithIdentifier:(NSString *)identifier;<br><br>&#x2F;**<br> *  使用xib时注册自定义的cell<br> *  @param nib        要注册的nib<br> *  @param identifier 复用标识<br> *&#x2F;<br>- (void)registerNib:(nullable UINib *)nib forCellReuseIdentifier:(NSString *)identifier;<br><br>&#x2F;**<br> *   代码自定义cell时注册自定义的cell<br> *  @param cellClass  注册的自定义cell的类型<br> *  @param identifier 复用标识<br> *&#x2F;<br>- (void)registerClass:(nullable Class)cellClass forCellReuseIdentifier:(NSString *)identifier;<br><br>&#x2F;** 初始化一个带有复用标识的cell *&#x2F;<br>- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(nullable NSString *)reuseIdentifier<br></code></pre></td></tr></table></figure><h3 id="UITableViewDataSource中的常用方法"><a href="#UITableViewDataSource中的常用方法" class="headerlink" title="UITableViewDataSource中的常用方法:"></a>UITableViewDataSource中的常用方法:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">&#x2F;&#x2F; 必须实现的方法：<br>&#x2F;* 设置第section组有多少行数据 *&#x2F;<br>- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section;<br>&#x2F;* 设置每一行cell的内容，每当有一个cell进入视野屏幕的时候就会调用这个方法，所以在这个方法内部进行优化（cell的复用） *&#x2F;<br>- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath;<br><br>&#x2F;&#x2F; 可实现可不实现的方法：<br>&#x2F;* 总共有多少组，如果不实现，默认是一组 *&#x2F;<br>- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView;<br><br>&#x2F;* 第section组的头部标题 *&#x2F;<br>- (nullable NSString *)tableView:(UITableView *)tableView titleForHeaderInSection:(NSInteger)section;<br>&#x2F;* 第section组的尾部标题 *&#x2F;<br>- (nullable NSString *)tableView:(UITableView *)tableView titleForFooterInSection:(NSInteger)section;<br><br>&#x2F;** 设置索引条 *&#x2F;<br>- (nullable NSArray&lt;NSString *&gt; *)sectionIndexTitlesForTableView:(UITableView *)tableView;<br></code></pre></td></tr></table></figure><h3 id="UITableViewDelegate中的常用方法："><a href="#UITableViewDelegate中的常用方法：" class="headerlink" title="UITableViewDelegate中的常用方法："></a>UITableViewDelegate中的常用方法：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">&#x2F;** 设置每一行cell的高度 *&#x2F;<br>- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath;<br>&#x2F;** 设置第section组的头部高度 *&#x2F;<br>- (CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section;<br>&#x2F;** 设置第section组的尾部高度 *&#x2F;<br>- (CGFloat)tableView:(UITableView *)tableView heightForFooterInSection:(NSInteger)section;<br><br>&#x2F;** 每一行的估算高度 *&#x2F;<br>- (CGFloat)tableView:(UITableView *)tableView estimatedHeightForRowAtIndexPath:(NSIndexPath *)indexPath;<br><br>&#x2F;** 设置第section组的headerView *&#x2F;<br>- (nullable UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section;<br>&#x2F;** 设置第section组的footerView *&#x2F;<br>- (nullable UIView *)tableView:(UITableView *)tableView viewForFooterInSection:(NSInteger)section;<br><br>&#x2F;** 选中了某一行cell的时候就会调用这个方法 *&#x2F;<br>- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath;<br><br>&#x2F;**<br> *  设置左滑删除按钮的文字<br> *  @param tableView         被编辑的tableView<br> *  @param indexPath         indexPath<br> *  @return 返回删除按钮显示的文字<br> *&#x2F;<br>- (nullable NSString *)tableView:(UITableView *)tableView titleForDeleteConfirmationButtonForRowAtIndexPath:(NSIndexPath *)indexPath;<br><br>&#x2F;**<br> *  创建一个左滑出现按钮的操作（UITableViewRowAction）数组<br> *  @param tableView         添加操作的tableView<br> *  @param indexPath         indexPath，可以指定每一行有不同的效果<br> *  @return 返回一个操作（UITableViewRowAction）数组<br> *&#x2F;<br>- (nullable NSArray&lt;UITableViewRowAction *&gt; *)tableView:(UITableView *)tableView editActionsForRowAtIndexPath:(NSIndexPath *)indexPath;<br><br>&#x2F;**<br> *  移动cell<br> *  @param tableView            操作的tableView<br> *  @param sourceIndexPath      移动的行<br> *  @param destinationIndexPath 目标行<br> *&#x2F;<br>- (void)tableView:(UITableView *)tableView moveRowAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath;<br><br>&#x2F;** 根据editingStyle处理是删除还是添加操作，完成删除、插入操作刷新表格 *&#x2F;<br>- (void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath;<br><br>&#x2F;**<br> *  设置表格编辑模式，不实现默认都是删除<br> *  @param tableView 操作的tableView<br> *  @param indexPath cell的位置<br> *  @return 返回表格编辑样式<br> *&#x2F;<br>- (UITableViewCellEditingStyle)tableView:(UITableView *)tableView editingStyleForRowAtIndexPath:(NSIndexPath *)indexPath;<br></code></pre></td></tr></table></figure><h2 id="UIViewController"><a href="#UIViewController" class="headerlink" title="UIViewController"></a>UIViewController</h2><h3 id="UIViewController简介"><a href="#UIViewController简介" class="headerlink" title="UIViewController简介"></a>UIViewController简介</h3><p>ViewController是iOS应用程序中重要的部分，是应用程序数据和视图之间的重要桥梁，ViewController管理应用中的众多视图。</p><h4 id="ViewController分类"><a href="#ViewController分类" class="headerlink" title="ViewController分类"></a>ViewController分类</h4><ul><li>展示型ViewController<ul><li>UIViewController 基类，自定义视图</li><li>UITableViewController  垂直列表视图</li><li>UICollectionViewController  垂直和水平列表视图</li><li>UIActivityViewController  系统分享视图</li><li>UIAlertController     AlertView和ActionSheet</li><li>UISearchController  搜索</li><li>UIInputViewController  自定义键盘容器</li></ul></li><li>容器型ViewController<ul><li>UINavigationController 导航控制器</li><li>UITabbarController     选项卡控制器</li><li>UIPageViewController  多页面控制器（多用于App启动闪屏）</li><li>UISplitViewController    分割控制器（用于iPad）</li></ul></li></ul><h3 id="生命周期各个步骤"><a href="#生命周期各个步骤" class="headerlink" title="生命周期各个步骤"></a>生命周期各个步骤</h3><ul><li>init  初始化</li><li>loadView()  自定义加载视图</li><li>viewDidLoad() 视图加载完成</li><li>viewWillLayoutSubviews() 将要subview布局</li><li>viewDidLayoutSubviews() 完成subview布局</li><li>viewWillAppear(_:) 视图将要显示（过场动画即将开始）</li><li>viewDidAppear(_:) 视图显示结束（过场动画结束）</li><li>viewWillDisappear(_:) 视图将要消失</li><li>viewDidDisappear(_:) 视图消失结束</li><li>didReceiveMemoryWarning() 内存警告（正在显示的界面不会收到）</li><li>dealloc 销毁</li></ul><h2 id="UINavigationController"><a href="#UINavigationController" class="headerlink" title="UINavigationController"></a>UINavigationController</h2><p>UINavigationController即导航控制器，用来管理视图控制器。它以栈的形式管理视图控制器，管理视图控制器个数理论上不受限制(实际受内存限制)，push和pop方法来弹入弹出控制器，最多只能显示一个视图控制器，那就是处于栈顶的视图控制器。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UI </tag>
            
            <tag> Objective-C </tag>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/IOS/FMDB/"/>
      <url>/IOS/FMDB/</url>
      
        <content type="html"><![CDATA[<h2 id="FMDB"><a href="#FMDB" class="headerlink" title="FMDB"></a>FMDB</h2><a id="more"></a><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><strong>定义</strong></p><ul><li><p>FMDB是iOS平台的开源SQLite数据库框架</p></li><li><p>FMDB以OC的方式封装了SQLite的C语言API</p></li></ul><p><strong>优点</strong></p><ul><li>使用起来更加面向对象，省去了很多麻烦、冗余的C语言代码</li><li>对比苹果自带的Core Data框架，更加轻量级和灵活</li><li>提供了多线程安全的数据库操作方法，有效地防止数据混乱</li></ul><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><strong>主要的类</strong></p><ul><li><code>FMDatabase</code>：一个``FMDatabase`对象就代表一个单独的SQLite数据库用来执行SQL语句</li><li><code>FMResultSet</code>：使用``FMDatabase`执行查询后的结果集</li><li><code>FMDatabaseQueue</code>：用于在多线程中执行多个查询或更新，是线程安全的</li></ul><h3 id="数据库使用"><a href="#数据库使用" class="headerlink" title="数据库使用"></a>数据库使用</h3><h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><p>通过指定SQLite数据库文件路径来创建<code>FMDatabase</code>对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">FMDatabase *db &#x3D; [FMDatabase databaseWithPath:path];<br><br>if (![db open]) &#123;<br><br>    NSLog(@&quot;数据库打开失败！&quot;);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>文件路径有三种情况</p><ul><li>具体文件路径：如果不存在会自动创建</li><li>空字符串@””：会在临时目录创建一个空的数据库，当``FMDatabase`连接关闭时，数据库文件也被删除 </li><li>nil：会创建一个内存中临时数据库，当<code>FMDatabase</code>连接关闭时，数据库会被销毁</li></ul><h4 id="更新数据库"><a href="#更新数据库" class="headerlink" title="更新数据库"></a>更新数据库</h4><p>create、drop、insert、update、delete</p><p> 使用``executeUpdate`:方法执行更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">- (BOOL)executeUpdate:(NSString*)sql, ...<br><br>- (BOOL)executeUpdateWithFormat:(NSString*)format, ...<br><br>- (BOOL)executeUpdate:(NSString*)sql withArgumentsInArray:(NSArray *)arguments<br><br>[db executeUpdate:@&quot;UPDATE t_student SET age &#x3D; ? WHERE name &#x3D; ?;&quot;, @20, @&quot;Jack&quot;]<br></code></pre></td></tr></table></figure><h4 id="查询数据库"><a href="#查询数据库" class="headerlink" title="查询数据库"></a>查询数据库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">- (FMResultSet *)executeQuery:(NSString*)sql, ...<br><br>- (FMResultSet *)executeQueryWithFormat:(NSString*)format, ...<br><br>- (FMResultSet *)executeQuery:(NSString *)sql withArgumentsInArray:(NSArray *)arguments<br>    <br>&#x2F;&#x2F; 查询数据<br>FMResultSet *rs &#x3D; [db executeQuery:@&quot;SELECT * FROM t_student&quot;];<br><br>&#x2F;&#x2F; 遍历结果集<br>while ([rs next]) &#123;<br>    NSString *name &#x3D; [rs stringForColumn:@&quot;name&quot;];<br>    int age &#x3D; [rs intForColumn:@&quot;age&quot;];<br>    double score &#x3D; [rs doubleForColumn:@&quot;score&quot;];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">&#x2F;&#x2F;1.获取数据库文件的路径<br>_docPath &#x3D; [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];<br>NSLog(@&quot;%@&quot;,_docPath);<br>mark_student &#x3D; 1;<br>&#x2F;&#x2F;设置数据库名称<br>NSString *fileName &#x3D; [_docPath stringByAppendingPathComponent:@&quot;数据库名称.sqlite&quot;];<br><br>&#x2F;&#x2F;2.获取数据库<br> _db &#x3D; [FMDatabase databaseWithPath:fileName];<br>if ([_db open]) &#123;<br>    NSLog(@&quot;打开数据库成功&quot;);<br>&#125; else &#123;<br>    NSLog(@&quot;打开数据库失败&quot;);<br>&#125;<br><br>&#x2F;&#x2F;3.创建表<br>BOOL result &#x3D; [_db executeUpdate:@&quot;CREATE TABLE IF NOT EXISTS t_student(表名称) (id integer PRIMARY KEY AUTOINCREMENT, name text NOT NULL, age integer NOT NULL, sex text NOT NULL);&quot;];<br>if (result) &#123;  <br>  NSLog(@&quot;创建表成功&quot;);<br>&#125; else &#123;<br>  NSLog(@&quot;创建表失败&quot;);<br>&#125;<br><br>&#x2F;&#x2F;插入数据<br>&#x2F;&#x2F;1.executeUpdate:不确定的参数用？来占位（后面参数必须是oc对象，；代表语句结束）<br>BOOL result &#x3D; [_db executeUpdate:@&quot;INSERT INTO t_student(表名) (name, age, sex) VALUES (?,?,?)&quot;,name,@(age),sex];<br>&#x2F;&#x2F;2.executeUpdateWithForamat：不确定的参数用%@，%d等来占位 （参数为原始数据类型，执行语句不区分大小写）<br>    BOOL result &#x3D; [_db executeUpdateWithFormat:@&quot;insert into t_student(表名) (name,age, sex) values (%@,%i,%@)&quot;,name,age,sex];<br>&#x2F;&#x2F;3.参数是数组的使用方式<br>    BOOL result &#x3D; [_db executeUpdate:@&quot;INSERT INTO t_student(表名)(name,age,sex) VALUES  (?,?,?);&quot; withArgumentsInArray:@[name,@(age),sex]];<br>if (result) &#123;<br>    NSLog(@&quot;插入成功&quot;);<br>&#125; else &#123;<br>    NSLog(@&quot;插入失败&quot;);<br>&#125;<br><br>&#x2F;&#x2F;删除数据<br>&#x2F;&#x2F;1.不确定的参数用？来占位 （后面参数必须是oc对象,需要将int包装成OC对象）<br>int idNum &#x3D; 11;<br>BOOL result &#x3D; [_db executeUpdate:@&quot;delete from t_student where id &#x3D; ?&quot;,@(idNum)];<br>&#x2F;&#x2F;2.不确定的参数用%@，%d等来占位<br>&#x2F;&#x2F;BOOL result &#x3D; [_db executeUpdateWithFormat:@&quot;delete from t_student where name &#x3D; %@&quot;,@&quot;王二&quot;];<br>if (result) &#123;<br>    NSLog(@&quot;删除成功&quot;);<br>&#125; else &#123;<br>    NSLog(@&quot;删除失败&quot;);<br>&#125;<br><br>&#x2F;&#x2F;修改数据<br>&#x2F;&#x2F;修改学生的名字<br>NSString *newName &#x3D; @&quot;张三&quot;;<br>NSString *oldName &#x3D; @&quot;王二&quot;;<br>BOOL result &#x3D; [_db executeUpdate:@&quot;update t_student set name &#x3D; ? where name &#x3D; ?&quot;,newName,oldName];<br>if (result) &#123;<br>  NSLog(@&quot;修改成功&quot;);<br>&#125; else &#123;<br>  NSLog(@&quot;修改失败&quot;);<br>&#125;<br><br>&#x2F;&#x2F;查询数据<br>&#x2F;&#x2F;查询整个表<br>FMResultSet * resultSet &#x3D; [_db executeQuery:@&quot;select * from t_student&quot;];<br>&#x2F;&#x2F;根据条件查询<br>&#x2F;&#x2F;FMResultSet * resultSet &#x3D; [_db executeQuery:@&quot;select * from t_student where id &lt; ?&quot;, @(4)];<br>&#x2F;&#x2F;遍历结果集合<br>while ([resultSet next]) &#123;<br>     int idNum &#x3D; [resultSet intForColumn:@&quot;id&quot;];<br>     NSString *name &#x3D; [resultSet objectForColumnName:@&quot;name&quot;];<br>     int age &#x3D; [resultSet intForColumn:@&quot;age&quot;];<br>     NSString *sex &#x3D; [resultSet objectForColumnName:@&quot;sex&quot;];<br>     NSLog(@&quot;学号：%@ 姓名：%@ 年龄：%@ 性别：%@&quot;,@(idNum),name,@(age),sex);<br>&#125;<br><br>&#x2F;&#x2F;删除表<br>&#x2F;&#x2F;如果表格存在 则销毁<br>BOOL result &#x3D; [_db executeUpdate:@&quot;drop table if exists t_student&quot;];<br>if (result) &#123;<br>  NSLog(@&quot;删除表成功&quot;);<br>&#125; else &#123;<br>  NSLog(@&quot;删除表失败&quot;);<br>&#125;<br><br>&#x2F;&#x2F;关闭数据库<br>BOOL result &#x3D; [db close];<br>if(result)&#123;<br>NSLog(@&quot;数据库关闭成功&quot;);<br>&#125;<br>else &#123;<br>NSLog(@&quot;数据库关闭失败&quot;);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Objective-C </tag>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络编程与本地存储</title>
      <link href="/IOS/Network%20programming%20and%20local%20storage/"/>
      <url>/IOS/Network%20programming%20and%20local%20storage/</url>
      
        <content type="html"><![CDATA[<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="NSURLSession"><a href="#NSURLSession" class="headerlink" title="NSURLSession"></a>NSURLSession</h3><a id="more"></a><h4 id="发起一个Get请求"><a href="#发起一个Get请求" class="headerlink" title="发起一个Get请求"></a>发起一个Get请求</h4><ul><li>构建Request对象。</li><li>创建Session。</li><li>创建NSURLSessionDataTask。</li><li>执行Task</li><li>Response处理。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">-(void) sendHTTPPost<br>&#123;<br>    NSURLSessionConfiguration *defaultConfigObject &#x3D; [NSURLSessionConfiguration defaultSessionConfiguration];<br>    NSURLSession *delegateFreeSession &#x3D; [NSURLSession sessionWithConfiguration: defaultConfigObject delegate: self delegateQueue: [NSOperationQueue mainQueue]];<br><br>    NSURL * url &#x3D; [NSURL URLWithString:@&quot;http:&#x2F;&#x2F;127.0.0.1:18081&#x2F;edit&quot;];<br>    NSMutableURLRequest * urlRequest &#x3D; [NSMutableURLRequest requestWithURL:url];<br>    NSString * params &#x3D;@&quot;id&#x3D;1&amp;name&#x3D;Test&amp;age&#x3D;50&quot;;<br>    [urlRequest setHTTPMethod:@&quot;POST&quot;];<br>    [urlRequest setHTTPBody:[params dataUsingEncoding:NSUTF8StringEncoding]];<br><br>    NSURLSessionDataTask * dataTask &#x3D; [delegateFreeSession dataTaskWithRequest:urlRequest];<br>    [dataTask resume];<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="发起一个Post请求"><a href="#发起一个Post请求" class="headerlink" title="发起一个Post请求"></a>发起一个Post请求</h4><ul><li>构建可变的Request对象。</li><li>设置请求方法为POST，设置请求体数据。</li><li>创建Session。</li><li>创建NSURLSessionDataTask。</li><li>执行Task</li><li>Response处理。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">-(void) httpPostWithCustomDelegate<br>&#123;<br>    NSURLSessionConfiguration *defaultConfigObject &#x3D; [NSURLSessionConfiguration defaultSessionConfiguration];<br>    NSURLSession *delegateFreeSession &#x3D; [NSURLSession sessionWithConfiguration: defaultConfigObject<br>                                                                      delegate: nil delegateQueue: [NSOperationQueue mainQueue]];<br>    <br>    <br>    NSURL * url &#x3D; [NSURL URLWithString:@&quot;http:&#x2F;&#x2F;127.0.0.1:18081&#x2F;edit&quot;];<br>    NSMutableURLRequest * urlRequest &#x3D; [NSMutableURLRequest requestWithURL:url];<br>    [urlRequest setHTTPMethod:@&quot;POST&quot;];<br>    NSString * params &#x3D;@&quot;id&#x3D;1&amp;name&#x3D;Test2&amp;age&#x3D;30&quot;;<br>    [urlRequest setHTTPBody:[params dataUsingEncoding:NSUTF8StringEncoding]];<br>    <br>    <br>    NSURLSessionDataTask * dataTask &#x3D;[delegateFreeSession dataTaskWithRequest:urlRequest<br>                                        completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) &#123;<br>                                          NSLog(@&quot;Response:%@ %@\n&quot;, response, error);<br>                                          if(error &#x3D;&#x3D; nil) &#123;<br>                                              NSString * text &#x3D; [[NSString alloc] initWithData: data encoding: NSUTF8StringEncoding];<br>                                              NSDictionary *dict &#x3D; [NSJSONSerialization JSONObjectWithData:data options:0 error:nil];<br>                                              NSLog(@&quot;Data &#x3D; %@&quot;,text);<br>                                          &#125;<br>                                      &#125;];<br>    [dataTask resume];<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h4><ul><li>构建Request对象。</li><li>创建Session。</li><li>创建NSURLSessionDownloadTask。</li><li>执行Task</li><li>Response处理。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">-(void)downloadFile<br>&#123;<br>    NSURL * url &#x3D; [NSURL URLWithString:@&quot;http:&#x2F;&#x2F;127.0.0.1:18081&#x2F;download&#x2F;test.txt&quot;];<br>    NSURLSessionConfiguration *defaultConfigObject &#x3D; [NSURLSessionConfiguration defaultSessionConfiguration];<br>    NSURLSession *defaultSession &#x3D; [NSURLSession sessionWithConfiguration: defaultConfigObject<br>                                                                 delegate:self<br>                                                            delegateQueue: [NSOperationQueue mainQueue]];<br><br>    NSURLSessionDownloadTask * downloadTask &#x3D;[ defaultSession downloadTaskWithURL:url<br>                                                                completionHandler:^(NSURL *location, NSURLResponse *response, NSError *error)<br>                                              &#123;<br>                                                  if(error &#x3D;&#x3D; nil)<br>                                                  &#123;<br>                                                      NSLog(@&quot;Temporary file &#x3D;%@&quot;,location);<br><br>                                                      NSError *err &#x3D; nil;<br>                                                      NSFileManager *fileManager &#x3D; [NSFileManager defaultManager];<br>                                                      NSString *docsDir &#x3D; [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex:0];<br><br><br>                                                      NSURL *docsDirURL &#x3D; [NSURL fileURLWithPath:[docsDir stringByAppendingPathComponent:@&quot;out.zip&quot;]];<br>                                                      if ([fileManager moveItemAtURL:location<br>                                                                               toURL:docsDirURL<br>                                                                               error: &amp;err])<br>                                                      &#123;<br>                                                          NSLog(@&quot;File is saved to &#x3D;%@&quot;,docsDir);<br>                                                      &#125;<br>                                                      else<br>                                                      &#123;<br>                                                          NSLog(@&quot;failed to move: %@&quot;,[err userInfo]);<br>                                                      &#125;<br>                                                  &#125;<br>                                              &#125;];<br>    [downloadTask resume];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="第三方框架AFNetWorking"><a href="#第三方框架AFNetWorking" class="headerlink" title="第三方框架AFNetWorking"></a>第三方框架AFNetWorking</h3><ul><li>AFNetWorking一款轻量级网络请求开源框架，基于Cocoa扩展的高层网络抽象，使用模块化的架构，具有设计良好、功能丰富的API。降低了iOS开发工程师处理网络请求的难度，让iOS开发变成一件愉快的事情。</li><li>GitHub地址：<a href="https://github.com/AFNetworking/AFNetworking">https://github.com/AFNetworking/AFNetworking</a></li></ul><h2 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h2><h3 id="iOS-沙盒"><a href="#iOS-沙盒" class="headerlink" title="iOS 沙盒"></a><strong>iOS</strong> 沙盒</h3><p>每一个App都有一个存储空间。iOS系统为每个应用程序创建自己的目录，每个应用程序只能访问自己的目录，不能相互通信。</p><h4 id="沙盒目录"><a href="#沙盒目录" class="headerlink" title="沙盒目录"></a>沙盒目录</h4><ul><li><p>Documents：保存应用运行时生成的需要持久化的数据,iTunes会自动备份该目录。苹果建议将在应用程序中浏览到的文件数据保存在该目录下。</p></li><li><p>Library:</p></li><li><ul><li>Caches：一般存储的是缓存文件，例如图片视频等，此目录下的文件不会再应用程序退出时删除。在手机备份的时候，iTunes不会备份该目录。例如音频,视频等文件存放其中</li><li>Preferences：保存应用程序的所有偏好设置iOS的Settings(设置)，我们不应该直接在这里创建文件，而是需要通过NSUserDefault这个类来访问应用程序的偏好设置。iTunes会自动备份该文件目录下的内容。比如说:是否允许访问图片,是否允许访问地理位置……</li></ul></li><li><p>tmp：临时文件目录，在程序重新运行的时候，和开机的时候，会清空tmp文件夹。</p></li></ul><h4 id="获取沙盒目录"><a href="#获取沙盒目录" class="headerlink" title="获取沙盒目录"></a>获取沙盒目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">&#x2F;&#x2F; 获取document目录<br>    NSArray *documentPaths &#x3D; NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);<br>    NSString *documentPath &#x3D; [documentPaths objectAtIndex:0];<br><br>    &#x2F;&#x2F; 获取Cache目录<br>    NSArray *cachePaths &#x3D; NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES);<br>    NSString *cachePath &#x3D; [cachePaths objectAtIndex:0];<br><br>    &#x2F;&#x2F; 获取Library目录<br>    NSArray *libraryPaths &#x3D; NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES);<br>    NSString *libraryPath &#x3D; [libraryPaths objectAtIndex:0];<br><br>    &#x2F;&#x2F; 获取Tmp目录<br>    NSString *tmpPath &#x3D; NSTemporaryDirectory();<br></code></pre></td></tr></table></figure><h4 id="文件及文件夹操作"><a href="#文件及文件夹操作" class="headerlink" title="文件及文件夹操作"></a>文件及文件夹操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">&#x2F;&#x2F; 判断文件是否存在<br>    NSFileManager *fileManager &#x3D; [NSFileManager defaultManager];<br><br>    NSString *document &#x3D; NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject;<br>    NSString *filePath &#x3D; [document stringByAppendingPathComponent:@&quot;test.txt&quot;];<br><br>    if ([fileManager fileExistsAtPath:filePath]) &#123;<br>        NSLog(@&quot;test.txt exists&quot;);<br>    &#125;<br><br>    BOOL isDirectory;<br>    if ([fileManager fileExistsAtPath:filePath isDirectory:&amp;isDirectory]) &#123;<br><br>    &#125;<br><br>    &#x2F;&#x2F; 创建目录<br>    NSString *testDir &#x3D; [document stringByAppendingPathComponent:@&quot;test&quot;];<br><br>    NSError *error;<br><br>    [fileManager createDirectoryAtPath:testDir withIntermediateDirectories:YES attributes:nil error:&amp;error];<br><br>    &#x2F;&#x2F; 创建文件<br>    NSString *testTxt &#x3D; [testDir stringByAppendingPathComponent:@&quot;test.txt&quot;];<br>    NSData *data &#x3D; [@&quot;Hello world!&quot; dataUsingEncoding:NSUTF8StringEncoding];<br>    [fileManager createFileAtPath:testTxt contents:data attributes:nil];<br><br>    &#x2F;&#x2F; 删除文件<br>    [fileManager removeItemAtPath:testTxt error:nil];<br></code></pre></td></tr></table></figure><h4 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">- (IBAction)write:(id)sender &#123;<br>    NSString *document &#x3D; NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject;<br><br>    NSString *filePath &#x3D; [document stringByAppendingPathComponent:@&quot;text.txt&quot;];<br><br>    NSString *contents &#x3D; @&quot;Hello world!&quot;;<br>    [contents writeToFile:filePath atomically:YES encoding:NSUTF8StringEncoding error:nil];<br>&#125;<br><br>- (IBAction)read:(id)sender &#123;<br>    NSString *document &#x3D; NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject;<br><br>    NSString *filePath &#x3D; [document stringByAppendingPathComponent:@&quot;text.txt&quot;];<br><br>    NSString *content &#x3D; [NSString stringWithContentsOfFile:filePath encoding:NSUTF8StringEncoding error:nil];<br>    NSLog(@&quot;content %@&quot;, content);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="NSUserDefaults"><a href="#NSUserDefaults" class="headerlink" title="NSUserDefaults"></a><strong>NSUserDefaults</strong></h3><ul><li><p>NSUserDefaults用来存储 用户设置 系统配置等一些小的数据。<br> 因为数据是明文存储在 plist 文件中，不安全，即使只是修改一个 key 都会 load 整个文件，数据多加载慢(IO 内存)，不适合存储大量数据。<br> 它是单例的，也是线程安全的，是以键值对 key-value 的形式保存在沙盒中<br> 存储路径为：沙盒路径的Library——&gt;Preferences文件夹中</p></li><li><p>支持的数据类型有NSString、 NSNumber、NSDate、 NSArray、NSDictionary、BOOL、NSInteger、NSFloat等系统定义的数据类型，如果要存放其他数据类型或者自定义的对象（如自定义的类对象），则必须将其转换成NSData存储。</p></li><li><ul><li>即使对象是NSArray或NSDictionary，他们存储的类型也应该是以上范围包括的。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">&#x2F;&#x2F; save<br>    [[NSUserDefaults standardUserDefaults] setInteger:1024 forKey:@&quot;x&quot;];<br>    [[NSUserDefaults standardUserDefaults] setObject:@&quot;Tom&quot; forKey:@&quot;name&quot;];<br>    [[NSUserDefaults standardUserDefaults] setObject:@&#123;<br>                                                       @&quot;text&quot;: @&quot;Cancel&quot;,<br>                                                       @&quot;color&quot;: @&quot;#ff0000&quot;,<br>                                                       &#125; forKey:@&quot;button&quot;];<br>    User *user &#x3D; [[User alloc] init];<br>    user.userId &#x3D; 123;<br>    user.nickname &#x3D; @&quot;Tom&quot;;<br>    user.isVip &#x3D; YES;<br><br>    NSData *data &#x3D; [NSKeyedArchiver archivedDataWithRootObject:user requiringSecureCoding:YES error:nil];<br>    [[NSUserDefaults standardUserDefaults] setObject:data forKey:@&quot;user&quot;];<br><br>    &#x2F;&#x2F; read<br>    NSInteger x &#x3D; [[NSUserDefaults standardUserDefaults] integerForKey:@&quot;x&quot;];<br>    NSString *name &#x3D; [[NSUserDefaults standardUserDefaults] stringForKey:@&quot;name&quot;];<br>    NSDictionary *dict &#x3D; [[NSUserDefaults standardUserDefaults] objectForKey:@&quot;button&quot;];<br>    data &#x3D; [[NSUserDefaults standardUserDefaults] dataForKey:@&quot;user&quot;];<br>    user &#x3D; [NSKeyedUnarchiver unarchivedObjectOfClass:[User class] fromData:data error:nil];<br></code></pre></td></tr></table></figure><p> <img src= "/img/loading.gif" data-lazy-src="../../assets/image-20190329004120445.png" alt="image-20190329004120445"></p><p> <img src= "/img/loading.gif" data-lazy-src="../../assets/image-20190329004125750.png" alt="image-20190329004125750"></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Objective-C </tag>
            
            <tag> iOS </tag>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift第三方库</title>
      <link href="/IOS/Swift%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/"/>
      <url>/IOS/Swift%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="Alamofire"><a href="#Alamofire" class="headerlink" title="Alamofire"></a>Alamofire</h2><blockquote><p>Alamofire is an HTTP networking library written in Swift.</p></blockquote><p>项目地址：<a href="https://github.com/Alamofire/Alamofire">https://github.com/Alamofire/Alamofire</a></p><p>Carthage 引入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">github &quot;Alamofire&#x2F;Alamofire&quot;<br></code></pre></td></tr></table></figure><h2 id="Kingfisher"><a href="#Kingfisher" class="headerlink" title="Kingfisher"></a>Kingfisher</h2><blockquote><p>Kingfisher is a powerful, pure-Swift library for downloading and caching images from the web. It provides you a chance to use a pure-Swift way to work with remote images in your next app.</p></blockquote><p>项目地址：<a href="https://github.com/onevcat/Kingfisher">https://github.com/onevcat/Kingfisher</a></p><p>Carthage 引入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">github &quot;onevcat&#x2F;Kingfisher&quot;<br></code></pre></td></tr></table></figure><h2 id="MonkeyKing"><a href="#MonkeyKing" class="headerlink" title="MonkeyKing"></a>MonkeyKing</h2><blockquote><p>onkeyKing helps you post SNS messages to Chinese Social Networks, without their buggy SDKs.</p><p>MonkeyKing uses the same analysis process of openshare. We also use some reverse engineering tools such as Hopper Disassembler to unveil several undocumented authentication mechanisms under the hood. It supports sharing <strong>Text</strong>, <strong>URL</strong>, <strong>Image</strong>, <strong>Audio</strong>, <strong>Video</strong>, and <strong>File</strong> to <strong>WeChat</strong>, <strong>QQ</strong>, <strong>Alipay</strong> or <strong>Weibo</strong>. MonkeyKing can also post messages to Weibo by a web page. (Note: Audio and Video are exclusive to WeChat or QQ, and File is exclusive to QQ Dataline)</p><p>MonkeyKing also supports <strong>OAuth</strong> and <strong>Mobile payment</strong> via WeChat and Alipay!</p></blockquote><p>项目地址：<a href="https://github.com/nixzhu/MonkeyKing">https://github.com/nixzhu/MonkeyKing</a></p><p>Carthage 引入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">github &quot;nixzhu&#x2F;MonkeyKing&quot;<br></code></pre></td></tr></table></figure><h2 id="SwiftyJSON"><a href="#SwiftyJSON" class="headerlink" title="SwiftyJSON"></a>SwiftyJSON</h2><blockquote><p>SwiftyJSON makes it easy to deal with JSON data in Swift.</p></blockquote><p>项目地址：<a href="https://github.com/SwiftyJSON/SwiftyJSON">https://github.com/SwiftyJSON/SwiftyJSON</a></p><p>Carthage 引入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">github &quot;SwiftyJSON&#x2F;SwiftyJSON&quot;<br></code></pre></td></tr></table></figure><h2 id="SnapKit"><a href="#SnapKit" class="headerlink" title="SnapKit"></a>SnapKit</h2><blockquote><p>SnapKit is a DSL to make Auto Layout easy on both iOS and OS X.</p></blockquote><p>项目地址：<a href="https://github.com/SnapKit/SnapKit">https://github.com/SnapKit/SnapKit</a></p><p>Carthage 引入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">github &quot;SnapKit&#x2F;SnapKit&quot;<br></code></pre></td></tr></table></figure><h2 id="XLPagerTabStrip"><a href="#XLPagerTabStrip" class="headerlink" title="XLPagerTabStrip"></a>XLPagerTabStrip</h2><blockquote><p>Android PagerTabStrip for iOS.</p></blockquote><p>项目地址：<a href="https://github.com/xmartlabs/XLPagerTabStrip">https://github.com/xmartlabs/XLPagerTabStrip</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyDrive</title>
      <link href="/IOS/MyDrive/"/>
      <url>/IOS/MyDrive/</url>
      
        <content type="html"><![CDATA[<h2 id="框架选型"><a href="#框架选型" class="headerlink" title="框架选型"></a>框架选型</h2><p><a href="http://msching.github.io/">网易云开发者音频开发博客</a></p><h3 id="音乐播放框架"><a href="#音乐播放框架" class="headerlink" title="音乐播放框架"></a>音乐播放框架</h3><h4 id="Jukebox"><a href="#Jukebox" class="headerlink" title="Jukebox"></a>Jukebox</h4><blockquote><p>Jukebox is an iOS audio player written in Swift.</p><p><a href="https://github.com/teodorpatras/Jukebox">Jukebox</a></p></blockquote><h4 id="DOUAudioStreamer"><a href="#DOUAudioStreamer" class="headerlink" title="DOUAudioStreamer"></a>DOUAudioStreamer</h4><blockquote><p>DOUAudioStreamer is a Core Audio based streaming audio player for iOS/Mac.</p><p><a href="https://github.com/douban/DOUAudioStreamer">DOUAudioStreamer</a></p></blockquote><h4 id="FreeStreamer"><a href="#FreeStreamer" class="headerlink" title="FreeStreamer"></a>FreeStreamer</h4><blockquote><p>A streaming audio player for iOS and OS X.</p><ul><li><strong>CPU-friendly</strong> design (uses 1% of CPU on average when streaming)</li><li><strong>Multiple protocols supported</strong>: ShoutCast, standard HTTP, local files</li><li><strong>Prepared for tough network conditions</strong>: adjustable buffer sizes, stream pre-buffering and restart on failures</li><li><strong>Metadata support</strong>: ShoutCast metadata, IDv2 tags</li><li><strong>Local disk caching</strong>: user only needs to stream a file once and after that it can be played from a local cache</li><li><strong>Preloading</strong>: playback can start immediately without needing to wait for buffering</li><li><strong>Record</strong>: support recording the stream contents to a file</li><li><strong>Access the PCM audio samples</strong>: as an example, a visualizer is included</li></ul><p><a href="https://github.com/muhku/FreeStreamer">FreeStreamer</a></p></blockquote><h2 id="StreamingKit"><a href="#StreamingKit" class="headerlink" title="StreamingKit"></a>StreamingKit</h2><blockquote><p>StreamingKit (formally Audjustable) is an audio playback and streaming library for iOS and Mac OSX. StreamingKit uses CoreAudio to decompress and playback audio (using hardware or software codecs) whilst providing a clean and simple object-oriented API.</p><ul><li>Free OSS.</li><li>Simple API.</li><li>Easy to read source.</li><li>Carefully multi-threaded to provide a responsive API that won’t block your UI thread nor starve the audio buffers.</li><li>Buffered and gapless playback between all format types.</li><li>Easy to implement audio data sources (Local, HTTP, AutoRecoveringHTTP DataSources are provided).</li><li>Easy to extend DataSource to support adaptive buffering, encryption, etc.</li><li>Optimised for low CPU/battery usage (0% - 1% CPU usage when streaming).</li><li>Optimised for linear data sources. Random access sources are required only for seeking.</li><li>StreamingKit 0.2.0 uses the AudioUnit API rather than the slower AudioQueues API which allows real-time interception of the raw PCM data for features such as level metering, EQ, etc.</li><li>Power metering</li><li>Inbuilt equalizer/EQ (iOS 5.0 and above, OSX 10.9 Mavericks and above) with support for dynamically changing/enabling/disabling EQ while playing.</li><li>Example apps for iOS and Mac OSX provided.</li></ul><p><a href="https://github.com/tumtumtum/StreamingKit">StreamingKit</a></p><p><a href="https://zhuanlan.zhihu.com/p/28514566">https://zhuanlan.zhihu.com/p/28514566</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xcode</title>
      <link href="/IOS/Xcode/"/>
      <url>/IOS/Xcode/</url>
      
        <content type="html"><![CDATA[<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><h3 id="Mac-OS-外接键盘映射"><a href="#Mac-OS-外接键盘映射" class="headerlink" title="Mac OS 外接键盘映射"></a>Mac OS 外接键盘映射</h3><table><thead><tr><th align="center">修饰键</th><th align="center">符号</th><th align="center">外接键盘</th></tr></thead><tbody><tr><td align="center"><strong>Command</strong></td><td align="center">![Command 符号](/assets/9808e0a4c5ca7d8f3661af19ca54058e.png</td><td align="center"><strong>Win</strong></td></tr><tr><td align="center"><strong>Shift</strong></td><td align="center"><img src= "/img/loading.gif" data-lazy-src="/assets/da6e9b7f91e7eb13915e29d5288d8d3f.png" alt="Shift 符号"></td><td align="center"><strong>Shift</strong></td></tr><tr><td align="center"><strong>Option</strong></td><td align="center"><img src= "/img/loading.gif" data-lazy-src="/assets/4fa4885c9111e0de6faeb637be746e2a.png" alt="Option 符号"></td><td align="center"><strong>Alt</strong></td></tr><tr><td align="center"><strong>Control</strong></td><td align="center"><img src= "/img/loading.gif" data-lazy-src="/assets/d4a120294e44333f6ec6c00ef4648ee1.png" alt="Control 符号"></td><td align="center"><strong>Ctrl</strong></td></tr></tbody></table><h3 id="Xcode常用快捷键"><a href="#Xcode常用快捷键" class="headerlink" title="Xcode常用快捷键"></a>Xcode常用快捷键</h3><h4 id="代码编辑"><a href="#代码编辑" class="headerlink" title="代码编辑"></a>代码编辑</h4><table><thead><tr><th>代码编辑</th><th align="center">Mac</th></tr></thead><tbody><tr><td>代码左缩进</td><td align="center"><strong>Command + [</strong></td></tr><tr><td>代码右缩进</td><td align="center"><strong>Command + ]</strong></td></tr><tr><td>代码格式化</td><td align="center"><strong>Control + I</strong></td></tr><tr><td>光标移到前一行（previous）</td><td align="center"><strong>Control + P</strong></td></tr><tr><td>光标移到后一行（next）</td><td align="center"><strong>Control + N</strong></td></tr><tr><td>光标移到行首</td><td align="center"><strong>Control + A</strong></td></tr><tr><td>光标移到行尾（end）</td><td align="center"><strong>Control + E</strong></td></tr><tr><td>调换光标两边的字符，并移动光标到两个字符后（transpose）</td><td align="center"><strong>Control + T</strong></td></tr><tr><td>删除光标右侧字符</td><td align="center"><strong>Control + D</strong> <strong>/</strong> <strong>Delete</strong></td></tr><tr><td>删除本行光标右侧所有字符（kill）</td><td align="center"><strong>Control + K</strong></td></tr><tr><td></td><td align="center"></td></tr><tr><td></td><td align="center"></td></tr><tr><td></td><td align="center"></td></tr><tr><td></td><td align="center"></td></tr></tbody></table><h3 id="Xcode自定义组合快捷键"><a href="#Xcode自定义组合快捷键" class="headerlink" title="Xcode自定义组合快捷键"></a>Xcode自定义组合快捷键</h3><p>修改 <code>Xcode</code> 里快捷键的配置文件 <code>(plist)</code> 权限，打开终端输入如下两条命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">sudo chmod 666 &#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Frameworks&#x2F;IDEKit.framework&#x2F;Resources&#x2F;IDETextKeyBindingSet.plist<br>sudo chmod 777 &#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Frameworks&#x2F;IDEKit.framework&#x2F;Resources&#x2F;<br></code></pre></td></tr></table></figure><p>打开 <code>plist</code> 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Frameworks&#x2F;IDEKit.framework&#x2F;Resources&#x2F;IDETextKeyBindingSet.plist<br></code></pre></td></tr></table></figure><h4 id="复制一行快捷键"><a href="#复制一行快捷键" class="headerlink" title="复制一行快捷键"></a>复制一行快捷键</h4><blockquote><p>在<code>Insertions and Indentations</code>下添加 key ：<code>Duplicate Current Line</code>，值为：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">selectLine:, copy:, moveToEndOfLine:, moveToBeginningOfLine:, paste:, moveBackward:<br></code></pre></td></tr></table></figure><p>绑定快捷键 <code>Command</code> + <code>D</code></p><h4 id="删除整行快捷键"><a href="#删除整行快捷键" class="headerlink" title="删除整行快捷键"></a>删除整行快捷键</h4><p>在 <code>Deletions </code> 下添加一个 key ：<code>Delete Current Line</code> 值为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">deleteToBeginningOfLine:, moveToEndOfLine:, deleteToBeginningOfLine:, deleteBackward:<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Xcode </tag>
            
            <tag> MacOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MacOS开源软件</title>
      <link href="/MacOS/MacOS%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/"/>
      <url>/MacOS/MacOS%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="Boop-编程开发辅助神器（Swift）"><a href="#Boop-编程开发辅助神器（Swift）" class="headerlink" title="Boop 编程开发辅助神器（Swift）"></a>Boop 编程开发辅助神器（Swift）</h2><blockquote><p>Boop 是一款编程开发辅助应用。通过 <code>command + b</code> 键即可快速帮助您进行 JSON 解析、URL编码解码、Base64解码编码、计算MD5哈希值、JWT解码、XML格式化、JSON转CSV、css格式化、Javascript压缩格式化、SQL格式化等等功能。需要注意的是通过 <code>command + b</code> 键调用出功能列表后，要使用上下箭头选择，回车键确认。</p></blockquote><p>项目地址：<a href="https://github.com/IvanMathy/Boop">https://github.com/IvanMathy/Boop</a></p><p><img src= "/img/loading.gif" data-lazy-src="/assets/UI.png" alt="UI Screenshot"> </p><h2 id="Hidden-Bar-菜单栏图标隐藏工具（Swift）"><a href="#Hidden-Bar-菜单栏图标隐藏工具（Swift）" class="headerlink" title="Hidden Bar 菜单栏图标隐藏工具（Swift）"></a>Hidden Bar 菜单栏图标隐藏工具（Swift）</h2><blockquote><p>Hidden Bar 是一款 macOS 菜单栏图标隐藏工具。使用方法：按住 <code>⌘ Command</code> 键，拖动想要折叠的图标移到「｜」图标左侧就可以了，点击「&gt;」箭头图标就可以直接隐藏菜单栏图标。不过要注意一个逻辑问题，「&gt;」图标不能放置在「｜」图标左侧。</p></blockquote><p>项目地址：<a href="https://github.com/dwarvesf/hidden">https://github.com/dwarvesf/hidden</a></p><p><img src= "/img/loading.gif" data-lazy-src="/assets/screen1.png" alt="img"></p><h2 id="Dozer-隐藏Mac菜单栏图标（Swift）"><a href="#Dozer-隐藏Mac菜单栏图标（Swift）" class="headerlink" title="Dozer 隐藏Mac菜单栏图标（Swift）"></a>Dozer 隐藏Mac菜单栏图标（Swift）</h2><blockquote><p>Dozer 是一款隐藏macOS菜单栏图标的应用，不同于 Bartender 和 Vanilla，Dozer 是免费、开源的。Dozer 操作方法也很简单，Dozer运行后在菜单栏会出现一个「‧」，点击它，然后会出现另外一个「‧」，按住 <code>command</code> 键拖曳「‧」调整到适当位置，然后点击一下「‧」就会隐藏第一个「‧」左边的图标，重新显示也只需要点击「‧」即可。</p></blockquote><p>项目地址：<a href="https://github.com/Mortennn/Dozer">https://github.com/Mortennn/Dozer</a></p><p><img src= "/img/loading.gif" data-lazy-src="/assets/demo-4041258.gif" alt="demo"></p><h2 id="Mos-鼠标平滑滚动反转（Swift）"><a href="#Mos-鼠标平滑滚动反转（Swift）" class="headerlink" title="Mos 鼠标平滑滚动反转（Swift）"></a>Mos 鼠标平滑滚动反转（Swift）</h2><blockquote><p>Mos 是mac上一款针对非原装鼠标不能平滑滚动的鼠标平滑滚动工具，Mos最主要的功能就是让你的鼠标滚动效果达到和妙控鼠标（Magic Mouse）/ 妙控板（Magic Trackpad）一样的如丝般顺滑的滚动体验。对于没有买妙控鼠标（Magic Mouse）的人来说这是一款神器。</p></blockquote><p>项目地址：<a href="https://github.com/Caldis/Mos">https://github.com/Caldis/Mos</a></p><p><img src= "/img/loading.gif" data-lazy-src="/assets/PreferencesGeneral.png" alt="img"></p><h2 id="IINA-视频播放器（Swift）"><a href="#IINA-视频播放器（Swift）" class="headerlink" title="IINA 视频播放器（Swift）"></a>IINA 视频播放器（Swift）</h2><blockquote><p>IINA 是一款采用现代设计和流线型功能的在线mac视频播放器，可以观看视频，管理播放列表，处理媒体内容或为电影加载字幕提等等。IINA mac可以加载本地文件或提供视频URL，IINA mac可以使用所有流行的媒体格式。而且您可以快速更改界面主题，调整默认行为和用户界面，决定是否要自动加载字幕，配置新的键绑定等。</p></blockquote><p>项目地址：<a href="https://github.com/iina/iina">https://github.com/iina/iina</a></p><p><img src= "/img/loading.gif" data-lazy-src="/assets/sc-sky.png" alt="Screenshot"></p><h2 id="FSNotes-程序员笔记应用（Swift）"><a href="#FSNotes-程序员笔记应用（Swift）" class="headerlink" title="FSNotes 程序员笔记应用（Swift）"></a>FSNotes 程序员笔记应用（Swift）</h2><blockquote><p>FSNotes 是一款本地的Mac笔记应用，支持markdown、rtf、txt格式，它将数据存储在本地文件系统中而非云端，安全，稳定。</p></blockquote><p>项目地址：<a href="https://github.com/glushchenko/fsnotes">https://github.com/glushchenko/fsnotes</a></p><p><img src= "/img/loading.gif" data-lazy-src="/assets/code.png" alt="macOS FSNotes"></p><p><img src= "/img/loading.gif" data-lazy-src="/assets/68747470733a2f2f66736e6f742e65732f696d672f696f732d73637265656e2e706e67.png" alt="FSNotes for iOS"></p><h2 id="AltTab-窗口快速切换利器（Swift）"><a href="#AltTab-窗口快速切换利器（Swift）" class="headerlink" title="AltTab 窗口快速切换利器（Swift）"></a>AltTab 窗口快速切换利器（Swift）</h2><blockquote><p>AltTab 是一款适用于 macOS 的窗口切换工具，将 Windows 的 <code>alt-tab</code> 窗口切换功能带到了 macOS 中。用法：</p><ul><li>按下 <code>⌥ option + ⇥ tab</code> 显示窗口缩略图。</li><li>继续按 <code>⌥ option + ⇥ tab</code> 选择下一个窗口。</li><li>按住 <code>⌥ option + ⇧ shift + ⇥ tab</code> 选择上一个缩略图。</li><li>松开 <code>⌥ option</code> 以将焦点切换到窗口。</li></ul></blockquote><p>项目地址：<a href="https://github.com/lwouis/alt-tab-macos">https://github.com/lwouis/alt-tab-macos</a></p><p><img src= "/img/loading.gif" data-lazy-src="/assets/frontpage.jpg" alt="frontpage"></p><h2 id="Rectangle-开源Mac窗口管理应用（Swift）"><a href="#Rectangle-开源Mac窗口管理应用（Swift）" class="headerlink" title="Rectangle 开源Mac窗口管理应用（Swift）"></a>Rectangle 开源Mac窗口管理应用（Swift）</h2><blockquote><p>Rectangle 是一款开源免费的 Mac 窗口管理工具。Rectangle 可以让用户使用键盘快捷键来移动和调整窗口大小。</p></blockquote><p>项目地址：<a href="https://github.com/rxhanson/Rectangle">https://github.com/rxhanson/Rectangle</a></p><p><img src= "/img/loading.gif" data-lazy-src="/assets/71896594-7cdb9280-3154-11ea-83a7-70b71c6df9d4-4045866.png" alt="71896594-7cdb9280-3154-11ea-83a7-70b71c6df9d4"></p><h2 id="uPic-Mac图床客户端（Swift）"><a href="#uPic-Mac图床客户端（Swift）" class="headerlink" title="uPic Mac图床客户端（Swift）"></a>uPic Mac图床客户端（Swift）</h2><blockquote><p>uPic 是一款 Mac图床(文件)上传客户端，它可以将图片、各种文件上传到配置好的指定对象存储中，然后即时生成可供互联网访问的文件URL。支持图床： smms、 又拍云 USS、七牛云 KODO、 阿里云 OSS、 腾讯云 COS、微博、Github、 Gitee、 Amazon S3、自定义上传接口。无论是本地文件、或者屏幕截图都可自动上传，菜单栏显示实时上传进度。上传完成后文件链接自动复制到剪切板，返回的URL链接格式可以选择：普通 URL、HTML 或者 Markdown，非常灵活，推荐使用，比iPic强大！</p></blockquote><p>项目地址：<a href="https://github.com/gee1k/uPic">https://github.com/gee1k/uPic</a></p><p><img src= "/img/loading.gif" data-lazy-src="/assets/shortcuts.png" alt="img"></p><h2 id="OpenInTerminal-在当前目录打开终端（Swift）"><a href="#OpenInTerminal-在当前目录打开终端（Swift）" class="headerlink" title="OpenInTerminal 在当前目录打开终端（Swift）"></a>OpenInTerminal 在当前目录打开终端（Swift）</h2><blockquote><p>OpenInTerminal 是一款开发辅助工具，可以在当前位置打开终端。主要功能：在终端（或编辑器）中打开当前目录以及在终端（或编辑器）中打开选择的文件夹或文件。</p><ul><li>支持的终端： iTerm, Hyper 和 Alacritty</li><li>支持的文本编辑：Visual Studio Code, VSCode Insiders, Atom, Sublime Text, VSCodium, BBEdit，TextMate，CotEditor，MacVim 和 JetBrains(AppCode, CLion, GoLand, IntelliJ IDEA, PhpStorm, PyCharm, RubyMine, WebStorm)</li><li>设置为打开新的窗口或者标签页</li><li>将已选择的文件或者访达窗口的路径拷贝到粘贴板</li><li>支持键盘快捷键</li><li>支持 Dark Mode</li></ul></blockquote><p>项目地址：<a href="https://github.com/Ji4n1ng/OpenInTerminal">https://github.com/Ji4n1ng/OpenInTerminal</a></p><p><img src= "/img/loading.gif" data-lazy-src="/assets/78589385-b797b880-7872-11ea-9062-c11a49461598.gif" alt="img"></p><h2 id="MonitorControl-菜单栏显示器音量亮度调节（Swift）"><a href="#MonitorControl-菜单栏显示器音量亮度调节（Swift）" class="headerlink" title="MonitorControl 菜单栏显示器音量亮度调节（Swift）"></a>MonitorControl 菜单栏显示器音量亮度调节（Swift）</h2><blockquote><p>MonitorControl 是一款 macOS 菜单栏多显款器音量及亮度调节应用。相信很多 Mac 用户都是一台 MacBook 加一台外接显示器，但是你会发现 macOS 不能用键盘直接调节外接显款器的亮度和输出的音量。MonitorControl 的出现就是为了解决这个问题的，MonitorControl 不仅可以对外接屏的音量、亮度调节，还可以对外接屏的对比度进行调节，并可以自定义选择快捷键控制的类型，或是指定在某个屏幕启用这些功能，甚至连 ⇧Shift+⌥Option 这种微调音量控制都能支持。</p></blockquote><p>项目地址：<a href="https://github.com/MonitorControl/MonitorControl">https://github.com/MonitorControl/MonitorControl</a></p><p><img src= "/img/loading.gif" data-lazy-src="/assets/menugeneral.png" alt="general screenshot"></p><h2 id="NetNewsWire-RSS新闻订阅客户端（Swift）"><a href="#NetNewsWire-RSS新闻订阅客户端（Swift）" class="headerlink" title="NetNewsWire RSS新闻订阅客户端（Swift）"></a>NetNewsWire RSS新闻订阅客户端（Swift）</h2><blockquote><p>NetNewsWire 是一款开源免费的 RSS订阅器，支持Safari扩展程序，可轻松添加Feed订阅，支持通过Feedbin同步，共享到邮件，MarsEdit，Micro.blog，便笺，消息等，支持AppleScript。</p></blockquote><p>开源项目：<a href="https://github.com/Ranchero-Software/NetNewsWire">https://github.com/Ranchero-Software/NetNewsWire</a></p><p><img src= "/img/loading.gif" data-lazy-src="/assets/NNW5Light-Thumb.png" alt="Screenshot showing NetNewsWire in light mode."></p><h2 id="Karabiner-Elements-键盘键位修改神器（Swift）"><a href="#Karabiner-Elements-键盘键位修改神器（Swift）" class="headerlink" title="Karabiner-Elements 键盘键位修改神器（Swift）"></a>Karabiner-Elements 键盘键位修改神器（Swift）</h2><blockquote><p>karabiner-elements 一款开源的 macOS 键盘修改神器。可以将键盘上的某个键位映射为任意指定的其他键位。可以仅特定/同时对连接到 Mac 的键盘设备生效。支持虚拟键盘（ANSI, ISO, JIS）等。支持设置多套偏好设置，可根据场景切换使用</p></blockquote><p>项目地址：<a href="https://github.com/pqrs-org/Karabiner-Elements">https://github.com/pqrs-org/Karabiner-Elements</a></p><p><img src= "/img/loading.gif" data-lazy-src="/assets/karabiner-elements-update-13.0.12-beta.jpg" alt="karabiner-elements-update-13.0.12-beta"></p><h2 id="CotEditor-开源免费的文本编辑器（Swift）"><a href="#CotEditor-开源免费的文本编辑器（Swift）" class="headerlink" title="CotEditor 开源免费的文本编辑器（Swift）"></a>CotEditor 开源免费的文本编辑器（Swift）</h2><blockquote><p>CotEditor 是一款针对 macOS 开发的轻量级代码编辑器。CotEditor 启动非常快，支持 50 多种语言高亮，例如HTML、PHP、Python、Ruby、Markdown、Javascript等等。</p></blockquote><p>项目地址：<a href="https://github.com/coteditor/CotEditor">https://github.com/coteditor/CotEditor</a></p><p><img src= "/img/loading.gif" data-lazy-src="/assets/screenshot@2x.png" alt="img"></p><h2 id="Thor-通过快捷键快速打开应用（Swift）"><a href="#Thor-通过快捷键快速打开应用（Swift）" class="headerlink" title="Thor 通过快捷键快速打开应用（Swift）"></a>Thor 通过快捷键快速打开应用（Swift）</h2><blockquote><p>Thor 是一款 Mac 效率类应用，可以针对指定的应用设计设置快捷键，通过指定的快捷键快速打开应用和切换应用。</p></blockquote><p>项目地址：<a href="https://github.com/gbammc/Thor">https://github.com/gbammc/Thor</a></p><p><img src= "/img/loading.gif" data-lazy-src="/assets/screenshot_list.png" alt="Screenshots"></p><h2 id="LyricsX-菜单栏及桌面歌词显示（Swift）"><a href="#LyricsX-菜单栏及桌面歌词显示（Swift）" class="headerlink" title="LyricsX 菜单栏及桌面歌词显示（Swift）"></a>LyricsX 菜单栏及桌面歌词显示（Swift）</h2><blockquote><p>LyricsX 是一款 Mac 桌面歌词及菜单栏歌词显示应用。可从网络自动搜索和下载当前播放歌曲的歌词并将其显示在桌面和菜单栏中，您可以自定义字体，颜色和位置，在状态菜单上调整歌词偏移，另外可以拖放导入歌词以及导出歌词文件。支持 iTunes、Spotify、Vox、Audirvana、Swinsian 等音乐播放器。歌词来源：网易云音乐、QQ音乐、酷狗音乐、虾米音乐、天天动听、歌词迷。</p></blockquote><p>项目地址：<a href="https://github.com/ddddxxx/LyricsX">https://github.com/ddddxxx/LyricsX</a></p><p><img src= "/img/loading.gif" data-lazy-src="/assets/desktop_lyrics.gif" alt="img"></p><h2 id="Pock-在TouchBar中显示Dock栏图标（Swift）"><a href="#Pock-在TouchBar中显示Dock栏图标（Swift）" class="headerlink" title="Pock 在TouchBar中显示Dock栏图标（Swift）"></a>Pock 在TouchBar中显示Dock栏图标（Swift）</h2><blockquote><p>Pock 是一款可以将macOS Dock栏图标映射到触摸栏中显示工具。程序还附带了一些简约的小部件，比如时间，Wifi，电量、亮度控制、声音控制、正在播放等。</p></blockquote><p>项目地址：<a href="https://github.com/pigigaldi/Pock">https://github.com/pigigaldi/Pock</a></p><p><img src= "/img/loading.gif" data-lazy-src="/assets/68747470733a2f2f706f636b2e6465762f6173736574732f696d672f707265766965772f706f636b5f776964676574732e706e67.png" alt="img"></p><h2 id="Stats-菜单栏系统监视器（Swift）"><a href="#Stats-菜单栏系统监视器（Swift）" class="headerlink" title="Stats 菜单栏系统监视器（Swift）"></a>Stats 菜单栏系统监视器（Swift）</h2><blockquote><p>Stats 是一款macOS菜单栏系统监视工具。可以帮助您实时监视：CPU利用率、GPU利用率、内存使用情况、磁盘利用率、传感器信息（温度/电压/功率）、电池电量、网络使用等信息。</p></blockquote><p>项目地址：<a href="https://github.com/exelban/stats">https://github.com/exelban/stats</a></p><p><img src= "/img/loading.gif" data-lazy-src="/assets/68747470733a2f2f7365726869792e73332e65752d63656e7472616c2d312e616d617a6f6e6177732e636f6d2f4769746875625f7265706f2f73746174732f706f7075707325334676322e332e322e706e673f7633.png" alt="Stats"></p><h2 id="Gifski-从视频中提取gif动图（Swift）"><a href="#Gifski-从视频中提取gif动图（Swift）" class="headerlink" title="Gifski 从视频中提取gif动图（Swift）"></a>Gifski 从视频中提取gif动图（Swift）</h2><blockquote><p>Gifski for Mac 是一款可以将视频转换为GIF动画的应用。Gifski 支持 macOS 支持的所有视频格式（.mp4/.movH264/HEVC/ProRes 等等）。使用方法简单：只需将视频拖放到主界面，然后裁切需要时长的视频，设置尺寸（可以自定义宽度和高度）、FPS、质量，点击转换即可。</p></blockquote><p>项目地址：<a href="https://github.com/sindresorhus/Gifski">https://github.com/sindresorhus/Gifski</a></p><p><img src= "/img/loading.gif" data-lazy-src="/assets/screenshot2.jpg" alt="img"></p><h2 id="Retroactive-解锁MacOS软件系统限制（Swift）"><a href="#Retroactive-解锁MacOS软件系统限制（Swift）" class="headerlink" title="Retroactive 解锁MacOS软件系统限制（Swift）"></a>Retroactive 解锁MacOS软件系统限制（Swift）</h2><blockquote><p>Retroactive (解印) 可让您在 macOS Catalina (10.15.x) 上运行iTunes，iPhoto和Aperture。还可以在 macOS Mojave (10.14.x) 解封 Xcode 11.4.1。 macOS Mojave 或macOS High Sierra 上解锁 Final Cut Pro 7，Logic Pro 9 或者修复 iWork ‘09。</p></blockquote><p>项目地址：<a href="https://github.com/cormiertyshawn895/Retroactive">https://github.com/cormiertyshawn895/Retroactive</a></p><p><a href="https://github.com/cormiertyshawn895/Retroactive/blob/master/screenshots/2.jpg"><img src= "/img/loading.gif" data-lazy-src="/assets/2.jpg" alt="img"></a></p><h2 id="PicGo-跨平台图床软件"><a href="#PicGo-跨平台图床软件" class="headerlink" title="PicGo 跨平台图床软件"></a>PicGo 跨平台图床软件</h2><blockquote><p>PicGo 是一款强大的mac图床工具，默认支持微博图床、七牛图床、腾讯云COS、又拍云、GitHub、SM.MS、阿里云OSS、Imgur，方便不同图床的上传需求。支持5种默认剪贴板链接格式：Markdown/html/url/ubb/自定义链接格式，让你的文本编辑游刃有余。2.0版本开始支持插件系统</p></blockquote><p>项目地址：<a href="https://github.com/Molunerfinn/PicGo">https://github.com/Molunerfinn/PicGo</a></p><p><img src= "/img/loading.gif" data-lazy-src="/assets/picgo-2.0.gif" alt="picgo-2.0"></p><h2 id="Stretchly-休息提醒工具"><a href="#Stretchly-休息提醒工具" class="headerlink" title="Stretchly 休息提醒工具"></a>Stretchly 休息提醒工具</h2><blockquote><p>Stretchly 是一款免费开源的 Mac 休息提醒工具。默认情况下，每10分钟有20秒的小憩，每30分钟有5分钟的长休息（在2个小憩之后）。您可以设置小憩与休息间隔、提醒声音、界面主题样式以及提醒模式，并提供可选的不可跳过休息模式。</p></blockquote><p>项目地址：<a href="https://github.com/hovancik/stretchly">https://github.com/hovancik/stretchly</a></p><p><a href="https://github.com/hovancik/stretchly/blob/master/minibreak.png"><img src= "/img/loading.gif" data-lazy-src="/assets/minibreak.png" alt="img"></a></p><h2 id="Terminus-支持SSH的mac终端模拟器"><a href="#Terminus-支持SSH的mac终端模拟器" class="headerlink" title="Terminus 支持SSH的mac终端模拟器"></a>Terminus 支持SSH的mac终端模拟器</h2><p>Terminus 是一个高度可配置的终端模拟器，适用于Windows，macOS和Linux。 主题和配色方案，完全可配置的快捷键，仿chrome标签页，保存最近打开的标签，集成的SSH客户端和连接管理器，完整的Unicode支持，包括双宽字符</p><p>项目地址：<a href="https://github.com/Eugeny/terminus">https://github.com/Eugeny/terminus</a></p><p><img src= "/img/loading.gif" data-lazy-src="/assets/readme.png" alt="img"></p><h2 id="Electerm-终端模拟器-ssh-sftp客户端"><a href="#Electerm-终端模拟器-ssh-sftp客户端" class="headerlink" title="Electerm 终端模拟器/ssh/sftp客户端"></a>Electerm 终端模拟器/ssh/sftp客户端</h2><blockquote><p>Electerm 是一款集终端模拟器、文件管理器、ssh远程连接、sftp客户端为一体的工具（类似于xshell），允许双击直接编辑远程文件（小文件），使用内置编辑器编辑本地文件，使用publickey +密码验证，Zmodem（rz，sz），还有自定义终端样式，全局/会话代理，将书签/主题/快速命令同步到github secret gist等功能。</p></blockquote><p>项目地址：<a href="https://github.com/electerm/electerm">https://github.com/electerm/electerm</a></p><p><img src= "/img/loading.gif" data-lazy-src="https://github.com/electerm/electerm-resource/raw/master/static/images/electerm.gif" alt="img"></p><h2 id="洛雪音乐-全网音乐播放下载工具"><a href="#洛雪音乐-全网音乐播放下载工具" class="headerlink" title="洛雪音乐 全网音乐播放下载工具"></a>洛雪音乐 全网音乐播放下载工具</h2><blockquote><p>洛雪音乐 for mac是一款全网免vip无损音乐歌曲下载工具，LuoXue Music支持免vip下载歌典的平台：QQ音乐无损音乐下载、酷狗音乐无损音乐下载、酷我音乐无损音乐下载、百度音乐无损音乐下载、网易云音乐无损歌典下载。lx music，你值得拥有！</p></blockquote><p>项目地址：<a href="https://github.com/lyswhut/lx-music-desktop">https://github.com/lyswhut/lx-music-desktop</a></p><p><a href="https://github.com/lyswhut/lx-music-desktop"><img src= "/img/loading.gif" data-lazy-src="https://github.com/lyswhut/lx-music-desktop/raw/master/doc/images/app.png" alt="lx-music UI"></a></p><h2 id="KeeWeb-跨平台密码管理器"><a href="#KeeWeb-跨平台密码管理器" class="headerlink" title="KeeWeb 跨平台密码管理器"></a>KeeWeb 跨平台密码管理器</h2><blockquote><p>KeeWeb for Mac是一款非常赞的密码管理器，KeeWeb与KeePass兼容的而且是跨平台的。KeeWeb在您浏览网站或者使用需要输入密码的应用中可以帮您自动填写已存储的密码。拥有密码生成器，支持密码生成规则，可以帮您生成最安全的密码！</p></blockquote><p>项目地址：<a href="https://github.com/keeweb/keeweb">https://github.com/keeweb/keeweb</a></p><p><img src= "/img/loading.gif" data-lazy-src="https://github.com/keeweb/keeweb/raw/master/img/screenshot.png" alt="screenshot"></p><h2 id="Buttercup-跨平台密码管理器"><a href="#Buttercup-跨平台密码管理器" class="headerlink" title="Buttercup 跨平台密码管理器"></a>Buttercup 跨平台密码管理器</h2><blockquote><p>Buttercup for Mac 是一款精美简单的密码管理器，旨在帮助您管理凭据。Buttercup使用非常强大的加密功能，以一个主密码保护您的敏感信息-随时为每个服务使用更强大，更复杂的密码，并让Buttercup安全地存储它们，支持自定义字段功能！Buttercup将跨平台提升到了新的高度，支持Windows、macOS、Linux、iOS、Android和浏览器插件</p></blockquote><p>项目地址：<a href="https://github.com/buttercup">https://github.com/buttercup</a></p><p><img src= "/img/loading.gif" data-lazy-src="/assets/35880367-6bd58770-0b86-11e8-879f-d1f9136274a9.png" alt="image"></p><h2 id="Listen-付费VIP音乐免费听"><a href="#Listen-付费VIP音乐免费听" class="headerlink" title="Listen 付费VIP音乐免费听"></a>Listen 付费VIP音乐免费听</h2><blockquote><p>Listen 1 是一款 Mac 全网音乐播放器。可以搜索和播放来自网易云音乐，虾米音乐，酷狗音乐，酷我音乐，哔哩哔哩，咪咕音乐，QQ音乐七个主流音乐网站平台的付费VIP歌曲，让你的曲库更全面。并支持收藏功能，方便的创建自己的歌单。</p></blockquote><p>项目地址：<a href="https://github.com/listen1/listen1_desktop">https://github.com/listen1/listen1_desktop</a></p><p><img src= "/img/loading.gif" data-lazy-src="/assets/687474703a2f2f692e696d6775722e636f6d2f41653649746d412e706e67.png" alt="687474703a2f2f692e696d6775722e636f6d2f41653649746d412e706e67"></p><h2 id="Mark-Text-Markdown编辑器"><a href="#Mark-Text-Markdown编辑器" class="headerlink" title="Mark Text Markdown编辑器"></a>Mark Text Markdown编辑器</h2><blockquote><p>Mark Text for mac是一款所输即所见的markdown编辑器，摒弃了众多 Markdown 编辑器左边写作右边预览的写作方式，巧妙的将编辑和预览融为一体。极速渲染编辑页面，带来流畅的书写体验。生成的 Markdown 可以复制到任何支持 Markdown 格式的社区、网站。可以导出 HTML 和 PDF 格式文件。支持六种皮肤风格，支持多种编辑模式：源代码模式、打字机模式、专注模式。</p></blockquote><p>项目地址：<a href="https://github.com/marktext/marktext">https://github.com/marktext/marktext</a></p><p><img src= "/img/loading.gif" data-lazy-src="/assets/marktext.png" alt="img"></p><h2 id="Motrix-全能的下载工具"><a href="#Motrix-全能的下载工具" class="headerlink" title="Motrix 全能的下载工具"></a>Motrix 全能的下载工具</h2><blockquote><p>Motrix for mac版是一款全能的下载工具。支持 HTTP下载、FTP下载、BT下载下载、磁力链下载、百度网盘资源下载。Motrix 也是采用了「Aria 2」作为核心，所以下载速度、多线程等能力与其他下载工具几乎一致。</p></blockquote><p>项目地址：<a href="https://github.com/agalwood/Motrix">https://github.com/agalwood/Motrix</a></p><p><img src= "/img/loading.gif" data-lazy-src="/assets/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3132393134372f313538393738323233383530312d65376233393136362d646135382d343135322d616533342d3635613036316361666134382e706e67.png" alt="motrix-screenshot-task-en.png"></p><h2 id="NTFSTool-NTFS硬盘读写工具"><a href="#NTFSTool-NTFS硬盘读写工具" class="headerlink" title="NTFSTool NTFS硬盘读写工具"></a>NTFSTool NTFS硬盘读写工具</h2><blockquote><p>NTFS Tool For Mac 是一款为 macOS 提供 NTFS 读写支持的软件。 支持NTFS磁盘读写、挂载、推出、管理等功能。它的界面简洁易用，希望这款工具能够为你的工作和生活带来便利。NTFS Tool 是一款纯净版的NTFS硬盘读写工具。</p></blockquote><p>项目地址：<a href="https://github.com/ntfstool/ntfstool">https://github.com/ntfstool/ntfstool</a></p><p><img src= "/img/loading.gif" data-lazy-src="/assets/ntfs-display.jpg" alt="ntfstool-main1.png"></p><h2 id="SwitchHosts-mac-hosts修改工具"><a href="#SwitchHosts-mac-hosts修改工具" class="headerlink" title="SwitchHosts!  mac hosts修改工具"></a>SwitchHosts!  mac hosts修改工具</h2><blockquote><p>SwitchHosts! 是一个管理切换编辑Mac系统hosts的工具。支持编辑mac hosts文件，自定义以及添加多个hosts文件配置，备份hosts文件。</p></blockquote><p>项目地址：<a href="https://github.com/oldj/SwitchHosts">https://github.com/oldj/SwitchHosts</a></p><p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/oldj/SwitchHosts/master/screenshots/sh_light.png" alt="Capture"></p><h2 id="magnetW-磁力聚合搜索工具"><a href="#magnetW-磁力聚合搜索工具" class="headerlink" title="magnetW 磁力聚合搜索工具"></a>magnetW 磁力聚合搜索工具</h2><blockquote><p>magnetW 是一款开源的Mac磁力链接聚合搜索工具。磁力搜 For magnetW通过关键字词搜索时实反馈搜索结果，包含大小，时间，来源，避免下载葫芦娃。可以配合 webtorrent 进行在线播放（webtorrent加载资源得等待几分钟），可以配合Folx、迅雷不限速进行下载。</p></blockquote><p>项目地址：<a href="https://github.com/xiandanin/magnetW">https://github.com/xiandanin/magnetW</a></p><p><img src= "/img/loading.gif" data-lazy-src="/assets/app.gif" alt="app"></p><h2 id="draw-io-流程图绘制应用"><a href="#draw-io-流程图绘制应用" class="headerlink" title="draw.io 流程图绘制应用"></a>draw.io 流程图绘制应用</h2><blockquote><p>draw.io for Mac 是一款免费的跨平台绘图工具。可以创建流程图、组织架构图、UML、ER图、泳道图、网络拓朴图、思维导图等等。内置丰富的模板和控件库供挑选使用，还可以导入组件。支持Google Dirve，One Drive， Dropbox和本地存储，支持将流程图导出为多种格式，比如 pdf/svg/html 等，提供 Chrome 插件。</p></blockquote><p>项目地址：<a href="https://github.com/jgraph/drawio-desktop">https://github.com/jgraph/drawio-desktop</a></p><p><img src= "/img/loading.gif" data-lazy-src="/assets/screenshot-20201030161656777.png" alt="draw.io desktop app"></p>]]></content>
      
      
      <categories>
          
          <category> MacOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MacOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac键盘快捷键</title>
      <link href="/MacOS/Mac%E9%94%AE%E7%9B%98%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/MacOS/Mac%E9%94%AE%E7%9B%98%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="键盘按键使用符合"><a href="#键盘按键使用符合" class="headerlink" title="键盘按键使用符合"></a>键盘按键使用符合</h3><table><thead><tr><th align="left">修饰键</th><th align="left">符号</th></tr></thead><tbody><tr><td align="left">Command</td><td align="left"><img src= "/img/loading.gif" data-lazy-src="https://help.apple.com/assets/5EF110D6680CE23B38350954/5EF110E3680CE23B3835095C/zh_CN/9808e0a4c5ca7d8f3661af19ca54058e.png" alt="Command 符号"></td></tr><tr><td align="left">Shift</td><td align="left"><img src= "/img/loading.gif" data-lazy-src="https://help.apple.com/assets/5EF110D6680CE23B38350954/5EF110E3680CE23B3835095C/zh_CN/da6e9b7f91e7eb13915e29d5288d8d3f.png" alt="Shift 符号"></td></tr><tr><td align="left">Option</td><td align="left"><img src= "/img/loading.gif" data-lazy-src="https://help.apple.com/assets/5EF110D6680CE23B38350954/5EF110E3680CE23B3835095C/zh_CN/4fa4885c9111e0de6faeb637be746e2a.png" alt="Option 符号"></td></tr><tr><td align="left">Control</td><td align="left"><img src= "/img/loading.gif" data-lazy-src="https://help.apple.com/assets/5EF110D6680CE23B38350954/5EF110E3680CE23B3835095C/zh_CN/d4a120294e44333f6ec6c00ef4648ee1.png" alt="Control 符号"></td></tr><tr><td align="left">Return</td><td align="left"><img src= "/img/loading.gif" data-lazy-src="https://help.apple.com/assets/5EF110D6680CE23B38350954/5EF110E3680CE23B3835095C/zh_CN/078689fe0beeb14141babebacd04c2b6.png" alt="Return 符号"></td></tr><tr><td align="left">Delete</td><td align="left"><img src= "/img/loading.gif" data-lazy-src="https://help.apple.com/assets/5EF110D6680CE23B38350954/5EF110E3680CE23B3835095C/zh_CN/218d37fa854c02bcf94075c546a8c409.png" alt="Delete 符号"></td></tr><tr><td align="left">向前删除键</td><td align="left"><img src= "/img/loading.gif" data-lazy-src="https://help.apple.com/assets/5EF110D6680CE23B38350954/5EF110E3680CE23B3835095C/zh_CN/ada1e91f6f600e9bedfd0cfa6350016e.png" alt="向前删除符号"></td></tr><tr><td align="left">上箭头键</td><td align="left"><img src= "/img/loading.gif" data-lazy-src="https://help.apple.com/assets/5EF110D6680CE23B38350954/5EF110E3680CE23B3835095C/zh_CN/f0580e8a608126a12c53e7e9cb781f6a.png" alt="上箭头符号"></td></tr><tr><td align="left">下箭头键</td><td align="left"><img src= "/img/loading.gif" data-lazy-src="https://help.apple.com/assets/5EF110D6680CE23B38350954/5EF110E3680CE23B3835095C/zh_CN/c3eaebe7bf4f546981782483deb66c3d.png" alt="下箭头符号"></td></tr><tr><td align="left">左箭头键</td><td align="left"><img src= "/img/loading.gif" data-lazy-src="https://help.apple.com/assets/5EF110D6680CE23B38350954/5EF110E3680CE23B3835095C/zh_CN/48aad3ebcec5008affc2c4d1909e8181.png" alt="左箭头符号"></td></tr><tr><td align="left">右箭头键</td><td align="left"><img src= "/img/loading.gif" data-lazy-src="https://help.apple.com/assets/5EF110D6680CE23B38350954/5EF110E3680CE23B3835095C/zh_CN/910af33ff9bce5ce72f76173bbee6db8.png" alt="右箭头符号"></td></tr><tr><td align="left">Page Up</td><td align="left"><img src= "/img/loading.gif" data-lazy-src="https://help.apple.com/assets/5EF110D6680CE23B38350954/5EF110E3680CE23B3835095C/zh_CN/3ebb2923e18011444f96c5250e45aba5.png" alt="Page Up 符号"></td></tr><tr><td align="left">Page Down</td><td align="left"><img src= "/img/loading.gif" data-lazy-src="https://help.apple.com/assets/5EF110D6680CE23B38350954/5EF110E3680CE23B3835095C/zh_CN/293ba6a98cc6b5d2ef0c991aa127b16b.png" alt="Page Down 符号"></td></tr><tr><td align="left">Top (Home)</td><td align="left"><img src= "/img/loading.gif" data-lazy-src="https://help.apple.com/assets/5EF110D6680CE23B38350954/5EF110E3680CE23B3835095C/zh_CN/f2459d16a2dc99487ffedccd96ba2371.png" alt="Top 符号"></td></tr><tr><td align="left">End</td><td align="left"><img src= "/img/loading.gif" data-lazy-src="https://help.apple.com/assets/5EF110D6680CE23B38350954/5EF110E3680CE23B3835095C/zh_CN/070b28862a467ea7a5adc92d58159d4c.png" alt="End 符号"></td></tr><tr><td align="left">右制表符</td><td align="left"><img src= "/img/loading.gif" data-lazy-src="https://help.apple.com/assets/5EF110D6680CE23B38350954/5EF110E3680CE23B3835095C/zh_CN/cd484d20455f2ae2026ed324d873c1d7.png" alt="右制表符符号"></td></tr><tr><td align="left">左制表符</td><td align="left"><img src= "/img/loading.gif" data-lazy-src="https://help.apple.com/assets/5EF110D6680CE23B38350954/5EF110E3680CE23B3835095C/zh_CN/980be5db7a048e35a2227a5ecf9f1118.png" alt="左制表符符号"></td></tr><tr><td align="left">Escape (Esc)</td><td align="left"><img src= "/img/loading.gif" data-lazy-src="https://help.apple.com/assets/5EF110D6680CE23B38350954/5EF110E3680CE23B3835095C/zh_CN/aa1397cc08985a6824afe45c4f62ac87.png" alt="Escape 符号"></td></tr></tbody></table><h3 id="剪切、拷贝、粘贴和其他常用快捷键"><a href="#剪切、拷贝、粘贴和其他常用快捷键" class="headerlink" title="剪切、拷贝、粘贴和其他常用快捷键"></a>剪切、拷贝、粘贴和其他常用快捷键</h3><ul><li><strong>Command-X</strong>：剪切所选项并拷贝到剪贴板。</li><li><strong>Command-C</strong>：将所选项拷贝到剪贴板。这同样适用于“访达”中的文件。</li><li><strong>Command-V</strong>：将剪贴板的内容粘贴到当前文稿或 App 中。这同样适用于“访达”中的文件。</li><li><strong>Command-Z</strong>：撤销上一个命令。随后您可以按 Shift-Command-Z 来重做，从而反向执行撤销命令。在某些 App 中，您可以撤销和重做多个命令。</li><li><strong>Command-A</strong>：全选各项。</li><li><strong>Command-F</strong>：查找文稿中的项目或打开“查找”窗口。</li><li><strong>Command-G</strong>：再次查找：查找之前所找到项目出现的下一个位置。要查找出现的上一个位置，请按 Shift-Command-G。</li><li><strong>Command-H</strong>：隐藏最前面的 App 的窗口。要查看最前面的 App 但隐藏所有其他 App，请按 Option-Command-H。</li><li><strong>Command-M</strong>：将最前面的窗口最小化至“程序坞”。要最小化最前面的 App 的所有窗口，请按 Option-Command-M。</li><li><strong>Command-O：</strong>打开所选项，或打开一个对话框以选择要打开的文件。</li><li><strong>Command-P</strong>：打印当前文稿。</li><li><strong>Command-S</strong>：存储当前文稿。</li><li><strong>Command-T</strong>：打开新标签页。</li><li><strong>Command-W</strong>：关闭最前面的窗口。要关闭 App 的所有窗口，请按下 Option-Command-W。</li><li><strong>Option-Command-Esc</strong>：<a href="https://support.apple.com/zh-cn/HT201276">强制退出</a> App。</li><li><strong>Command–空格键</strong>：显示或隐藏“<a href="https://support.apple.com/zh-cn/HT201744">聚焦</a>”搜索栏。要从“访达”窗口执行“聚焦”搜索，请按 Command–Option–空格键。（如果您<a href="https://support.apple.com/zh-cn/guide/mac-help/type-in-another-language-with-input-sources-mchlp1406/mac">使用多个输入源</a>以便用不同的语言键入内容，这些快捷键会更改输入源而非显示“聚焦”。了解如何<a href="https://support.apple.com/zh-cn/guide/mac-help/change-a-conflicting-keyboard-shortcut-mh35591/mac">更改冲突的键盘快捷键</a>。）</li><li><strong>Control-Command–空格键</strong>：显示字符检视器，您可以从中选择<a href="https://support.apple.com/zh-cn/HT201586">表情符号和其他符号</a>。</li><li><strong>Control-Command-F</strong>：全屏使用 App（如果 App 支持）。</li><li><strong>空格键</strong>：使用<a href="https://support.apple.com/zh-cn/guide/mac-help/quick-look-files-and-folders-mh14119/mac">快速查看</a>来预览所选项。</li><li><strong>Command-Tab</strong>：在打开的 App 中切换到下一个最近使用的 App。 </li><li><strong>Shift-Command-5</strong>：在 <a href="https://support.apple.com/zh-cn/HT201260">macOS Mojave 或更高版本</a>中，拍摄截屏或录制屏幕。也可以使用 Shift-Command-3 或 Shift-Command-4 来拍摄截屏。<a href="https://support.apple.com/zh-cn/HT201361">进一步了解截屏</a>。</li><li><strong>Shift-Command-N：</strong>在“访达”中创建一个新文件夹。</li><li>**Command-逗号 (,)**：打开最前面的 App 的偏好设置。</li></ul><h3 id="睡眠、退出登录和关机快捷键"><a href="#睡眠、退出登录和关机快捷键" class="headerlink" title="睡眠、退出登录和关机快捷键"></a>睡眠、退出登录和关机快捷键</h3><p>在这些快捷键中，您可能需要按住其中一些快捷键稍长时间。这样有助于避免无意中启用快捷键。</p><ul><li><strong>电源按钮</strong>：按下可将 Mac 开机或将 Mac 从睡眠状态唤醒。按住这个按钮 1.5 秒可使 Mac 进入睡眠状态。*继续按住<a href="https://support.apple.com/zh-cn/HT201150">则会强制您的 Mac 关机</a>。</li><li>*<em>Option–Command–电源按钮**</em>或 <strong>Option–Command–Media Eject（Option–Command–介质推出键）</strong><img src= "/img/loading.gif" data-lazy-src="https://support.apple.com/library/content/dam/edam/applecare/images/en_US/il/eject-button-icon.png" alt="img">：将您的 Mac 置于睡眠状态。</li><li>*<em>Control–Shift–电源按钮**</em>或 <strong>Control–Shift–Media Eject（Control–Shift–介质推出键）</strong><img src= "/img/loading.gif" data-lazy-src="https://support.apple.com/library/content/dam/edam/applecare/images/en_US/il/eject-button-icon.png" alt="img">：将显示器置于睡眠状态。</li><li>*<em>Control–电源按钮**</em> 或 <strong>Control–介质推出键</strong> <img src= "/img/loading.gif" data-lazy-src="https://support.apple.com/library/content/dam/edam/applecare/images/en_US/il/eject-button-icon.png" alt="img">：显示一个对话框，询问您是要重新启动、睡眠还是关机。</li><li>*<em>Control–Command–电源按钮**</em>：强制 Mac 重新启动，系统不会提示是否要存储任何打开且未存储的文稿。</li><li><strong>Control–Command–Media Eject（Control–Command–介质推出键）</strong><img src= "/img/loading.gif" data-lazy-src="https://support.apple.com/library/content/dam/edam/applecare/images/en_US/il/eject-button-icon.png" alt="img">：退出所有 App，然后重新启动您的Mac。如果任何打开的文稿有未存储的更改，系统会询问您是否要存储这些更改。</li><li>*<em>Control–Option–Command–电源按钮**</em> 或 <strong>Control–Option–Command–介质推出键</strong> <img src= "/img/loading.gif" data-lazy-src="https://support.apple.com/library/content/dam/edam/applecare/images/en_US/il/eject-button-icon.png" alt="img">：退出所有 App，然后将您的 Mac 关机。如果任何打开的文稿有未存储的更改，系统会询问您是否要存储这些更改。</li><li><strong>Control-Command-Q</strong>：立即锁定屏幕。</li><li><strong>Shift–Command–Q</strong>：退出登录您的 macOS 用户帐户。系统将提示您确认。要在不确认的情况下立即退出登录，请按下 Option-Shift-Command-Q。</li></ul><h3 id="访达和系统快捷键"><a href="#访达和系统快捷键" class="headerlink" title="访达和系统快捷键"></a>访达和系统快捷键</h3><ul><li><strong>Command-D</strong>：复制所选文件。</li><li><strong>Command-E</strong>：推出所选磁盘或宗卷。</li><li><strong>Command-F</strong>：在“访达”窗口中开始“聚焦”搜索。</li><li><strong>Command-I</strong>：显示所选文件的“显示简介”窗口。</li><li><strong>Command-R</strong>：(1) 如果在“访达”中选择了某个别名：显示所选别名对应的原始文件。(2) 在某些 App（如“日历”或 Safari 浏览器）中，刷新或重新载入页面。(3) 在<a href="https://support.apple.com/zh-cn/HT201541">“软件更新”偏好设置</a>中，再次检查有没有软件更新。</li><li><strong>Shift-Command-C</strong>：打开“电脑”窗口。</li><li><strong>Shift-Command-D</strong>：打开“桌面”文件夹。</li><li><strong>Shift-Command-F</strong>：打开“最近使用”窗口，其中显示了您最近查看或更改过的所有文件。</li><li><strong>Shift-Command-G</strong>：打开“前往文件夹”窗口。</li><li><strong>Shift-Command-H</strong>：打开当前 macOS 用户帐户的个人文件夹。</li><li><strong>Shift-Command-I</strong>：打开 iCloud 云盘。</li><li><strong>Shift-Command-K</strong>：打开“网络”窗口。</li><li><strong>Option-Command-L</strong>：打开“下载”文件夹。</li><li><strong>Shift-Command-N：</strong>新建文件夹。</li><li><strong>Shift-Command-O</strong>：打开“文稿”文件夹。</li><li><strong>Shift-Command-P</strong>：在“访达”窗口中显示或隐藏预览面板。</li><li><strong>Shift-Command-R</strong>：打开“隔空投送”窗口。</li><li><strong>Shift-Command-T</strong>：显示或隐藏“访达”窗口中的标签页栏。 </li><li><strong>Ctrl-Shift-Command-T</strong>：将所选的“访达”项目添加到“程序坞”（OS X Mavericks 或更高版本）</li><li><strong>Shift-Command-U</strong>：打开“实用工具”文件夹。</li><li><strong>Option-Command-D</strong>：显示或隐藏“程序坞”。 </li><li><strong>Control-Command-T</strong>：将所选项添加到边栏（OS X Mavericks 或更高版本）。</li><li><strong>Option-Command-P</strong>：隐藏或显示“访达”窗口中的路径栏。</li><li><strong>Option-Command-S</strong>：隐藏或显示“访达”窗口中的边栏。</li><li>**Command–斜线 (/)**：隐藏或显示“访达”窗口中的状态栏。</li><li><strong>Command-J</strong>：显示“显示”选项。</li><li><strong>Command-K</strong>：打开“连接服务器”窗口。</li><li><strong>Command-L</strong>：为所选项制作替身。</li><li><strong>Command-N</strong>：打开一个新的“访达”窗口。</li><li><strong>Option-Command-N</strong>：新建智能文件夹。</li><li><strong>Command-T</strong>：在当前“访达”窗口中有单个标签页开着的状态下显示或隐藏标签页栏。</li><li><strong>Option-Command-T</strong>：在当前“访达”窗口中有单个标签页开着的状态下显示或隐藏工具栏。</li><li><strong>Option-Command-V</strong>：移动：将剪贴板中的文件从原始位置移动到当前位置。</li><li><strong>Command-Y</strong>：使用“快速查看”预览所选文件。</li><li><strong>Option-Command-Y</strong>：显示所选文件的快速查看幻灯片显示。</li><li><strong>Command-1</strong>：以图标方式显示“访达”窗口中的项目。</li><li><strong>Command-2</strong>：以列表方式显示“访达”窗口中的项目。</li><li><strong>Command-3</strong>：以分栏方式显示“访达”窗口中的项目。 </li><li><strong>Command-4</strong>：以画廊方式显示“访达”窗口中的项目。</li><li>**Command–左中括号 ([)**：前往上一文件夹。</li><li>**Command–右中括号 (])**：前往下一个文件夹。</li><li><strong>Command–上箭头</strong>：打开包含当前文件夹的文件夹。</li><li><strong>Command–Control–上箭头</strong>：在新窗口中打开包含当前文件夹的文件夹。</li><li><strong>Command–下箭头</strong>：打开所选项。</li><li><strong>右箭头</strong>：打开所选文件夹。这个快捷键仅在列表视图中有效。</li><li><strong>左箭头</strong>：关闭所选文件夹。这个快捷键仅在列表视图中有效。</li><li><strong>Command-Delete</strong>：将所选项移到废纸篓。</li><li><strong>Shift-Command-Delete</strong>：清倒废纸篓。</li><li><strong>Option-Shift-Command-Delete</strong>：清倒废纸篓而不显示确认对话框。</li><li><strong>Command–调高亮度</strong>：打开或关闭<a href="https://support.apple.com/zh-cn/HT204592">目标显示器模式</a>。</li><li><strong>Command–调低亮度</strong>：当您的 Mac 连接到多台显示器时，打开或关闭<a href="https://support.apple.com/zh-cn/HT202351#mirroring">视频镜像</a>。</li><li><strong>Option–调高亮度</strong>：打开“显示器”偏好设置。这个快捷键可与任一亮度键搭配使用。</li><li><strong>Control–调高亮度</strong>或 <strong>Control–调低亮度</strong>：更改外部显示器的亮度（如果显示器支持）。</li><li><strong>Option-Shift–调高亮度</strong>或 <strong>Option-Shift–调低亮度</strong>：以较小的步幅调节显示器亮度。如果您的显示器支持，可以将 Control 键添加到此快捷键，以便在外置显示器上进行调节。</li><li><strong>Option–“调度中心”</strong>：打开“调度中心”偏好设置。</li><li><strong>Command–调度中心</strong>：显示桌面。 </li><li><strong>Control–下箭头</strong>：显示最前面的 App 的所有窗口。</li><li><strong>Option–调高音量</strong>：打开“声音”偏好设置。这个快捷键可与任一音量键搭配使用。</li><li><strong>Option-Shift–调高音量</strong>或 <strong>Option-Shift–调低音量</strong>：以较小的步幅调节音量。</li><li><strong>Option–键盘调高亮度</strong>：打开“键盘”偏好设置。这个快捷键可与任一键盘亮度键搭配使用。</li><li><strong>Option-Shift–键盘调高亮度</strong>或 <strong>Option-Shift–键盘调低亮度</strong>：以较小的步幅调节键盘亮度。</li><li><strong>连按 Option 键</strong>：在单独的窗口中打开项目，然后关闭原始窗口。</li><li><strong>连按 Command 键</strong>：在单独的标签页或窗口中打开文件夹。</li><li><strong>按住 Command 键拖移到另一个宗卷</strong>：将拖移的项目移到另一个宗卷，而不是拷贝它。 </li><li><strong>按住 Option 键拖移</strong>：拷贝托移的项目。拖移项目时指针会随之变化。</li><li><strong>拖移时按住 Option-Command</strong>：为拖移的项目制作替身。拖移项目时指针会随之变化。</li><li><strong>按住 Option 键点按开合三角</strong>：打开所选文件夹内的所有文件夹。这个快捷键仅在列表视图中有效。</li><li><strong>按住 Command 键点按窗口标题</strong>：查看包含当前文件夹的文件夹。</li><li><a href="https://support.apple.com/zh-cn/guide/mac-help/select-items-mchlp1378">了解如何使用 Command 或 Shift 在“访达”中选择多个项目</a>。 </li><li>点按“访达”菜单栏中的“前往”菜单查看用于打开许多常用文件夹（如“应用程序”、“文稿”、“下载”、“实用工具”和“iCloud 云盘”）的快捷键。</li></ul><h3 id="文稿快捷键"><a href="#文稿快捷键" class="headerlink" title="文稿快捷键"></a>文稿快捷键</h3><p>这些快捷键的行为可能因您使用的 App 而异。</p><ul><li><strong>Command-B</strong>：以粗体显示所选文本，或者打开或关闭粗体显示功能。 </li><li><strong>Command-I</strong>：以斜体显示所选文本，或者打开或关闭斜体显示功能。</li><li><strong>Command-K</strong>：添加网页链接。</li><li><strong>Command-U</strong>：对所选文本加下划线，或者打开或关闭加下划线功能。</li><li><strong>Command-T</strong>：显示或隐藏“字体”窗口。</li><li><strong>Command-D</strong>：从“打开”对话框或“存储”对话框内选择“桌面”文件夹。</li><li><strong>Control-Command-D</strong>：显示或隐藏所选字词的定义。</li><li>**Shift-Command–冒号 (:)**：显示“拼写和语法”窗口。</li><li>**Command–分号 (;)**：查找文稿中拼写错误的字词。</li><li><strong>Option-Delete</strong>：删除插入点左边的字词。</li><li><strong>Control-H</strong>：删除插入点左边的字符。也可以使用 Delete 键。</li><li><strong>Control-D</strong>：删除插入点右边的字符。也可以使用 Fn-Delete。</li><li><strong>Fn-Delete</strong>：在没有向前删除  键的键盘上向前删除。也可以使用 Control-D。</li><li><strong>Control-K</strong>：删除插入点与行或段落末尾处之间的文本。</li><li><strong>Fn–上箭头</strong>：Page Up：向上滚动一页。 </li><li><strong>Fn–下箭头</strong>：Page Down：向下滚动一页。</li><li><strong>Fn–左箭头：</strong>Home：滚动到文稿开头。</li><li><strong>Fn–右箭头</strong>：End：滚动到文稿末尾。</li><li><strong>Command–上箭头</strong>：将插入点移至文稿开头。</li><li><strong>Command–下箭头</strong>：将插入点移至文稿末尾。</li><li><strong>Command–左箭头</strong>：将插入点移至当前行的行首。</li><li><strong>Command–右箭头</strong>：将插入点移至当前行的行尾。</li><li><strong>Option–左箭头</strong>：将插入点移至上一字词的词首。</li><li><strong>Option–右箭头</strong>：将插入点移至下一字词的词尾。</li><li><strong>Shift-Command–上箭头</strong>：选中插入点与文稿开头之间的文本。</li><li><strong>Shift-Command–下箭头</strong>：选中插入点与文稿末尾之间的文本。</li><li><strong>Shift-Command–左箭头</strong>：选中插入点与当前行行首之间的文本。</li><li><strong>Shift-Command–右箭头</strong>：选中插入点与当前行行尾之间的文本。</li><li><strong>Shift–上箭头</strong>：将文本选择范围扩展到上一行相同水平位置的最近字符处。</li><li><strong>Shift–下箭头</strong>：将文本选择范围扩展到下一行相同水平位置的最近字符处。</li><li><strong>Shift–左箭头</strong>：将文本选择范围向左扩展一个字符。</li><li><strong>Shift–右箭头</strong>：将文本选择范围向右扩展一个字符。</li><li><strong>Option–Shift–上箭头</strong>：将文本选择范围扩展到当前段落的段首，再按一次则扩展到下一段落的段首。</li><li><strong>Option–Shift–下箭头</strong>：将文本选择范围扩展到当前段落的段尾，再按一次则扩展到下一段落的段尾。</li><li><strong>Option–Shift–左箭头</strong>：将文本选择范围扩展到当前字词的词首，再按一次则扩展到后一字词的词首。</li><li><strong>Option–Shift–左箭头</strong>：将文本选择范围扩展到当前字词的词尾，再按一次则扩展到后一字词的词尾。</li><li><strong>Control–A</strong>：移至行或段落的开头。</li><li><strong>Control–E</strong>：移至行或段落的末尾。</li><li><strong>Control–F</strong>：向前移动一个字符。</li><li><strong>Control–B</strong>：向后移动一个字符。</li><li><strong>Control–L</strong>：将光标或所选内容置于可见区域中央。</li><li><strong>Control–P</strong>：上移一行。</li><li><strong>Control–N</strong>：下移一行。</li><li><strong>Control–O</strong>：在插入点后新插入一行。</li><li><strong>Control–T</strong>：将插入点后面的字符与插入点前面的字符交换。</li><li>**Command–左花括号 ({)**：左对齐。</li><li>**Command–右花括号 (})**：右对齐。</li><li>**Shift-Command–竖线 (|)**：居中对齐。</li><li><strong>Option-Command-F</strong>：前往搜索栏。 </li><li><strong>Option-Command-T</strong>：显示或隐藏 App 中的工具栏。</li><li><strong>Option-Command-C</strong>：拷贝样式：将所选项的格式设置拷贝到剪贴板。</li><li><strong>Option-Command-V</strong>：粘贴样式：将拷贝的样式应用到所选项。</li><li><strong>Option-Shift-Command-V</strong>：粘贴并匹配样式：将周围内容的样式应用到粘贴在该内容中的项目。</li><li><strong>Option-Command-I</strong>：显示或隐藏检查器窗口。</li><li><strong>Shift-Command-P</strong>：页面设置：显示用于选择文稿设置的窗口。</li><li><strong>Shift-Command-S</strong>：显示“存储为”对话框或复制当前文稿。</li><li>**Shift-Command-减号 (-)**：缩小所选项。</li><li>**Shift-Command-加号 (+)**：放大所选项。Command–等号 (=) 可实现相同的功能。</li><li>**Shift-Command–问号 (?)**：打开“帮助”菜单。</li></ul><h3 id="Mac-的启动组合键"><a href="#Mac-的启动组合键" class="headerlink" title="Mac 的启动组合键"></a>Mac 的启动组合键</h3><p>了解可通过在启动时按住一个或多个按键来访问的 Mac 功能和工具。 </p><p>要使用这些组合键中的任何一个，请在按下电源按钮以<a href="https://support.apple.com/zh-cn/HT201150">开启 Mac</a> 后或在 Mac 开始重新启动后，立即按住相应按键。请一直按住，直至电脑出现对应的行为。</p><ul><li><strong>Command (⌘)-R：</strong>从内建的 <a href="https://support.apple.com/zh-cn/HT201314">macOS 恢复</a>系统启动。或者，您也可以使用 Option-Command-R 或 Shift-Option-Command-R 以通过互联网从 macOS 恢复功能启动。<a href="https://support.apple.com/zh-cn/HT204904">macOS 恢复功能可以安装不同版本的 macOS</a>，具体取决于您在电脑启动时使用的组合键。如果您的 Mac 使用了<a href="https://support.apple.com/zh-cn/HT204455">固件密码</a>，系统将提示您输入这个密码。</li><li><strong>Option (⌥) 或 Alt：</strong>启动进入“<a href="https://support.apple.com/zh-cn/HT202796">启动管理器</a>”，您可以从中选取其他可用的启动磁盘或宗卷。如果您的 Mac 使用了<a href="https://support.apple.com/zh-cn/HT204455">固件密码</a>，系统将提示您输入这个密码。</li><li><strong>Option-Command-P-R：</strong><a href="https://support.apple.com/zh-cn/HT204063">重置 NVRAM</a> 或 PRAM。如果您的 Mac 使用了<a href="https://support.apple.com/zh-cn/HT204455">固件密码</a>，电脑会忽略这个组合键或从 <a href="https://support.apple.com/zh-cn/HT201314">macOS 恢复功能</a>启动。 </li><li><strong>Shift (⇧)：</strong>以<a href="https://support.apple.com/zh-cn/HT201262">安全模式</a>启动。如果使用了<a href="https://support.apple.com/zh-cn/HT204455">固件密码</a>，这个组合键将被停用。</li><li><strong>D：</strong>启动进入“<a href="https://support.apple.com/zh-cn/HT202731">Apple 诊断</a>”实用工具。或者，您也可以使用 Option-D 通过互联网启动进入这个实用工具。如果使用了<a href="https://support.apple.com/zh-cn/HT204455">固件密码</a>，这个组合键将被停用。</li><li><strong>N：</strong>从 NetBoot 服务器启动，<a href="https://support.apple.com/zh-cn/HT202770">前提是您的 Mac 支持网络启动宗卷</a>。要使用服务器上默认的引导映像，请按住 Option-N。如果使用了<a href="https://support.apple.com/zh-cn/HT204455">固件密码</a>，这个组合键将被停用。</li><li><strong>Command-S：</strong>以<a href="https://support.apple.com/zh-cn/HT201573">单用户模式</a>启动。如果运行的是 <a href="https://support.apple.com/zh-cn/HT201260">macOS Mojave 或更高版本</a>，或者使用了<a href="https://support.apple.com/zh-cn/HT204455">固件密码</a>，这个组合键将被停用。</li><li><strong>T：</strong>以<a href="https://support.apple.com/zh-cn/HT201462">目标磁盘模式</a>启动。如果使用了<a href="https://support.apple.com/zh-cn/HT204455">固件密码</a>，这个组合键将被停用。</li><li><strong>Command-V：</strong>以<a href="https://support.apple.com/zh-cn/HT201573">详细模式</a>启动。如果使用了<a href="https://support.apple.com/zh-cn/HT204455">固件密码</a>，这个组合键将被停用。</li><li><strong>推出键</strong> (⏏)、<strong>F12</strong>、<strong>鼠标按钮</strong>或<strong>触控板按钮：</strong>推出可移动介质，例如光盘。如果使用了<a href="https://support.apple.com/zh-cn/HT204455">固件密码</a>，这个组合键将被停用。</li></ul><h3 id="Mac-上的“聚焦”键盘快捷键"><a href="#Mac-上的“聚焦”键盘快捷键" class="headerlink" title="Mac 上的“聚焦”键盘快捷键"></a>Mac 上的“聚焦”键盘快捷键</h3><p>在 Mac 上使用键盘快捷键通过“聚焦”快速搜索。</p><table><thead><tr><th align="left">操作</th><th align="left">快捷键</th></tr></thead><tbody><tr><td align="left">打开“聚焦”以启动搜索</td><td align="left">Command-空格键</td></tr><tr><td align="left">使用建议的结果完成搜索</td><td align="left">右箭头键</td></tr><tr><td align="left">移到下一个搜索结果</td><td align="left">下箭头键</td></tr><tr><td align="left">移到上一个搜索结果</td><td align="left">上箭头键</td></tr><tr><td align="left">移到下一个类别中的第一个搜索结果</td><td align="left">Command-下箭头</td></tr><tr><td align="left">移到上一个类别中的第一个搜索结果</td><td align="left">Command-上箭头</td></tr><tr><td align="left">显示 Mac 上的搜索结果（如文件）路径</td><td align="left">Command</td></tr><tr><td align="left">放大图像预览</td><td align="left">Control 键（然后在触控板上移动双指以在预览中移动图像）</td></tr><tr><td align="left">打开所选结果</td><td align="left">Return 键</td></tr><tr><td align="left">在 App 或<a href="https://support.apple.com/zh-cn/guide/mac-help/aside/glos00063759/10.15/mac/10.15">“访达”</a>中查看文件</td><td align="left">Command-R 或 Command-连按</td></tr><tr><td align="left">打开搜索结果已选定的“访达”窗口</td><td align="left">Option-Command-空格键</td></tr></tbody></table><h3 id="Mac-上-Safari-浏览器中的键盘快捷键和手势"><a href="#Mac-上-Safari-浏览器中的键盘快捷键和手势" class="headerlink" title="Mac 上 Safari 浏览器中的键盘快捷键和手势"></a>Mac 上 Safari 浏览器中的键盘快捷键和手势</h3><p>除 Safari 浏览器菜单中显示的快捷键外，您还可以使用以下快捷键。</p><h4 id="网页"><a href="#网页" class="headerlink" title="网页"></a>网页</h4><table><thead><tr><th align="left">操作</th><th align="left">快捷键或手势</th></tr></thead><tbody><tr><td align="left">向上、向下、向左或向右滚动</td><td align="left">按下箭头键。</td></tr><tr><td align="left">大幅度滚动</td><td align="left">按下箭头键时按住 Option 键。</td></tr><tr><td align="left">向下滚动屏幕</td><td align="left">Page Down 键空格键</td></tr><tr><td align="left">向上滚动屏幕</td><td align="left">Page Up 键Shift-空格键</td></tr><tr><td align="left">滚动到页面左上角或左下角</td><td align="left">Command–上箭头键或 Home 键Command–下箭头键或 End 键</td></tr><tr><td align="left">高亮显示网页上的下一项</td><td align="left">Tab 将高亮显示下一文本栏或弹出式菜单。如果在“系统偏好设置”的“键盘”面板的“快捷键”面板中选择了“所有控制”，Tab 还将高亮显示按钮和其他控制。按下 Option-Tab 会高亮显示按下 Tab 键所高亮显示的项目，以及所有其他可点按项目。若要交换 Tab 和 Option-Tab 的行为，请在 Safari 浏览器偏好设置的“高级”面板中打开“按下 Tab 键以高亮显示网页上的每一项”。</td></tr><tr><td align="left">显示所有标签页</td><td align="left">Shift-Command-\</td></tr><tr><td align="left">在新标签页中打开页面</td><td align="left">按住 Command 键点按链接按住 Command 键点按书签在<a href="https://support.apple.com/zh-cn/guide/safari/aside/glos5a7c4a65/13.0/mac/10.15">智能搜索栏</a>中键入后，按下 Command-Return。</td></tr><tr><td align="left">在新标签页中打开页面，并使该标签页成为活跃标签页</td><td align="left">按住 Shift-Command 点按链接按住 Shift-Command 点按书签在智能搜索栏中键入后，按下 Shift-Command-Return。</td></tr><tr><td align="left">使下一标签页成为活跃标签页</td><td align="left">Control-Tab 或 Shift-Command-]</td></tr><tr><td align="left">使上一标签页成为活跃标签页</td><td align="left">Control-Shift-Tab 或 Shift-Command -[</td></tr><tr><td align="left">选择前 9 个标签页中的一个</td><td align="left">Command-1 到 Command-9</td></tr><tr><td align="left">关闭全部标签页，只保留其中一个</td><td align="left">按住 Option 键点按您要保持打开的标签页上的“关闭”按钮 <img src= "/img/loading.gif" data-lazy-src="https://help.apple.com/assets/5E191630680CE2E07445B58A/5E191634680CE2E07445B591/zh_CN/7bba8a8a3f5749b2aa1803dbc411c33b.png" alt="img"></td></tr><tr><td align="left">重新打开上次关闭的标签页或窗口</td><td align="left">Shift-Command-T</td></tr><tr><td align="left">按名称查看最近访问页面的列表</td><td align="left">按住“后退”<img src= "/img/loading.gif" data-lazy-src="https://help.apple.com/assets/5E191630680CE2E07445B58A/5E191634680CE2E07445B591/zh_CN/0c4ab2775b2487b679f490cd69937d92.png" alt="img"> 或“前进”<img src= "/img/loading.gif" data-lazy-src="https://help.apple.com/assets/5E191630680CE2E07445B58A/5E191634680CE2E07445B591/zh_CN/fc1a25678d1c65d4fd4746243fd8ee15.png" alt="img"> 按钮，直到列表出现</td></tr><tr><td align="left">按网址 (URL) 查看最近访问页面的列表</td><td align="left">按下 Option 键，并按住“后退”或“前进”按钮，直到列表出现</td></tr><tr><td align="left">前往主页</td><td align="left">Command-Home 键</td></tr><tr><td align="left">在<a href="https://support.apple.com/zh-cn/guide/safari/aside/glos5a7c4a65/13.0/mac/10.15">智能搜索栏</a>中键入时，恢复当前网页地址</td><td align="left">Esc 键</td></tr><tr><td align="left">关闭阅读器</td><td align="left">Esc 键</td></tr><tr><td align="left">退出全屏幕视图</td><td align="left">Esc 键</td></tr><tr><td align="left">下载链接文件</td><td align="left">按住 Option 键点按文件的链接</td></tr><tr><td align="left">打开下载的文件</td><td align="left">连按下载列表中的文件</td></tr><tr><td align="left">缩放网站内容</td><td align="left">按下 Command-加号 (+) 或 Command-减号 (–)</td></tr><tr><td align="left">缩放网站文本</td><td align="left">选取“显示”&gt;“使文本变大”或“显示”&gt;“使文本变小”时，按下 Option 键。</td></tr></tbody></table><h4 id="阅读列表"><a href="#阅读列表" class="headerlink" title="阅读列表"></a>阅读列表</h4><table><thead><tr><th align="left">操作</th><th align="left">快捷键或手势</th></tr></thead><tbody><tr><td align="left">显示或隐藏阅读列表边栏</td><td align="left">Control-Command-2</td></tr><tr><td align="left">添加当前页面</td><td align="left">Shift-Command-D</td></tr><tr><td align="left">添加链接页面</td><td align="left">按住 Shift 键点按页面的链接</td></tr><tr><td align="left">移除页面</td><td align="left">按住 Control 键点按边栏中的页面摘要，然后选取“移除项目”。您也可以在页面摘要上向左轻扫，然后点按“移除”。或者，一直向左轻扫直至页面摘要消失。</td></tr></tbody></table><h4 id="书签"><a href="#书签" class="headerlink" title="书签"></a>书签</h4><table><thead><tr><th align="left">操作</th><th align="left">快捷键或手势</th></tr></thead><tbody><tr><td align="left">将书签添加到“个人收藏”栏</td><td align="left">点按<a href="https://support.apple.com/zh-cn/guide/safari/aside/glos5a7c4a65/13.0/mac/10.15">智能搜索栏</a>以显示页面的完整地址及其图标，然后将图标拖移到“个人收藏”栏</td></tr><tr><td align="left">打开“个人收藏”栏中某个文件夹内的所有书签</td><td align="left">按住 Command 键点按“个人收藏”栏中的文件夹</td></tr><tr><td align="left">在“个人收藏”栏上移动书签</td><td align="left">左右拖移书签</td></tr><tr><td align="left">从“个人收藏”栏移除书签</td><td align="left">将书签拖移到个人收藏栏外</td></tr></tbody></table><h4 id="书签边栏和书签视图"><a href="#书签边栏和书签视图" class="headerlink" title="书签边栏和书签视图"></a>书签边栏和书签视图</h4><table><thead><tr><th align="left">操作</th><th align="left">快捷键或手势</th></tr></thead><tbody><tr><td align="left">显示或隐藏书签边栏</td><td align="left">Control-Command-1</td></tr><tr><td align="left">选择边栏中的书签和文件夹</td><td align="left">按住 Command 键点按每个书签和文件夹按住 Shift 键点按以扩展选择</td></tr><tr><td align="left">选择下一个书签或文件夹</td><td align="left">上箭头键或下箭头键</td></tr><tr><td align="left">打开所选书签</td><td align="left">空格键</td></tr><tr><td align="left">打开所选文件夹</td><td align="left">空格键或右箭头键</td></tr><tr><td align="left">关闭所选文件夹</td><td align="left">空格键或左箭头键</td></tr><tr><td align="left">更改书签的名称或地址</td><td align="left">选择书签，然后按下 Return 键您还可以<a href="https://support.apple.com/zh-cn/guide/safari/aside/glosb234ba05/13.0/mac/10.15">用力点按</a>书签</td></tr><tr><td align="left">取消编辑边栏中的书签名称</td><td align="left">Esc 键</td></tr><tr><td align="left">完成编辑书签名称</td><td align="left">Return 键</td></tr><tr><td align="left">创建包含书签视图中的所选书签和文件夹的文件夹</td><td align="left">按下 Option 键点按右上角附近的“新建文件夹”按钮</td></tr><tr><td align="left">删除书签</td><td align="left">按住 Control 键点按书签，然后选取“删除”</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> MacOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MacOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Activity</title>
      <link href="/Android/Activity/"/>
      <url>/Android/Activity/</url>
      
        <content type="html"><![CDATA[<h2 id="Activity4种本质状态："><a href="#Activity4种本质状态：" class="headerlink" title="Activity4种本质状态："></a>Activity4种本质状态：</h2><ul><li>运行状态： 当前显示在屏幕的activity(位于任务栈的顶部)，用户可见状态。 如果当前的activity在前台界面上时（堆栈顶端）。</li><li>暂停状态： 依旧在用户可见状态，但是界面焦点已经失去，此Activity无法与用户进行交互。 如果activity被另一个非全屏活动强占焦点并覆盖时（如弹窗dialog），它将会暂停。一个暂停的活动也是完全活跃的（它的所有的状态和成员信息将会保留，但activity本身将不会再依附于WindowsManager了），在内存极度缺乏的状态会被系统杀死。</li><li>停止状态： 用户看不到当前界面,也无法与用户进行交互 完全被覆盖.。如果activity完全被另一个全屏活动遮挡住时，它将会停止。该活动也仍保留全部的状态和成员信息，但将会被隐藏起来不再展示给用户，并且当内存在其他地方被需要时该活动就将会被系统杀死。</li><li>销毁状态： 当前界面被销毁，等待这系统被回收 。如果activity处于暂停或者停止状态，系统将会在内存中终止该活动无论是结束活动或者杀死进程。当它再一次展示给用户时，它必须是完全重启并且恢复到之前的状态。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Handler机制</title>
      <link href="/Android/Handler/"/>
      <url>/Android/Handler/</url>
      
        <content type="html"><![CDATA[<p>线程间通信：</p><p>Hander通信实现方案实际上是内存共享的方案</p><p>线程间不会干扰：</p><p>内存管理设计思路优秀 加锁</p><p>Android 一般不使用java层的wait/notify</p><p>handler已经将需要这部分功能进行了Linux层的封装</p><p>lancher （app）：zygote -》 jvm -》 ActvityThread.main</p><h3 id="源码-epoll"><a href="#源码-epoll" class="headerlink" title="源码 epoll"></a>源码 epoll</h3><p>MessageQueue是一个优先级队列（单链表实现）</p><p>传入消息</p><p>MessageQueue.enqueueMessage</p><p>取出消息</p><p>MessageQueue.next()</p><p>子线程<br>handler -&gt; sendMessage   -&gt; messasgeQueue.enqueueMessage  //消息队列队列的插入节点 </p><p>looper.loop() -&gt; messasgeQueue.next（）-&gt;handler.dispatchMessage()-&gt;handler.handleMessage（）</p><p>主线程</p><p>handler.handleMessage（）</p><p>Message,在动的过程，内存<br>new Messaage() obtain()</p><p>内存不分线程</p><p>MessageQueue.next() 方法 通过调用 native方法 nativePollOnce(ptr, nextPollTimeoutMillis)实现无消息处理时，进入阻塞的功能。<br>当nextPollTimeoutMillis 值为0时，该方法会立刻返回；<br>当nextPollTimeoutMillis 值为-1时，该方法会无限阻塞，直到被唤醒；<br>当nextPollTimeoutMillis 值大于0时，该方法会将该值设置为超时时间，阻塞到达一定时间后，返回；</p><h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h3 id="异步消息和同步消息"><a href="#异步消息和同步消息" class="headerlink" title="异步消息和同步消息"></a>异步消息和同步消息</h3><h3 id="消息屏障"><a href="#消息屏障" class="headerlink" title="消息屏障"></a>消息屏障</h3><p>HandlerThread</p><p>IntentSever</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.jianshu.com/p/e172a2d58905">Android：这是一份Handler消息传递机制 的使用教程</a></p><p><a href="https://www.jianshu.com/p/b4d745c7ff7a?tdsourcetag=s_pcqq_aiomsg">Android Handler：手把手带你深入分析 Handler机制源码</a></p><p><a href="https://www.jianshu.com/p/db7bda388d4a">Android Handler那些事儿，消息屏障？IdelHandler?ANR?</a><br>注意密码最后面有！或其它特殊字符，最好复制粘贴密码！</p><p>官网下载教程<a href="https://shimo.im/docs/KhRtdCVdPg8GR6RT/">https://shimo.im/docs/KhRtdCVdPg8GR6RT/</a><br>百度云链接（已汉化）：<a href="https://pan.baidu.com/s/1coy2Y6_KWMlV3A21vz6iJQ">https://pan.baidu.com/s/1coy2Y6_KWMlV3A21vz6iJQ</a><br>提取码：1234 </p><p>改密改邮箱<a href="https://shimo.im/docs/6wrVtx3WTxHPwVrT/">https://shimo.im/docs/6wrVtx3WTxHPwVrT/</a></p><p>汉化教程<a href="https://shimo.im/docs/hPCrh3XhhQxpVVqy/">https://shimo.im/docs/hPCrh3XhhQxpVVqy/</a></p><p>pbe开黑交流群439160678</p><p>常用收费加速器：uu加速器 迅游加速器 腾讯加速器 等</p><p>五星好评带图送免费加速器，可以永久使用！</p><p>上号如果需要过新手教程，可以从新手教程中退出重新登录，即可跳过新手教程！！！！</p><p>免费加速器:  奇妙加速器  <a href="https://www.qimiao.com/">https://www.qimiao.com/</a>  自己注册即可免费使用，使用方法：搜英雄联盟–点击国服—选择美服（测试服）–开启加速–然后手动启动游戏（别用加速器启动）</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android UI绘制流程</title>
      <link href="/Android/UI%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/"/>
      <url>/Android/UI%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>布局文件在 Activity 的生命周期方法中在 <code>onCreate</code> 加载，在 <code>onResume</code> 绘制</p><p>Activity何时被创建</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> UI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift基础</title>
      <link href="/IOS/Swift/"/>
      <url>/IOS/Swift/</url>
      
        <content type="html"><![CDATA[<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs swift"><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//  URankTCell.swift</span><br><span class="hljs-comment">//  U17</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//  Created by charles on 2017/11/8.</span><br><span class="hljs-comment">//  Copyright © 2017年 None. All rights reserved.</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-keyword">import</span> UIKit<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">URankTCell</span>: <span class="hljs-title">UBaseTableViewCell</span> </span>&#123;<br>    <br>    <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> iconView: <span class="hljs-type">UIImageView</span> = &#123;<br>        <span class="hljs-keyword">let</span> iw = <span class="hljs-type">UIImageView</span>()<br>        <span class="hljs-keyword">var</span> a: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">var</span> b: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;w&quot;</span><br>        iw.contentMode = .scaleAspectFill<br>        iw.clipsToBounds = <span class="hljs-literal">true</span><br>        <span class="hljs-keyword">return</span> iw<br>    &#125;()<br>    <br>    <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> titleLabel: <span class="hljs-type">UILabel</span> = &#123;<br>        <span class="hljs-keyword">let</span> tl = <span class="hljs-type">UILabel</span>()<br>        tl.textColor = <span class="hljs-type">UIColor</span>.black<br>        tl.font = <span class="hljs-type">UIFont</span>.systemFont(ofSize: <span class="hljs-number">18</span>)<br>        <span class="hljs-keyword">return</span> tl<br>    &#125;()<br>    <br>    <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> descLabel: <span class="hljs-type">UILabel</span> = &#123;<br>        <span class="hljs-keyword">let</span> dl = <span class="hljs-type">UILabel</span>()<br>        dl.textColor = <span class="hljs-type">UIColor</span>.gray<br>        dl.numberOfLines = <span class="hljs-number">0</span><br>        dl.font = <span class="hljs-type">UIFont</span>.systemFont(ofSize: <span class="hljs-number">14</span>)<br>        <span class="hljs-keyword">return</span> dl<br>    &#125;()<br>    <br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">configUI</span><span class="hljs-params">()</span></span> &#123;<br>        <br>        <span class="hljs-keyword">let</span> line = <span class="hljs-type">UIView</span>().then&#123;<br>            $<span class="hljs-number">0</span>.backgroundColor = <span class="hljs-type">UIColor</span>.background<br>        &#125;<br>        contentView.addSubview(line)<br>        line.snp.makeConstraints&#123;<br>            $<span class="hljs-number">0</span>.<span class="hljs-keyword">left</span>.bottom.<span class="hljs-keyword">right</span>.equalToSuperview()<br>            $<span class="hljs-number">0</span>.height.equalTo(<span class="hljs-number">10</span>)<br>        &#125;<br>        <br>        contentView.addSubview(iconView)<br>        iconView.snp.makeConstraints &#123;<br>            $<span class="hljs-number">0</span>.<span class="hljs-keyword">left</span>.top.equalToSuperview().offset(<span class="hljs-number">10</span>)<br>            $<span class="hljs-number">0</span>.bottom.equalTo(line.snp.top).offset(-<span class="hljs-number">10</span>)<br>            $<span class="hljs-number">0</span>.width.equalToSuperview().multipliedBy(<span class="hljs-number">0.5</span>)<br>        &#125;<br>        <br>        contentView.addSubview(titleLabel)<br>        titleLabel.snp.makeConstraints &#123;<br>            $<span class="hljs-number">0</span>.<span class="hljs-keyword">left</span>.equalTo(iconView.snp.<span class="hljs-keyword">right</span>).offset(<span class="hljs-number">10</span>)<br>            $<span class="hljs-number">0</span>.<span class="hljs-keyword">right</span>.equalToSuperview().offset(-<span class="hljs-number">10</span>)<br>            $<span class="hljs-number">0</span>.height.equalTo(<span class="hljs-number">30</span>)<br>            $<span class="hljs-number">0</span>.top.equalTo(iconView).offset(<span class="hljs-number">20</span>)<br>        &#125;<br>        <br>        contentView.addSubview(descLabel)<br>        descLabel.snp.makeConstraints &#123;<br>            $<span class="hljs-number">0</span>.<span class="hljs-keyword">left</span>.equalTo(iconView.snp.<span class="hljs-keyword">right</span>).offset(<span class="hljs-number">10</span>)<br>            $<span class="hljs-number">0</span>.<span class="hljs-keyword">right</span>.equalToSuperview().offset(-<span class="hljs-number">10</span>)<br>            $<span class="hljs-number">0</span>.top.equalTo(titleLabel.snp.bottom).offset(<span class="hljs-number">10</span>)<br>            $<span class="hljs-number">0</span>.bottom.equalTo(iconView)<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">var</span> model: <span class="hljs-type">RankingModel?</span> &#123;<br>        <span class="hljs-keyword">didSet</span> &#123;<br>            <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> model = model <span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">return</span> &#125;<br>            iconView.kf.setImage(urlString: model.cover)<br>            titleLabel.text = <span class="hljs-string">&quot;\(model.title ?? &quot;</span><span class="hljs-string">&quot;)榜&quot;</span><br>            descLabel.text = model.subTitle<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android开源框架</title>
      <link href="/Android/Android%20Library/"/>
      <url>/Android/Android%20Library/</url>
      
        <content type="html"><![CDATA[<h3 id="awesome-android-libraries"><a href="#awesome-android-libraries" class="headerlink" title="awesome-android-libraries"></a>awesome-android-libraries</h3><p>开源框架整理</p><p>项目地址：<a href="https://github.com/wasabeef/awesome-android-libraries">https://github.com/wasabeef/awesome-android-libraries</a></p><h3 id="glide"><a href="#glide" class="headerlink" title="glide"></a>glide</h3><p>网络图片加载</p><p>项目地址：<a href="https://github.com/bumptech/glide">https://github.com/bumptech/glide</a></p><h3 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h3><p>Http 网络请求</p><p>项目地址：<a href="http://square.github.io/okhttp">http://square.github.io/okhttp</a></p><h3 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a>Retrofit</h3><p>网络请求注解</p><p>项目地址：<a href="http://square.github.io/retrofit">http://square.github.io/retrofit</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android开源UI框架</title>
      <link href="/Android/Android%20UI%E6%A1%86%E6%9E%B6/"/>
      <url>/Android/Android%20UI%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="awesome-android-ui"><a href="#awesome-android-ui" class="headerlink" title="awesome-android-ui"></a>awesome-android-ui</h3><p>开源 UI 框架整理</p><p>项目地址：<a href="https://github.com/wasabeef/awesome-android-ui">https://github.com/wasabeef/awesome-android-ui</a></p><h3 id="PersistentSearch"><a href="#PersistentSearch" class="headerlink" title="PersistentSearch"></a>PersistentSearch</h3><p>在点击搜索的时候控件在原有位置显示输入框。</p><p>项目地址：<a href="https://github.com/Quinny898/PersistentSearch">https://github.com/Quinny898/PersistentSearch</a></p><p> <img src= "/img/loading.gif" data-lazy-src="/assets/1426922209_2845.gif-thumb.jpg" alt="img"></p><h3 id="circular-progress-button"><a href="#circular-progress-button" class="headerlink" title="circular-progress-button"></a>circular-progress-button</h3><p>带进度显示的 Button 。</p><p>项目地址： <a href="https://github.com/dmytrodanylyk/circular-progress-button">https://github.com/dmytrodanylyk/circular-progress-button</a></p><p> <img src= "/img/loading.gif" data-lazy-src="/assets/1426922347_5739.gif-thumb.jpg" alt="img"></p><h3 id="sweet-alert-dialog"><a href="#sweet-alert-dialog" class="headerlink" title="sweet-alert-dialog"></a>sweet-alert-dialog</h3><p>一个带动画效果的自定义对话框样式。</p><p>项目地址：<a href="https://github.com/pedant/sweet-alert-dialog">https://github.com/pedant/sweet-alert-dialog</a></p><p> <img src= "/img/loading.gif" data-lazy-src="/assets/1426922742_2528.gif-thumb.jpg" alt="img"></p><h3 id="android-floating-action-button"><a href="#android-floating-action-button" class="headerlink" title="android-floating-action-button"></a>android-floating-action-button</h3><p>Material Desig 风格的浮动操作按钮。</p><p>项目地址：<a href="https://github.com/futuresimple/android-floating-action-button">https://github.com/futuresimple/android-floating-action-button</a></p><p> <img src= "/img/loading.gif" data-lazy-src="/assets/1426922886_3445.gif-thumb.jpg" alt="img"></p><h3 id="NumberProgressBar"><a href="#NumberProgressBar" class="headerlink" title="NumberProgressBar"></a>NumberProgressBar</h3><p>个简约性感的数字进度条。</p><p>项目地址：<a href="https://github.com/daimajia/NumberProgressBar">https://github.com/daimajia/NumberProgressBar</a></p><p> <img src= "/img/loading.gif" data-lazy-src="/assets/1426923126_2788.gif-thumb.jpg" alt="img"></p><h3 id="CircularProgressView"><a href="#CircularProgressView" class="headerlink" title="CircularProgressView"></a>CircularProgressView</h3><p>CircularProgressView 是通过自定义view的方式实现的 Material 风格的加载提示控件，兼容任何版本。</p><p>项目地址：<a href="https://github.com/rahatarmanahmed/CircularProgressView">https://github.com/rahatarmanahmed/CircularProgressView</a></p><p> <img src= "/img/loading.gif" data-lazy-src="/assets/1426923297_9170.gif-thumb.jpg" alt="img"></p><h3 id="ToggleButton"><a href="#ToggleButton" class="headerlink" title="ToggleButton"></a>ToggleButton</h3><p>状态切换的 Button，类似 iOS，用 View 实现。</p><p>项目地址：<a href="https://github.com/zcweng/ToggleButton">https://github.com/zcweng/ToggleButton</a></p><p> <img src= "/img/loading.gif" data-lazy-src="/assets/1423462956_6647.gif-thumb.jpg" alt="img"></p><h3 id="WilliamChart"><a href="#WilliamChart" class="headerlink" title="WilliamChart"></a>WilliamChart</h3><p>绘制图表的库，支持 LineChartView、BarChartView 和 StackBarChartView 三中图表类型，并且支持 Android 2.2及以上的系统。</p><p>项目地址：<a href="https://github.com/diogobernardino/WilliamChart">https://github.com/diogobernardino/WilliamChart</a></p><p>Demo地址：<a href="https://play.google.com/store/apps/details?id=com.db.williamchartdemo">https://play.google.com/store/apps/details?id=com.db.williamchartdemo</a></p><p>Demo项目：<a href="https://github.com/diogobernardino/WilliamChart/tree/master/sample">https://github.com/diogobernardino/WilliamChart/tree/master/sample</a></p><p> <img src= "/img/loading.gif" data-lazy-src="/assets/1423464450_9931.gif-thumb.jpg" alt="img"></p><h3 id="android-lockpattern"><a href="#android-lockpattern" class="headerlink" title="android-lockpattern"></a>android-lockpattern</h3><p>Android 的图案密码解锁。</p><p>项目地址：<a href="https://code.google.com/p/android-lockpattern/">https://code.google.com/p/android-lockpattern/</a></p><p>Demo地址：<a href="https://play.google.com/store/apps/details?id=group.pals.android.lib.ui.lockpattern.demo">https://play.google.com/store/apps/details?id=group.pals.android.lib.ui.lockpattern.demo</a></p><p>文档介绍：<a href="https://code.google.com/p/android-lockpattern/wiki/QuickUse">https://code.google.com/p/android-lockpattern/wiki/QuickUse</a></p><p>APP示例：Android 开机的图案密码解锁，支付宝的密码解锁。</p><p> <img src= "/img/loading.gif" data-lazy-src="/assets/1423462562_3964.gif-thumb.jpg" alt="img"></p><h3 id="AndroidSwipeLayout"><a href="#AndroidSwipeLayout" class="headerlink" title="AndroidSwipeLayout"></a>AndroidSwipeLayout</h3><p>滑动 Layout，支持单个 View ，ListView ，GridView。</p><p>项目地址：<a href="https://github.com/daimajia/AndroidSwipeLayout">https://github.com/daimajia/AndroidSwipeLayout</a></p><p>Demo地址：<a href="https://github.com/daimajia/AndroidSwipeLayout/releases/download/v1.0.0/AndroidSwipeLayout-Demo-1.0.1-snapshot.apk">Download Demo</a></p><p> <img src= "/img/loading.gif" data-lazy-src="/assets/1423460378_5762.gif-thumb.jpg" alt="img"></p><h3 id="Titanic"><a href="#Titanic" class="headerlink" title="Titanic"></a>Titanic</h3><p>可以显示水位上升下降的 TextView 。</p><p>项目地址：<a href="https://github.com/RomainPiel/Titanic">https://github.com/RomainPiel/Titanic</a></p><p> <img src= "/img/loading.gif" data-lazy-src="/assets/1423213775_1197.gif-thumb.jpg" alt="img"></p><h3 id="Pull-to-Refresh-Rentals-Android"><a href="#Pull-to-Refresh-Rentals-Android" class="headerlink" title="Pull-to-Refresh.Rentals-Android"></a>Pull-to-Refresh.Rentals-Android</h3><p>提供一个简单可以自定义的下拉刷新实现，<a href="http://yalantis.com/">Yalantis</a> 出品。</p><p>项目地址：<a href="https://github.com/Yalantis/Pull-to-Refresh.Rentals-Android">https://github.com/Yalantis/Pull-to-Refresh.Rentals-Android</a></p><p> <img src= "/img/loading.gif" data-lazy-src="/assets/1423211132_9821.gif-thumb.jpg" alt="img"></p><h3 id="CircleRefreshLayout"><a href="#CircleRefreshLayout" class="headerlink" title="CircleRefreshLayout"></a>CircleRefreshLayout</h3><p>带圆形加载的下拉刷新</p><p>项目地址：<a href="https://github.com/tuesda/CircleRefreshLayout">https://github.com/tuesda/CircleRefreshLayout</a></p><p> <img src= "/img/loading.gif" data-lazy-src="/assets/circlerefresh.gif" alt="img"></p><h3 id="Side-Menu-Android"><a href="#Side-Menu-Android" class="headerlink" title="Side-Menu.Android"></a>Side-Menu.Android</h3><p>分类侧滑菜单，<a href="http://yalantis.com/">Yalantis</a> 出品。</p><p>项目地址：<a href="https://github.com/Yalantis/Side-Menu.Android">https://github.com/Yalantis/Side-Menu.Android</a> </p><p> <img src= "/img/loading.gif" data-lazy-src="/assets/1423213091_2192.gif-thumb.jpg" alt="img"></p><h3 id="Context-Menu-Android"><a href="#Context-Menu-Android" class="headerlink" title="Context-Menu.Android"></a>Context-Menu.Android</h3><p>可以方便快速集成漂亮带有动画效果的上下文菜单，<a href="http://yalantis.com/">Yalantis</a>出品。</p><p>项目地址：<a href="https://github.com/Yalantis/Context-Menu.Android">https://github.com/Yalantis/Context-Menu.Android</a></p><p> <img src= "/img/loading.gif" data-lazy-src="/assets/1423213164_4792.gif-thumb.jpg" alt="img"></p><h3 id="MaterialViewPager"><a href="#MaterialViewPager" class="headerlink" title="MaterialViewPager"></a>MaterialViewPager</h3><p>可下拉切换的 ViewPager</p><p>项目地址：<a href="https://github.com/florent37/MaterialViewPager">https://github.com/florent37/MaterialViewPager</a></p><p> <img src= "/img/loading.gif" data-lazy-src="/assets/MaterialViewPager.png" alt="img"></p><h3 id="CircleImageView"><a href="#CircleImageView" class="headerlink" title="CircleImageView"></a>CircleImageView</h3><p>圆形 ImageView</p><p>项目地址：<a href="https://github.com/hdodenhof/CircleImageView">https://github.com/hdodenhof/CircleImageView</a>)</p><p> <img src= "/img/loading.gif" data-lazy-src="/assets/CircleImageView.png" alt="img"></p><h3 id="ExpandableBottomBar"><a href="#ExpandableBottomBar" class="headerlink" title="ExpandableBottomBar"></a>ExpandableBottomBar</h3><p>炫酷的底部导航栏</p><p><a href="https://github.com/st235/ExpandableBottomBar">https://github.com/st235/ExpandableBottomBar</a></p><p> <img src= "/img/loading.gif" data-lazy-src="/assets/ExpandableBottomBarvideo.gif" alt="ExpandableBottomBarvideo"></p><h3 id="SlidingUpPanelLayout"><a href="#SlidingUpPanelLayout" class="headerlink" title="SlidingUpPanelLayout"></a>SlidingUpPanelLayout</h3><p>可以上下滑动的菜单布局</p><p><a href="https://github.com/umano/AndroidSlidingUpPanel">https://github.com/umano/AndroidSlidingUpPanel</a></p><p><img src= "/img/loading.gif" data-lazy-src="/assets/68747470733a2f2f7261772e6769746875622e636f6d2f756d616e6f2f416e64726f6964536c6964696e67557050616e656c44656d6f2f6d61737465722f736c6964696e67757070616e656c2e706e67.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android UI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Studio 指南</title>
      <link href="/Android/Android%20Studio/"/>
      <url>/Android/Android%20Studio/</url>
      
        <content type="html"><![CDATA[<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><h3 id="Mac-OS-外接键盘映射"><a href="#Mac-OS-外接键盘映射" class="headerlink" title="Mac OS 外接键盘映射"></a>Mac OS 外接键盘映射</h3><table><thead><tr><th align="center">修饰键</th><th align="center">符号</th><th align="center">外接键盘</th></tr></thead><tbody><tr><td align="center"><strong>Command</strong></td><td align="center"><img src= "/img/loading.gif" data-lazy-src="/assets/9808e0a4c5ca7d8f3661af19ca54058e.png" alt="Command 符号"></td><td align="center"><strong>Win</strong></td></tr><tr><td align="center"><strong>Shift</strong></td><td align="center"><img src= "/img/loading.gif" data-lazy-src="/assets/da6e9b7f91e7eb13915e29d5288d8d3f.png" alt="Shift 符号"></td><td align="center"><strong>Shift</strong></td></tr><tr><td align="center"><strong>Option</strong></td><td align="center"><img src= "/img/loading.gif" data-lazy-src="/assets/4fa4885c9111e0de6faeb637be746e2a.png" alt="Option 符号"></td><td align="center"><strong>Alt</strong></td></tr><tr><td align="center"><strong>Control</strong></td><td align="center"><img src= "/img/loading.gif" data-lazy-src="/assets/d4a120294e44333f6ec6c00ef4648ee1.png" alt="Control 符号"></td><td align="center"><strong>Ctrl</strong></td></tr></tbody></table><h3 id="Mac-OS"><a href="#Mac-OS" class="headerlink" title="Mac OS"></a>Mac OS</h3><ul><li>Command + Shift  + F ：在路径中查找</li><li>Option + Shift + 方向键 ：上下移动单行代码</li></ul><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><table><thead><tr><th>常规</th><th align="center">Windows/Linux</th><th align="center">Mac</th></tr></thead><tbody><tr><td>添加到收藏夹</td><td align="center"><strong>Alt+Shift+F</strong></td><td align="center"><strong>Option+Shift+F</strong></td></tr><tr><td>打开设置对话框</td><td align="center"><strong>Ctrl+Alt+S</strong></td><td align="center"><strong>Command+,</strong></td></tr><tr><td>打开项目结构对话框</td><td align="center"><strong>Ctrl+Alt+Shift+S</strong></td><td align="center"><strong>Command+;</strong></td></tr><tr><td>在标签页和工具窗口之间切换</td><td align="center"><strong>Ctrl+Tab</strong></td><td align="center"><strong>Ctrl+Tab</strong></td></tr></tbody></table><h3 id="工具窗口"><a href="#工具窗口" class="headerlink" title="工具窗口"></a>工具窗口</h3><table><thead><tr><th align="left">工具窗口</th><th align="center">Windows 和 Linux</th><th align="center">Mac</th></tr></thead><tbody><tr><td align="left">运行</td><td align="center"><strong>Shift+F10</strong></td><td align="center"><strong>Ctrl+R</strong></td></tr><tr><td align="left">调试</td><td align="center"><strong>Shift+F9</strong></td><td align="center"><strong>Ctrl+D</strong></td></tr><tr><td align="left">项目窗口</td><td align="center"><strong>Alt+1</strong></td><td align="center"><strong>Command+1</strong></td></tr><tr><td align="left">Logcat窗口</td><td align="center"><strong>Alt+6</strong></td><td align="center"><strong>Command+6</strong></td></tr><tr><td align="left">版本控制窗口</td><td align="center"><strong>Alt+9</strong></td><td align="center"><strong>Command+9</strong></td></tr><tr><td align="left">隐藏所有工具窗口</td><td align="center"><strong>Ctrl+Shift+F12</strong></td><td align="center"><strong>Command+Shift+F12</strong></td></tr><tr><td align="left">焦点返回编辑器</td><td align="center"><strong>Esc</strong></td><td align="center"><strong>Esc</strong></td></tr></tbody></table><h3 id="样式和格式"><a href="#样式和格式" class="headerlink" title="样式和格式"></a>样式和格式</h3><table><thead><tr><th align="left">样式和格式</th><th align="center">Windows 和 Linux</th><th align="center">Mac</th></tr></thead><tbody><tr><td align="left">重新格式化代码</td><td align="center"><strong>Ctrl+Alt+L</strong></td><td align="center"><strong>Option+Command+L</strong></td></tr><tr><td align="left"></td><td align="center"></td><td align="center"></td></tr><tr><td align="left"></td><td align="center"></td><td align="center"></td></tr><tr><td align="left"></td><td align="center"></td><td align="center"></td></tr><tr><td align="left"></td><td align="center"></td><td align="center"></td></tr><tr><td align="left"></td><td align="center"></td><td align="center"></td></tr><tr><td align="left"></td><td align="center"></td><td align="center"></td></tr></tbody></table><table><thead><tr><th>导航和搜索</th><th align="center">Windows 和 Linux</th><th align="center">Mac</th></tr></thead><tbody><tr><td>全局搜索内容（包括代码和菜单）</td><td align="center">两次 <strong>Shift</strong></td><td align="center">两次 <strong>Shift</strong></td></tr><tr><td>全局查找类</td><td align="center"><strong>Ctrl+N</strong></td><td align="center"><strong>Command+O</strong></td></tr><tr><td>全局查找文件</td><td align="center"><strong>Ctrl+Shift+N</strong></td><td align="center"><strong>Command+Shift+O</strong></td></tr><tr><td>全局查找方法或变量</td><td align="center"><strong>Ctrl+Shift+Alt+N</strong></td><td align="center"><strong>Command+Option+O</strong></td></tr><tr><td>全局查找字符</td><td align="center"><strong>Ctrl+Shift+F</strong></td><td align="center"><strong>Command+Shift+F</strong></td></tr><tr><td>当前文件查找字符</td><td align="center"><strong>Ctrl+F</strong></td><td align="center"><strong>Command+F</strong></td></tr><tr><td>当前文件查找字符下一项内容</td><td align="center"><strong>F3</strong></td><td align="center"><strong>Command+G</strong></td></tr><tr><td>当前文件查找字符上一项内容</td><td align="center"><strong>Shift+F3</strong></td><td align="center"><strong>Command+Shift+G</strong></td></tr><tr><td>当前文件查找引用当前光标位置处的类、方法、字段、参数或语句的所有代码片段</td><td align="center"><strong>Alt+F7</strong></td><td align="center"><strong>Option+F7</strong></td></tr><tr><td>打开文件结构弹出式菜单</td><td align="center"><strong>Ctrl+F12</strong></td><td align="center"><strong>Command+F12</strong></td></tr><tr><td>跳到源代码（声明处）</td><td align="center"><strong>F4</strong> 或 <strong>Ctrl+Enter</strong></td><td align="center"><strong>F4</strong> 或 <strong>Command+↓</strong></td></tr><tr><td>在新窗口中打开当前编辑器标签页</td><td align="center"><strong>Shift+F4</strong></td><td align="center"><strong>Shift+F4</strong></td></tr><tr><td>关闭活动编辑器标签页</td><td align="center"><strong>Ctrl+F4</strong></td><td align="center"><strong>Command+W</strong></td></tr><tr><td>从工具窗口返回到编辑器窗口</td><td align="center"><strong>Esc</strong></td><td align="center"><strong>Esc</strong></td></tr><tr><td>转到具体行</td><td align="center"><strong>Ctrl+G</strong></td><td align="center"><strong>Command+L</strong></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TBS 文件浏览</title>
      <link href="/Android/TBS/"/>
      <url>/Android/TBS/</url>
      
        <content type="html"><![CDATA[<h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><h3 id="SDK接入"><a href="#SDK接入" class="headerlink" title="SDK接入"></a>SDK接入</h3><p>Gradle 集成：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">implementation <span class="hljs-string">&#x27;com.tencent.tbs.tbssdk:sdk:43939&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="权限配置"><a href="#权限配置" class="headerlink" title="权限配置"></a>权限配置</h3><p>在 AndroidManifest.xml 增加如下权限：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--外存储写权限 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!--外存储读权限 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.READ_EXTERNAL_STORAGE&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!--读取网络信息状态 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.ACCESS_NETWORK_STATE&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!--获取当前wifi状态 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.ACCESS_WIFI_STATE&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!--连接网络权限 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.INTERNET&quot;</span> /&gt;</span><br><span class="hljs-comment">&lt;!--读取手机信息权限 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.permission.READ_PHONE_STATE&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><h3 id="混淆配置"><a href="#混淆配置" class="headerlink" title="混淆配置"></a>混淆配置</h3><p>为保障 X5 功能的正常使用，需要在 proguard.cfg 文件中添加如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plain">-dontwarn dalvik.**<br>-dontwarn com.tencent.smtt.**<br><br>-keep class com.tencent.smtt.** &#123;<br>    *;<br>&#125;<br><br>-keep class com.tencent.tbs.** &#123;<br>    *;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="首次初始化冷启动优化"><a href="#首次初始化冷启动优化" class="headerlink" title="首次初始化冷启动优化"></a>首次初始化冷启动优化</h3><p>TBS 内核首次使用和加载时，ART 虚拟机会将 Dex 文件转为 Oat ，该过程由系统底层触发且耗时较长，很容易引起 anr 问题，解决方法是使用 TBS 的 dex2oat 优化方案“。</p><h4 id="设置开启优化方案"><a href="#设置开启优化方案" class="headerlink" title="设置开启优化方案"></a>设置开启优化方案</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在调用TBS初始化、创建WebView之前进行如下配置 </span><br>HashMap map = <span class="hljs-keyword">new</span> HashMap(); <br>map.put(TbsCoreSettings.TBS_SETTINGS_USE_SPEEDY_CLASSLOADER, <span class="hljs-keyword">true</span>); <br>map.put(TbsCoreSettings.TBS_SETTINGS_USE_DEXLOADER_SERVICE, <span class="hljs-keyword">true</span>); <br>QbSdk.initTbsSettings(map);<br></code></pre></td></tr></table></figure><h4 id="增加Service声明"><a href="#增加Service声明" class="headerlink" title="增加Service声明"></a>增加Service声明</h4><ol><li><p>在AndroidManifest.xml中增加内核首次加载时优化Service声明。 </p></li><li><p>该Service仅在TBS内核首次Dex加载时触发并执行dex2oat任务，任务完成后自动结束。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">service</span> </span><br><span class="hljs-tag"><span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;com.tencent.smtt.export.external.DexClassLoaderProviderService&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:label</span>=<span class="hljs-string">&quot;dexopt&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:process</span>=<span class="hljs-string">&quot;:dexopt&quot;</span> &gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">service</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 基本数据类型初始值</title>
      <link href="/Java/Java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%9D%E5%A7%8B%E5%80%BC/"/>
      <url>/Java/Java%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%9D%E5%A7%8B%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="基本数据类型作为类成员"><a href="#基本数据类型作为类成员" class="headerlink" title="基本数据类型作为类成员"></a>基本数据类型作为类成员</h2><p>变量作为类成员使用时，即使没有进行初始化，java 也会给定默认的初始值，防止程序运行时错误。但是这些初始值对你的程序来说是不正确的。所以必须明确指定初始值。</p><p>默认是如下所示：</p><table><thead><tr><th align="center">数据类型</th><th align="center">大小/位</th><th align="center">封装类</th><th align="center">默认值</th><th align="left">可表示数据范围</th></tr></thead><tbody><tr><td align="center">byte</td><td align="center">8</td><td align="center">Byte</td><td align="center">0</td><td align="left">-128~127</td></tr><tr><td align="center">short</td><td align="center">16</td><td align="center">Short</td><td align="center">0</td><td align="left">-32768~32767</td></tr><tr><td align="center">int</td><td align="center">32</td><td align="center">Integer</td><td align="center">0</td><td align="left">-2147483648~2147483647</td></tr><tr><td align="center">long</td><td align="center">64</td><td align="center">Long</td><td align="center">0</td><td align="left">-9223372036854775808~9223372036854775807</td></tr><tr><td align="center">float</td><td align="center">32</td><td align="center">Float</td><td align="center">0.0f</td><td align="left">1.4E-45~3.4028235E38</td></tr><tr><td align="center">double</td><td align="center">64</td><td align="center">Double</td><td align="center">0.0</td><td align="left">4.9E-324~1.7976931348623157E308</td></tr><tr><td align="center">char</td><td align="center">16</td><td align="center">Character</td><td align="center">\u0000（null）</td><td align="left">0~65535</td></tr><tr><td align="center">boolean</td><td align="center">8</td><td align="center">Boolean</td><td align="center">flase</td><td align="left">true或false</td></tr></tbody></table><h2 id="基本数据类型作局部变量"><a href="#基本数据类型作局部变量" class="headerlink" title="基本数据类型作局部变量"></a>基本数据类型作局部变量</h2><p>局部变量并不会进行默认初始化。因此在某个方法中定义 <code>int i</code> ，那么变量 <code>i</code> 可能得到的是任一值，不会被初始化为 <code>0</code> 。如果忘记赋值，Java 会在编译时返回一个错误，提示此变量没有初始化。在类中定义一个对象的引用时，如果没有给定初始化值，此引用会默认为null值。</p><p>Java 中基本类型的默认值是 0 ，引用类型会默认为 <code>null</code> 。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android踩坑日记</title>
      <link href="/Android/Bug/"/>
      <url>/Android/Bug/</url>
      
        <content type="html"><![CDATA[<h3 id="NestedScrollView嵌套RecyclerView只显示一行"><a href="#NestedScrollView嵌套RecyclerView只显示一行" class="headerlink" title="NestedScrollView嵌套RecyclerView只显示一行"></a>NestedScrollView嵌套RecyclerView只显示一行</h3><p>在实现一个包含WebView富文本和底部附件列表的滚动页面时，采用 <code>NestedScrollView</code> 嵌套 <code>WebView</code> + <code>RecyclerView</code> ， <code>RecyclerView</code> 只显示了一行 item。</p><p>解决：</p><ul><li>设置 <code>RecyclerView</code> 的 <code>layout_height</code> 属性为 <code>wrap_content</code> 。</li><li>设置 <code>RecyclerView</code> 的 item 根布局的 <code>layout_height</code> 属性为 <code>wrap_content</code> 。</li><li><code>RecyclerView</code> 设置属性：<code>android:nestedScrollingEnabled=&quot;false&quot;</code></li></ul><h3 id="NestedScrollView默认不在最上方"><a href="#NestedScrollView默认不在最上方" class="headerlink" title="NestedScrollView默认不在最上方"></a>NestedScrollView默认不在最上方</h3><p><code>NestedScrollView</code> 嵌套 <code>RecyclerView</code> 时，会遇到不显示最顶端内容，需要给 <code>NestedScrollView</code> 的子控件设置属性: <code>android:descendantFocusability=&quot;beforeDescendants&quot;</code></p><h3 id="RecyclerView-下拉刷新上拉加载间隔线变粗"><a href="#RecyclerView-下拉刷新上拉加载间隔线变粗" class="headerlink" title="RecyclerView 下拉刷新上拉加载间隔线变粗"></a>RecyclerView 下拉刷新上拉加载间隔线变粗</h3><p><code>RecyclerView</code>设置了多次<code>addItemDecoration</code></p><p>解决：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (recyclerView.getItemDecorationCount() == <span class="hljs-number">0</span> ) &#123;<br>    recyclerView.addItemDecoration(<span class="hljs-keyword">new</span> PureItemDecoration(context, DividerItemDecoration.VERTICAL, R.drawable.shape_common_divider));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="RecyclerView嵌套RecyclerView自动滚动问题"><a href="#RecyclerView嵌套RecyclerView自动滚动问题" class="headerlink" title="RecyclerView嵌套RecyclerView自动滚动问题"></a>RecyclerView嵌套RecyclerView自动滚动问题</h3><p>在最外层的 recyclerView 布局文件中加上 <code>android:descendantFocusability=&quot;beforeDescendants&quot;</code> 属性。</p><p><code>descendantFocusability</code> 的值有三种：</p><ul><li><code>beforeDescendants </code>：<code>viewgroup</code> 会优先其子类控件而获取到焦点</li><li><code>afterDescendants </code>：<code>viewgroup</code> 只有当其子类控件不需要获取焦点时才获取焦点</li><li><code>blocksDescendants</code>：viewgroup 会覆盖子类控件而直接获得焦点</li></ul><h3 id="使用DataBinding的RecyclerView嵌套时子RecyclerView显示错误"><a href="#使用DataBinding的RecyclerView嵌套时子RecyclerView显示错误" class="headerlink" title="使用DataBinding的RecyclerView嵌套时子RecyclerView显示错误"></a>使用DataBinding的RecyclerView嵌套时子RecyclerView显示错误</h3><p>在父<code>Adapter</code>中重复使用了一个Adapter，只进行了重新设置数据源。</p><p>解决：</p><p>在<code>onBindViewHolder</code>时声明和<code>new</code> 一个新的<code>Adapter</code>，并进行设置数据源。</p><h3 id="设置文本框显示多少个字符"><a href="#设置文本框显示多少个字符" class="headerlink" title="设置文本框显示多少个字符"></a>设置文本框显示多少个字符</h3><p>可以使用 <code>maxEms</code> 和 <code>maxLength</code>设置一行展示多少字，或者展示多宽，最大长度多少。如果加上 <code>android:maxLines=&quot;1&quot;</code> 和 <code>android:ellipsize=&quot;end&quot;</code> 就表示最多显示一行，一行超过将会有省略号来表示</p><h4 id="maxEms"><a href="#maxEms" class="headerlink" title="maxEms"></a>maxEms</h4><p>一个 <code>em</code> 单位是两个 inch ，但是随着自动调整，在 Android 中 <code>em</code> 代表 M 的数量。</p><p>只有在 <code>android:layout_width=“wrap_content”</code> 时，有效</p><p>如果是 <code>android:layout_width=“match_parent”</code> 时，无效</p><h4 id="maxLength"><a href="#maxLength" class="headerlink" title="maxLength"></a>maxLength</h4><p><code>maxLength</code> 限制输入的文本个数，无论输入什么内容，如英文，符号，数字，汉字等都属于文本范围。</p><h4 id="ellipsize"><a href="#ellipsize" class="headerlink" title="ellipsize"></a>ellipsize</h4><p>设置当文字过长时,该控件该如何显示。有如下值设置：<br><code>”start”</code>—–省略号显示在开头；<br><code>”end”</code>——省略号显示在结尾；<br><code>”middle”</code>—-省略号显示在中间；<br><code>”marquee”</code> ——以跑马灯的方式显示(动画横向移动)</p><h3 id="安卓平板TabLayout不能平均分配"><a href="#安卓平板TabLayout不能平均分配" class="headerlink" title="安卓平板TabLayout不能平均分配"></a>安卓平板TabLayout不能平均分配</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">com.google.android.material.tabs.TabLayout</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">app:tabMaxWidth</span>=<span class="hljs-string">&quot;0dp&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">app:tabGravity</span>=<span class="hljs-string">&quot;fill&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">app:tabMode</span>=<span class="hljs-string">&quot;fixed&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><h3 id="打开多个Activity，返回到第一个Activity"><a href="#打开多个Activity，返回到第一个Activity" class="headerlink" title="打开多个Activity，返回到第一个Activity"></a>打开多个Activity，返回到第一个Activity</h3><p>如果 intent 对象包含 <code>FLAG_ACTIVITY_CLEAR_TOP</code> 标记，当目标 task 中已存在与接收该 intent 对象的 activity 类型相同的 activity 实例存在时，所有位于该 activity 对象上面的 activity 将被清空，这样接收该 intent 的 activity 就位于栈顶，可以响应到来的 intent 对象。如果目标 activity 的运行模式为 standard（默认），则目标 activtiy 也会被清空。因为当运行模式为 standard 时，总会创建新的 activity 对象来接收到来的 intent 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Intent intent = <span class="hljs-keyword">new</span> Intent(context, FirstActivity.class);<br>intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);<br>context.startActivity(intent);<br></code></pre></td></tr></table></figure><h3 id="List浅拷贝造成的数据错误"><a href="#List浅拷贝造成的数据错误" class="headerlink" title="List浅拷贝造成的数据错误"></a>List浅拷贝造成的数据错误</h3><p><code>list</code>是引用类型，<code>add</code> 和 <code>addAll</code> 方法都采用的是浅拷贝，即源数据变更后，新数据也随之变更。使用List的深拷贝：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListUtil</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-function">List&lt;E&gt; <span class="hljs-title">deepCopy</span><span class="hljs-params">(List&lt;E&gt; src)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ByteArrayOutputStream byteOut = <span class="hljs-keyword">new</span> ByteArrayOutputStream();<br>            ObjectOutputStream out = <span class="hljs-keyword">new</span> ObjectOutputStream(byteOut);<br>            out.writeObject(src);<br><br>            ByteArrayInputStream byteIn = <span class="hljs-keyword">new</span> ByteArrayInputStream(byteOut.toByteArray());<br>            ObjectInputStream in = <span class="hljs-keyword">new</span> ObjectInputStream(byteIn);<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            List&lt;E&gt; dest = (List&lt;E&gt;) in.readObject();<br>            <span class="hljs-keyword">return</span> dest;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;E&gt;();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>list.addAll(ListUtil.deepCopy(oldList));<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据存储</title>
      <link href="/Android/DataStorage/"/>
      <url>/Android/DataStorage/</url>
      
        <content type="html"><![CDATA[<p>Android 提供多种应用数据保存选项，可以使用文件形式、键值对形式、数据库形式或者其他数据类型保留应用和用户数据，分为内部文件存储、外部文件存储、数据库、共享首选项（SP）。</p><h2 id="数据存储分类"><a href="#数据存储分类" class="headerlink" title="数据存储分类"></a>数据存储分类</h2><p>从数据存储位置分为：</p><ul><li><strong>内部文件存储</strong>：这些目录既包括用于存储持久性文件的专属位置，也包括用于存储缓存数据的其他位置。系统会阻止其他应用访问这些位置，并且在 Android 10（API 级别 29）及更高版本中，系统会对这些位置进行加密。这些特征使得这些位置非常适合存储只有应用本身才能访问的敏感数据</li><li><strong>外部文件存储</strong>：这些目录既包括用于存储持久性文件的专属位置，也包括用于存储缓存数据的其他位置。虽然其他应用可以在具有适当权限的情况下访问这些目录，但存储在这些目录中的文件仅供您的应用使用。如果您明确打算创建其他应用能够访问的文件，您的应用应改为将这些文件存储在外部存储空间的<a href="https://developer.android.google.cn/training/data-storage/shared?hl=zh-cn">共享存储空间</a>部分。</li></ul><p>从功能上可以分为</p><ul><li><strong>应用专属存储空间</strong>：存储仅供应用使用的文件，可以存储到内部存储卷中的专属目录或外部存储空间中的其他专属目录。使用内部存储空间中的目录保存其他应用不应访问的敏感信息。</li><li><strong>共享存储</strong>：存储您的应用打算与其他应用共享的文件，包括媒体、文档和其他文件。</li><li><strong>偏好设置</strong>：以键值对形式存储私有原始数据。</li><li><strong>数据库</strong>：使用 Room 持久性库将结构化数据存储在专用数据库中。</li></ul><table><thead><tr><th align="left"></th><th align="center">内容类型</th><th align="left">访问方法</th><th align="left">所需权限</th><th align="left">其他应用是否可以访问？</th><th>卸载应用时是否移除文件？</th></tr></thead><tbody><tr><td align="left">应用专属文件</td><td align="center">仅供您的应用使用的文件</td><td align="left">从内部存储空间访问，可以使用 <code>getFilesDir()</code> 或 <code>getCacheDir()</code> 方法  从外部存储空间访问，可以使用 <code>getExternalFilesDir()</code> 或 <code>getExternalCacheDir()</code> 方法</td><td align="left">从内部存储空间访问不需要任何权限  如果应用在搭载 Android 4.4（API 级别 19）或更高版本的设备上运行，从外部存储空间访问不需要任何权限</td><td align="left">如果文件存储在内部存储空间中的目录内，则不能访问  如果文件存储在外部存储空间中的目录内，则可以访问</td><td>是</td></tr><tr><td align="left">媒体</td><td align="center">可共享的媒体文件（图片、音频文件、视频）</td><td align="left">MediaStore API</td><td align="left">在 Android 10（API 级别 29）或更高版本中，访问其他应用的文件需要 <code>READ_EXTERNAL_STORAGE</code> 或 <code>WRITE_EXTERNAL_STORAGE</code> 权限  在 Android 9（API 级别 28）或更低版本中，访问<strong>所有</strong>文件均需要相关权限</td><td align="left">是，但其他应用需要 <code>READ_EXTERNAL_STORAGE</code> 权限</td><td>否</td></tr><tr><td align="left">文档和其他文件</td><td align="center">其他类型的可共享内容，包括已下载的文件</td><td align="left">存储访问框架</td><td align="left">无</td><td align="left">是，可以通过系统文件选择器访问</td><td>否</td></tr><tr><td align="left">应用偏好设置</td><td align="center">键值对</td><td align="left">Jetpack Preferences 库</td><td align="left">无</td><td align="left">否</td><td>是</td></tr><tr><td align="left">数据库</td><td align="center">结构化数据</td><td align="left">Room 持久性库</td><td align="left">无</td><td align="left">否</td><td>是</td></tr></tbody></table><h2 id="内部存储"><a href="#内部存储" class="headerlink" title="内部存储"></a>内部存储</h2>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EventBus</title>
      <link href="/Android/EventBus/"/>
      <url>/Android/EventBus/</url>
      
        <content type="html"><![CDATA[<p>EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，事件可以理解为消息。事件传递既可以用于 Android 四大组件间通讯，也可以用于异步线程和主线程间通讯等。EventBus 是一个 Android 端优化的 发布/订阅 消息总线，简化了应用程序内各组件间、组件与后台线程间的通信。</p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">implementation <span class="hljs-string">&#x27;org.greenrobot:eventbus:3.1.1&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>如果传递的为字符串可以直接传递，如果传递的是对象，需要定义一个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageEvent</span> </span>&#123; <br><span class="hljs-comment">/* Additional fields if needed */</span> <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><p>在要接受消息的页面注册，Activity 和 fragment 在生命周期中注册和注销接收器，例如 <code>onCreate</code> 和 <code>onDestroy</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onCreate();<br>    EventBus.getDefault().register(<span class="hljs-keyword">this</span>);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onDestroy();<br>    EventBus.getDefault().unregister(<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="订阅者"><a href="#订阅者" class="headerlink" title="订阅者"></a>订阅者</h2><p>添加注解 <code>@Subscribe</code> （订阅者），在其内传入了 <code>threadMode</code> ，方法名可以自定义。</p><ul><li>ThreadMode.POSTING：默认值。将在发布事件的同一线程中调用订阅者。事件传递同步完成，发布完成后将调用所有订阅者。此 ThreadMode 意味着最少的开销，因为它完全避免了线程切换。因此，对于已知要完成的简单任务，建议使用这种模式的时间非常短，无需主线程。线程是主线程时，使用此模式的事件处理程序应快速返回以避免阻止发布线程。</li><li>ThreadMode.Main：主线程即 UI 线程。如果发布线程是主线程，则将直接调用事件处理程序方法（如 <code>POSTING</code> 所述的同步方法）。使用此模式的事件处理程序必须快速返回以避免阻塞主线程。</li><li>ThreadMode.MAIN_ORDERED：订阅者将在 Android 的主线程中调用。该事件总是排队等待以后交付给订阅者，因此对 <code>post</code> 的调用将立即返回。这为事件处理提供了更严格且更一致的顺序（因此名称为 <code>MAIN_ORDERED</code> ）。例如，如果您在具有 MAIN 线程模式的事件处理程序中发布另一个事件，则第二个事件处理程序将在第一个事件处理程序之前完成（因为它是同步调用的 - 将其与方法调用进行比较）。使用 <code>MAIN_ORDERED</code> ，第一个事件处理程序将完成，然后第二个事件处理程序将在稍后的时间点调用，使用此模式的事件处理程序必须快速返回以避免阻塞主线程。</li><li>ThreadMode.BACKGROUND：订阅者在后台线程中调用。如果发布线程不是主线程，则事件处理方法将直接在发布线程中调用。如果发布线程是主线程，EventBus 将使用一个后台线程，该线程将按顺序传递其所有事件。使用此模式的事件处理程序应尝试快速返回以避免阻止后台线程。</li><li>ThreadMode.ASYNC：事件处理程序方法在单独的线程中调用。这始终独立于过帐线程和主线程。发布事件从不使用此模式等待事件处理程序方法。如果事件处理程序方法的执行可能需要一些时间（例如，对于网络访问），则应使用此模式。避免同时触发大量长时间运行的异步处理程序方法，以限制并发线程的数量。EventBus 使用线程池，从而高效重用已完成的异步事件处理程序的线程。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 传递字符串</span><br><span class="hljs-meta">@Subscribe(threadMode = ThreadMode.MAIN)</span>  <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMessageEvent</span><span class="hljs-params">(String msg)</span> </span>&#123;<br><span class="hljs-comment">/* Do something */</span><br>&#125;;<br><br><span class="hljs-comment">// 传递对象</span><br><span class="hljs-meta">@Subscribe(threadMode = ThreadMode.MAIN)</span>  <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMessageEvent</span><span class="hljs-params">(MessageEvent event)</span> </span>&#123;<br><span class="hljs-comment">/* Do something */</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p>可以在网络请求、IO 操作等异步线程中执行，可以直接传递字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 传递字符串</span><br>String msg;<br>EventBus.getDefault().post(msg);<br><br><span class="hljs-comment">// 传递对象</span><br>EventBus.getDefault().post(<span class="hljs-keyword">new</span> MessageEvent());<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PopupWindow</title>
      <link href="/Android/PopupWindow/"/>
      <url>/Android/PopupWindow/</url>
      
        <content type="html"><![CDATA[<p>PopupWindow 是一个以弹窗方式呈现的控件，可以用来显示任意视图(View)，而且会浮动在当前活动的顶部。可以通过 PopupWindow 实现各种各样的弹窗效果,进行信息的展示或者是 UI 交互，由于 PopupWindow 自定义布局比较方便，而且在显示位置比较自由不受限制，因此受到众多开发者的青睐。</p><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>具体可参考<code>PopupWindow.java</code>源码</p><h3 id="1-PopupWindow与AlertDialog的区别"><a href="#1-PopupWindow与AlertDialog的区别" class="headerlink" title="1. PopupWindow与AlertDialog的区别"></a>1. PopupWindow与AlertDialog的区别</h3><ul><li>AlertDialog 不能指定显示位置，默认显示在屏幕最中间（可以通过设置 WindowManager 参数来改变位置）</li><li>PopupWindow 是可以指定显示位置</li></ul><h3 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="2. 构造方法"></a>2. 构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// empty，size(0,0)，provide background，non focusable</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PopupWindow</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-comment">// empty，size(0,0)，provide background，non focusable</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PopupWindow</span><span class="hljs-params">(Context context)</span></span><br><span class="hljs-function"><span class="hljs-comment">// empty，size(0,0)，not provide any background，non focusable</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PopupWindow</span><span class="hljs-params">(View contentView)</span></span><br><span class="hljs-function"><span class="hljs-comment">// empty，size(width,height)，not provide any background，non focusable</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PopupWindow</span><span class="hljs-params">(View contentView, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height)</span> </span><br><span class="hljs-function"><span class="hljs-comment">// empty，size(width,height)，not provide any background，focusable</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PopupWindow</span><span class="hljs-params">(View contentView, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, <span class="hljs-keyword">boolean</span> focusable)</span></span><br></code></pre></td></tr></table></figure><h3 id="3-显示方法"><a href="#3-显示方法" class="headerlink" title="3. 显示方法"></a>3. 显示方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//相对某个控件的位置（正左下方），无偏移</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showAsDropDown</span><span class="hljs-params">(View anchor)</span></span><br><span class="hljs-function"><span class="hljs-comment">//相对某个控件的位置，有偏移。xoff表示x轴的偏移，正值表示向左，负值表示向右；yoff表示相对y轴的偏移，正值是向下，负值是向上</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showAsDropDown</span><span class="hljs-params">(View anchor, <span class="hljs-keyword">int</span> xoff, <span class="hljs-keyword">int</span> yoff)</span></span><br><span class="hljs-function"><span class="hljs-comment">//gravity相对于父控件的位置（例如正中央Gravity.CENTER）</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showAtLocation</span><span class="hljs-params">(View anchor, <span class="hljs-keyword">int</span> xoff, <span class="hljs-keyword">int</span> yoff, <span class="hljs-keyword">int</span> gravity)</span></span><br></code></pre></td></tr></table></figure><h3 id="4-常用方法"><a href="#4-常用方法" class="headerlink" title="4. 常用方法"></a>4. 常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dismiss</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setContentView</span><span class="hljs-params">(contentView)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setWidth</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHeight</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFocusable</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> focusable)</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTouchable</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> touchable)</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setOutsideTouchable</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> touchable)</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBackgroundDrawable</span><span class="hljs-params">(Drawable background)</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAnimationStyle</span><span class="hljs-params">(R.style.WindowStyle)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setOnDismissListener</span><span class="hljs-params">(onDismissListener)</span></span>;<br></code></pre></td></tr></table></figure><h2 id="二、实例"><a href="#二、实例" class="headerlink" title="二、实例"></a>二、实例</h2><h3 id="1-固定控件布局"><a href="#1-固定控件布局" class="headerlink" title="1. 固定控件布局"></a>1. 固定控件布局</h3><p>布局</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span></span><br><span class="hljs-tag">        <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;fill_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;#ffffff&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:paddingBottom</span>=<span class="hljs-string">&quot;2dp&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">View</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;2.25dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;#fa7829&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_alignParentTop</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/pop_computer&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;@style/pop_text_style&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;计算机&quot;</span>/&gt;</span><br> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">View</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;1dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;@drawable/list_line&quot;</span>/&gt;</span><br> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/pop_financial&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;@style/pop_text_style&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;金融&quot;</span>/&gt;</span><br> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">View</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;1dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;@drawable/list_line&quot;</span>/&gt;</span><br> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/pop_manage&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;@style/pop_text_style&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;管理&quot;</span>/&gt;</span><br> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">View</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;1dp&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> PopupWindow mPopWindow；<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showPopupWindow</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//设置contentView</span><br>    View contentView = LayoutInflater.from(MainActivity.<span class="hljs-keyword">this</span>).inflate(R.layout.popuplayout, <span class="hljs-keyword">null</span>);<br>    mPopWindow = <span class="hljs-keyword">new</span> PopupWindow(contentView, LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT, <span class="hljs-keyword">true</span>);<br>    mPopWindow.setContentView(contentView);<br><span class="hljs-comment">//设置各个控件的点击响应</span><br>    TextView tv1 = (TextView)contentView.findViewById(R.id.pop_computer);<br>    TextView tv2 = (TextView)contentView.findViewById(R.id.pop_financial);<br>    TextView tv3 = (TextView)contentView.findViewById(R.id.pop_manage);<br>    tv1.setOnClickListener(<span class="hljs-keyword">this</span>);<br>    tv2.setOnClickListener(<span class="hljs-keyword">this</span>);<br>    tv3.setOnClickListener(<span class="hljs-keyword">this</span>);<br><span class="hljs-comment">//显示PopupWindow</span><br>    View rootview = LayoutInflater.from(MainActivity.<span class="hljs-keyword">this</span>).inflate(R.layout.main, <span class="hljs-keyword">null</span>);<br>    mPopWindow.showAtLocation(rootview, Gravity.BOTTOM, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-ListView布局"><a href="#2-ListView布局" class="headerlink" title="2. ListView布局"></a>2. ListView布局</h3><p>布局</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:padding</span>=<span class="hljs-string">&quot;2dp&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ListView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/listView&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:divider</span>=<span class="hljs-string">&quot;@null&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> PopupWindow <span class="hljs-title">getPopWindow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> type, Context context, PopupWindow.OnDismissListener onDismissListener, <span class="hljs-keyword">final</span> OnSelectListener onSelectListener)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (picPopWin == <span class="hljs-keyword">null</span>) &#123;<br>        picPopWin = <span class="hljs-keyword">new</span> PopupWindow(context);<br>    &#125;<br>    View contentView = LayoutInflater.from(MainActivity.<span class="hljs-keyword">this</span>).inflate(R.layout.pop, <span class="hljs-keyword">null</span>);<br>    <span class="hljs-comment">// TODO ListView 和 Adapter   </span><br>    ListView.setAdapter(<span class="hljs-keyword">new</span> SimpleAdapter(getContext(), list, R.layout.item_pop, <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;text&quot;</span>&#125;, <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;R.id.tv_title&#125;));<br>    ListView.setOnItemClickListener(<span class="hljs-keyword">new</span> AdapterView.OnItemClickListener() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onItemClick</span><span class="hljs-params">(AdapterView&lt;?&gt; adapterView, View view, <span class="hljs-keyword">int</span> position, <span class="hljs-keyword">long</span> l)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (onSelectListener != <span class="hljs-keyword">null</span>) &#123;<br>               picPopWin.dismiss();<br>               onSelectListener.onSelect(position);<br>            &#125;<br>        &#125;<br>    &#125;);<br>    picPopWin.setContentView(contentView);<br>    <span class="hljs-comment">// 设置固定高度和宽度</span><br>    picPopWin.setWidth(ScreenUtil.dip2px(getContext(), <span class="hljs-number">93</span>));<br>    picPopWin.setHeight(ScreenUtil.dip2px(getContext(), <span class="hljs-number">255</span>));<br>    picPopWin.setFocusable(<span class="hljs-keyword">true</span>);<br>    picPopWin.setOutsideTouchable(<span class="hljs-keyword">true</span>);<br>    picPopWin.setAnimationStyle(R.style.WindowStyle);<br>    picPopWin.setBackgroundDrawable(getResources().getDrawable(R.drawable.shap_pull_menu));<br>    picPopWin.setOnDismissListener(onDismissListener);<br>    <span class="hljs-keyword">return</span> picPopWin;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * popWindows选中侦听接口</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OnSelectListener</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onSelect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span></span>;<br>&#125;<br><br><span class="hljs-comment">// 调用</span><br>getPopWindow(<span class="hljs-keyword">this</span>.getContext(), list, <span class="hljs-keyword">new</span> PopupWindow.OnDismissListener() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDismiss</span><span class="hljs-params">()</span> </span>&#123;   <br>    &#125;<br>&#125;, <span class="hljs-keyword">new</span> OnSelectListener() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSelect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> position)</span> </span>&#123;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin</title>
      <link href="/Android/Kotlin/"/>
      <url>/Android/Kotlin/</url>
      
        <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><p>Kotlin声明变量使用 <code>val</code> 和 <code>var</code> 。</p><ul><li><code>val</code> 用于值从不更改的变量。使用 <code>val</code> 声明的变量无法重新赋值。</li><li><code>var</code> 用于值可以更改的变量。</li><li><code>val</code> 声明一个指向数组的变量时，引用不可变，不能指向另一个数组，但可以修改指向数组的值</li><li><code>val</code> 数组存储在堆内存中，引用不可更改，其引用对象可以更改</li><li><code>val</code> 声明一个本身不可变的变量，可以减少函数副作用</li></ul><p>Kotlin中的数据类型都为对象类，具体如下：</p><table><thead><tr><th align="center">Java基本数据类型</th><th align="center">Kotlin对象数据类型</th><th align="center">数据类型说明</th></tr></thead><tbody><tr><td align="center">int</td><td align="center">Int</td><td align="center">整型</td></tr><tr><td align="center">long</td><td align="center">Long</td><td align="center">长整型</td></tr><tr><td align="center">short</td><td align="center">Short</td><td align="center">短整型</td></tr><tr><td align="center">float</td><td align="center">Float</td><td align="center">单精度浮点型</td></tr><tr><td align="center">double</td><td align="center">Double</td><td align="center">双精度浮点型</td></tr><tr><td align="center">boolean</td><td align="center">Boolean</td><td align="center">布尔型</td></tr><tr><td align="center">char</td><td align="center">Char</td><td align="center">字符型</td></tr><tr><td align="center">byte</td><td align="center">Byte</td><td align="center">字节型</td></tr></tbody></table><h3 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h3><p>赋予变量初始值后 Kotlin 编译器可根据所赋值的类型来推断其类型。也可以指定变量类型</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> languageName = <span class="hljs-string">&quot;Kotlin&quot;</span><br><span class="hljs-keyword">val</span> hello : String = <span class="hljs-string">&quot;Kotlin&quot;</span><br></code></pre></td></tr></table></figure><h3 id="Null-安全"><a href="#Null-安全" class="headerlink" title="Null 安全"></a>Null 安全</h3><p>在某些语言中，可以声明引用类型变量而不明确提供初始值。在这类情况下，变量通常包含 <code>null</code> 值。默认情况下，Kotlin 变量不能持有 <code>null</code> 值。这意味着以下代码段无效：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// Fails to compile</span><br><span class="hljs-keyword">val</span> languageName: String = <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p>要使变量持有 <code>null</code> 值，它必须是可为 <code>null</code> 类型。可以在变量类型后面加上 <code>?</code> 后缀，将变量指定为可为 <code>null </code>，如以下示例所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> languageName: String? = <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><p>指定 <code>String?</code> 类型后，可以为 <code>languageName</code> 赋予 <code>String</code> 值或 <code>null</code>。</p><p>使用 <code>!!</code>断言自己使用的值不为空，如以下示例所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> languageName: String? = <span class="hljs-literal">null</span><br>languageName!!<br></code></pre></td></tr></table></figure><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>不可变集合初始化（不可增删改）：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> list = listOf(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span>)<br><span class="hljs-keyword">val</span> <span class="hljs-keyword">set</span> = setOf(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span>)<br></code></pre></td></tr></table></figure><p>可变集合初始化：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> list = mutableListOf(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span>)<br>list.add(<span class="hljs-string">&quot;Pear&quot;</span>)<br></code></pre></td></tr></table></figure><p>集合遍历：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">for</span> (fruit <span class="hljs-keyword">in</span> list) &#123;<br>    println(fruit)<br>&#125;<br></code></pre></td></tr></table></figure><p>Map集合初始化：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 写法1</span><br><span class="hljs-keyword">val</span> map = HashMap&lt;String, <span class="hljs-built_in">Int</span>&gt;()<br>map[<span class="hljs-string">&quot;apple&quot;</span>] = <span class="hljs-number">1</span><br>map[<span class="hljs-string">&quot;banana&quot;</span>] = <span class="hljs-number">2</span><br>map[<span class="hljs-string">&quot;orange&quot;</span>] = <span class="hljs-number">3</span><br><br><span class="hljs-comment">// 写法2</span><br><span class="hljs-keyword">val</span> map = mapOf(<span class="hljs-string">&quot;apple&quot;</span> to <span class="hljs-number">1</span>, <span class="hljs-string">&quot;banana&quot;</span> to <span class="hljs-number">2</span>, <span class="hljs-string">&quot;orange&quot;</span> to <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>Map集合遍历：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">for</span> ((fruit, number) <span class="hljs-keyword">in</span> map) &#123;<br>    println(<span class="hljs-string">&quot;fruit is &quot;</span> + fruit + <span class="hljs-string">&quot;, number is &quot;</span> + number)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="集合的函数式API"><a href="#集合的函数式API" class="headerlink" title="集合的函数式API"></a>集合的函数式API</h4><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><h3 id="if-else-语句"><a href="#if-else-语句" class="headerlink" title="if-else 语句"></a>if-else 语句</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">if</span> (count == <span class="hljs-number">42</span>) &#123;<br>    println(<span class="hljs-string">&quot;I have the answer.&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">35</span>) &#123;<br>    println(<span class="hljs-string">&quot;The answer is close.&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    println(<span class="hljs-string">&quot;The answer eludes me.&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>编写这些语句时会出现重复， Kotlin 提供了条件表达式，每个条件分支都隐式地返回其最后一行的表达式的结果，因此无需使用 <code>return</code> 关键字。利用类型推断可以省略 <code>answerString</code> 的显式类型声明，但为了清楚起见，通常最好添加该声明。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> answerString: String = <span class="hljs-keyword">if</span> (count == <span class="hljs-number">42</span>) &#123;<br>    <span class="hljs-string">&quot;I have the answer.&quot;</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">35</span>) &#123;<br>    <span class="hljs-string">&quot;The answer is close.&quot;</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-string">&quot;The answer eludes me.&quot;</span><br>&#125;<br><br>println(answerString)<br></code></pre></td></tr></table></figure><h3 id="when-语句"><a href="#when-语句" class="headerlink" title="when 语句"></a>when 语句</h3><p>条件语句的复杂性不断增加，您可以考虑将 if-else 表达式替换为 when 表达式，如以下示例所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> answerString = <span class="hljs-keyword">when</span> &#123;<br>    count == <span class="hljs-number">42</span> -&gt; <span class="hljs-string">&quot;I have the answer.&quot;</span><br>    count &gt; <span class="hljs-number">35</span> -&gt; <span class="hljs-string">&quot;The answer is close.&quot;</span><br>    <span class="hljs-keyword">else</span> -&gt; <span class="hljs-string">&quot;The answer eludes me.&quot;</span><br>&#125;<br><br>println(answerString)<br></code></pre></td></tr></table></figure><p><code>when</code> 表达式中每个分支都由一个条件、一个箭头 (<code>-&gt;</code>) 和一个结果来表示。如果箭头左侧的条件求值为 true，则会返回右侧的表达式结果。请注意，执行并不是从一个分支跳转到下一个分支。<code>when</code> 表达式示例中的代码在功能上与上一个示例中的代码等效。</p><p><code>when</code> 表达式可以传入参数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">describe</span><span class="hljs-params">(obj: <span class="hljs-type">Any</span>)</span></span>: String =<br>    <span class="hljs-keyword">when</span> (obj) &#123;<br>        <span class="hljs-number">1</span>          -&gt; <span class="hljs-string">&quot;One&quot;</span><br>        <span class="hljs-string">&quot;Hello&quot;</span>    -&gt; <span class="hljs-string">&quot;Greeting&quot;</span><br>        <span class="hljs-keyword">is</span> <span class="hljs-built_in">Long</span>    -&gt; <span class="hljs-string">&quot;Long&quot;</span><br>        !<span class="hljs-keyword">is</span> String -&gt; <span class="hljs-string">&quot;Not a string&quot;</span><br>        <span class="hljs-keyword">else</span>       -&gt; <span class="hljs-string">&quot;Unknown&quot;</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>Kotlin 的条件语句彰显了它的一项更强大的功能，即智能类型转换。您不必使用安全调用运算符或非 null 断言运算符来处理可为 null 的值，而可以使用条件语句来检查变量是否包含对 null 值的引用，如以下示例所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> languageName: String? = <span class="hljs-literal">null</span><br><span class="hljs-keyword">if</span> (languageName != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// No need to write languageName?.toUpperCase()</span><br>    println(languageName.toUpperCase())<br>&#125;<br></code></pre></td></tr></table></figure><p>在条件分支中，<code>languageName</code> 可能会被视为不可为 null。Kotlin 非常智能，能够识别执行分支的条件是 <code>languageName</code> 不持有 null 值，因此您不必在该分支中将 <code>languageName</code> 视为可为 null。这种智能类型转换适用于 null 检查、<a href="https://kotlinlang.org/docs/reference/typecasts.html#is-and-is-operators">类型检查</a>，或符合<a href="https://kotlinlang.org/docs/reference/whatsnew13.html#contracts">合约</a>的任何条件。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>要声明函数，请使用 <code>fun</code> 关键字，后跟函数名称。接下来，定义函数接受的输入类型（如果有），并声明它返回的输出类型。函数的主体用于定义在调用函数时调用的表达式。函数语法规则：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">methodName</span><span class="hljs-params">(param1: <span class="hljs-type">Int</span>, param2: <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="简化函数声明"><a href="#简化函数声明" class="headerlink" title="简化函数声明"></a>简化函数声明</h3><p>函数返回单个表达式的结果时，可以通过直接返回函数中包含的 if-else 表达式的结果来跳过声明局部变量，如以下示例所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">generateAnswerString</span><span class="hljs-params">(countThreshold: <span class="hljs-type">Int</span>)</span></span>: String &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> (count &gt; countThreshold) &#123;<br>        <span class="hljs-string">&quot;I have the answer.&quot;</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-string">&quot;The answer eludes me.&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>还可以将 return 关键字替换为赋值运算符：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">generateAnswerString</span><span class="hljs-params">(countThreshold: <span class="hljs-type">Int</span>)</span></span>: String = <span class="hljs-keyword">if</span> (count &gt; countThreshold) &#123;<br>        <span class="hljs-string">&quot;I have the answer&quot;</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-string">&quot;The answer eludes me&quot;</span><br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>并非每个函数都需要一个名称。某些函数通过输入和输出更直接地进行标识。这些函数称为“匿名函数”。</p><ul><li><code>-&gt;</code> 符号组织参数类型和返回值类型，左边是参数类型，右边是返回值类型</li><li>必须用一个括号包裹参数类型</li><li>返回值类型必须显式声明</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">(<span class="hljs-built_in">Int</span>, String) -&gt; <span class="hljs-built_in">Unit</span><br></code></pre></td></tr></table></figure><p>Kotlin 也支持为声明参数指定名字，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">(errCode: <span class="hljs-built_in">Int</span>, errMsg: String) -&gt; <span class="hljs-built_in">Unit</span><br></code></pre></td></tr></table></figure><p>如果该匿名函数类型的变量是可选的，可以使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">((errCode: <span class="hljs-built_in">Int</span>, errMsg: String) -&gt; <span class="hljs-built_in">Unit</span>)?<br></code></pre></td></tr></table></figure><p>您可以保留对某个匿名函数的引用，以便日后使用此引用来调用该匿名函数。与其他引用类型一样，您也可以在应用中传递引用。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> stringLengthFunc: (String) -&gt; <span class="hljs-built_in">Int</span> = &#123; input -&gt;<br>    input.length<br>&#125;<br></code></pre></td></tr></table></figure><p>与命名函数一样，匿名函数也可以包含任意数量的表达式。 函数的返回值是最终表达式的结果。</p><p>在上面的示例中，<code>stringLengthFunc</code> 包含对一个匿名函数的引用，该函数将 <code>String</code> 当作输入，并将输入 <code>String</code> 的长度作为 <code>Int</code> 类型的输出返回。因此，该函数的类型表示为 <code>(String) -&gt; Int</code>。不过，此代码不会调用该函数。要检索该函数的结果，您必须像调用命名函数一样调用该函数。调用 <code>stringLengthFunc</code> 时，必须提供 <code>String</code>，如以下示例所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> stringLengthFunc: (String) -&gt; <span class="hljs-built_in">Int</span> = &#123; input -&gt;<br>    input.length<br>&#125;<br><br><span class="hljs-keyword">val</span> stringLength: <span class="hljs-built_in">Int</span> = stringLengthFunc(<span class="hljs-string">&quot;Android&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>一个函数可以将另一个函数当作参数。将其他函数用作参数的函数称为“高阶函数”。此模式对组件之间的通信（其方式与在 Java 中使用回调接口相同）很有用。</p><p>下面是一个高阶函数的示例：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">stringMapper</span><span class="hljs-params">(str: <span class="hljs-type">String</span>, mapper: (<span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Int</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>    <span class="hljs-comment">// Invoke function</span><br>    <span class="hljs-keyword">return</span> mapper(str)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>stringMapper()</code> 函数接受一个 <code>String</code> 以及一个函数，该函数根据您传递给它的 <code>String</code> 来推导 <code>Int</code> 值。</p><p>要调用 <code>stringMapper()</code>，可以传递一个 <code>String</code> 和一个满足其他输入参数的函数（即，一个将 <code>String</code> 当作输入并输出 <code>Int</code> 的函数），如以下示例所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">stringMapper(<span class="hljs-string">&quot;Android&quot;</span>, &#123; input -&gt;<br>    input.length<br>&#125;)<br></code></pre></td></tr></table></figure><p>如果匿名函数是在某个函数上定义的最后一个参数，则您可以在用于调用该函数的圆括号之外传递它，如以下示例所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">stringMapper(<span class="hljs-string">&quot;Android&quot;</span>) &#123; input -&gt;<br>    input.length<br>&#125;<br></code></pre></td></tr></table></figure><p>高阶函数支持返回一个匿名函数：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">(<span class="hljs-built_in">Int</span>) -&gt; ((<span class="hljs-built_in">Int</span>) -&gt; <span class="hljs-built_in">Unit</span>)<br></code></pre></td></tr></table></figure><p>支持传入匿名函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">((Int) -&gt; Int) -&gt; Unit<br></code></pre></td></tr></table></figure><p>在整个 Kotlin 标准库中可以找到很多匿名函数。如需了解详情，请参阅<a href="https://kotlinlang.org/docs/reference/lambdas.html">高阶函数和 Lambda</a>。</p><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><ul><li>Lambda 表达式必须通过 {} 包裹。</li><li>如果 Lambda 声明了参数部分的类型，且返回值类型支持类型推导，则 Lambda 变量可以省略函数类型声明。</li><li>如果 Lambda 变量声明了函数类型，那么 Lambda 的参数部分的类型可以忽略。</li><li>如果 Lambda 表达式返回的不是 Unit ，那么默认最后一行的表达式的值类型就是返回值类型。</li></ul><h3 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h3><ul><li>单参数隐式名称：Lambda 只有一个参数时，可以用 <code>it</code> 代表</li></ul><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>使用 <code>class</code> 关键字来定义类，如以下示例所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span></span><br></code></pre></td></tr></table></figure><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>类使用属性来表示状态。<a href="https://kotlinlang.org/docs/reference/properties.html">属性</a>是类级变量，可以包含 getter、setter 和后备字段。如以下示例所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> </span>&#123;<br>    <span class="hljs-keyword">val</span> wheels = listOf&lt;Wheel&gt;()<br>&#125;<br></code></pre></td></tr></table></figure><p>请注意，<code>wheels</code> 是一个 <code>public val</code>，这意味着，可以从 <code>Car</code> 类外部访问 <code>wheels</code>，并且不能为其重新赋值。如果要获取 <code>Car</code> 的实例，必须先调用其构造函数。之后可以访问它的任何可访问属性。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> car = Car() <span class="hljs-comment">// construct a Car</span><br><span class="hljs-keyword">val</span> wheels = car.wheels <span class="hljs-comment">// retrieve the wheels value from the Car</span><br></code></pre></td></tr></table></figure><p>如果希望自定义轮子，可以定义一个自定义构造函数，用来指定如何初始化类属性：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span></span>(<span class="hljs-keyword">val</span> wheels: List&lt;Wheel&gt;)<br></code></pre></td></tr></table></figure><h3 id="类函数和封装"><a href="#类函数和封装" class="headerlink" title="类函数和封装"></a>类函数和封装</h3><p>类使用函数对行为建模。函数可以修改状态，从而帮助您只公开希望公开的数据。这种访问控制机制属于一个面向对象的更大概念，称为“封装”。</p><p>在以下示例中，<code>doorLock</code> 属性对 <code>Car</code> 类外部的一切都不公开。要解锁汽车，必须调用 <code>unlockDoor()</code> 函数并传入有效的“钥匙”，如以下示例所示：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span></span>(<span class="hljs-keyword">val</span> wheels: List&lt;Wheel&gt;) &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> doorLock: DoorLock = ...<br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">unlockDoor</span><span class="hljs-params">(key: <span class="hljs-type">Key</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-comment">// Return true if key is valid for door lock, false otherwise</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果希望自定义属性的引用方式，则可以提供自定义的 getter 和 setter。例如，如果希望公开属性的 getter 而限制访问其 setter，则可以将该 setter 指定为 <code>private</code>：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span></span>(<span class="hljs-keyword">val</span> wheels: List&lt;Wheel&gt;) &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> doorLock: DoorLock = ...<br><br>    <span class="hljs-keyword">var</span> gallonsOfFuelInTank: <span class="hljs-built_in">Int</span> = <span class="hljs-number">15</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">set</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">unlockDoor</span><span class="hljs-params">(key: <span class="hljs-type">Key</span>)</span></span>: <span class="hljs-built_in">Boolean</span> &#123;<br>        <span class="hljs-comment">// Return true if key is valid for door lock, false otherwise</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过结合使用属性和函数，可以创建能够对所有类型的对象建模的类。</p><h2 id="互操作性"><a href="#互操作性" class="headerlink" title="互操作性"></a>互操作性</h2><p>Kotlin 最重要的功能之一就是它与 Java 之间流畅的互操作性。由于 Kotlin 代码可编译为 JVM 字节码，因此 Kotlin 代码可直接调用 Java 代码，反之亦然。这意味着，您可以直接从 Kotlin 利用现有的 Java 库。此外，绝大多数 Android API 都是用 Java 编写的，因此可以直接从 Kotlin 调用它们。</p><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="常用用法"><a href="#常用用法" class="headerlink" title="常用用法"></a>常用用法</h2><h3 id="创建数据类"><a href="#创建数据类" class="headerlink" title="创建数据类"></a>创建数据类</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">data</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Customer</span></span>(<span class="hljs-keyword">val</span> name: String, <span class="hljs-keyword">val</span> email: String)<br></code></pre></td></tr></table></figure><p>会为 <code>Customer</code> 类提供以下功能：</p><ul><li>所有属性的 <code>getter</code> （对于 <code>var</code> 定义的还有 <code>setter</code>）</li><li><code>equals()</code></li><li><code>hashCode()</code></li><li><code>toString()</code></li><li><code>copy()</code></li><li>所有属性的 <code>component1()</code>、 <code>component2()</code>……等等（参见<a href="https://www.kotlincn.net/docs/reference/data-classes.html">数据类</a>）</li></ul><h3 id="函数的默认参数"><a href="#函数的默认参数" class="headerlink" title="函数的默认参数"></a>函数的默认参数</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">(a: <span class="hljs-type">Int</span> = <span class="hljs-number">0</span>, b: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;&quot;</span>)</span></span> &#123; …… &#125;<br></code></pre></td></tr></table></figure><h3 id="过滤-list"><a href="#过滤-list" class="headerlink" title="过滤 list"></a>过滤 list</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> positives = list.filter &#123; x -&gt; x &gt; <span class="hljs-number">0</span> &#125;<br></code></pre></td></tr></table></figure><p>或者可以更短:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> positives = list.filter &#123; it &gt; <span class="hljs-number">0</span> &#125;<br></code></pre></td></tr></table></figure><h3 id="检测元素是否存在于集合中"><a href="#检测元素是否存在于集合中" class="headerlink" title="检测元素是否存在于集合中"></a>检测元素是否存在于集合中</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;john@example.com&quot;</span> <span class="hljs-keyword">in</span> emailsList) &#123; …… &#125;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;jane@example.com&quot;</span> !<span class="hljs-keyword">in</span> emailsList) &#123; …… &#125;<br></code></pre></td></tr></table></figure><h3 id="字符串内插"><a href="#字符串内插" class="headerlink" title="字符串内插"></a>字符串内插</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">println(<span class="hljs-string">&quot;Name <span class="hljs-variable">$name</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">when</span> (x) &#123;<br>    <span class="hljs-keyword">is</span> Foo <span class="hljs-comment">//-&gt; ……</span><br>    <span class="hljs-keyword">is</span> Bar <span class="hljs-comment">//-&gt; ……</span><br>    <span class="hljs-keyword">else</span>   <span class="hljs-comment">//-&gt; ……</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="遍历-map-pair型list"><a href="#遍历-map-pair型list" class="headerlink" title="遍历 map/pair型list"></a>遍历 map/pair型list</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">for</span> ((k, v) <span class="hljs-keyword">in</span> map) &#123;<br>    println(<span class="hljs-string">&quot;<span class="hljs-variable">$k</span> -&gt; <span class="hljs-variable">$v</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>k</code>、<code>v</code> 可以改成任意名字。</p><h3 id="使用区间"><a href="#使用区间" class="headerlink" title="使用区间"></a>使用区间</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">100</span>) &#123; …… &#125;  <span class="hljs-comment">// 闭区间：包含 100</span><br><span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span> until <span class="hljs-number">100</span>) &#123; …… &#125; <span class="hljs-comment">// 半开区间：不包含 100</span><br><span class="hljs-keyword">for</span> (x <span class="hljs-keyword">in</span> <span class="hljs-number">2</span>..<span class="hljs-number">10</span> step <span class="hljs-number">2</span>) &#123; …… &#125;<br><span class="hljs-keyword">for</span> (x <span class="hljs-keyword">in</span> <span class="hljs-number">10</span> downTo <span class="hljs-number">1</span>) &#123; …… &#125;<br><span class="hljs-keyword">if</span> (x <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">10</span>) &#123; …… &#125;<br></code></pre></td></tr></table></figure><h3 id="只读-list"><a href="#只读-list" class="headerlink" title="只读 list"></a>只读 list</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> list = listOf(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="只读-map"><a href="#只读-map" class="headerlink" title="只读 map"></a>只读 map</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> map = mapOf(<span class="hljs-string">&quot;a&quot;</span> to <span class="hljs-number">1</span>, <span class="hljs-string">&quot;b&quot;</span> to <span class="hljs-number">2</span>, <span class="hljs-string">&quot;c&quot;</span> to <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><h3 id="访问-map"><a href="#访问-map" class="headerlink" title="访问 map"></a>访问 map</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">println(map[<span class="hljs-string">&quot;key&quot;</span>])<br>map[<span class="hljs-string">&quot;key&quot;</span>] = value<br></code></pre></td></tr></table></figure><h3 id="延迟属性"><a href="#延迟属性" class="headerlink" title="延迟属性"></a>延迟属性</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> p: String <span class="hljs-keyword">by</span> lazy &#123;<br>    <span class="hljs-comment">// 计算该字符串</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="扩展函数"><a href="#扩展函数" class="headerlink" title="扩展函数"></a>扩展函数</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">spaceToCamelCase</span><span class="hljs-params">()</span></span> &#123; …… &#125;<br><br><span class="hljs-string">&quot;Convert this to camelcase&quot;</span>.spaceToCamelCase()<br></code></pre></td></tr></table></figure><h3 id="创建单例"><a href="#创建单例" class="headerlink" title="创建单例"></a>创建单例</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">object</span> Resource &#123;<br>    <span class="hljs-keyword">val</span> name = <span class="hljs-string">&quot;Name&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="If-not-null-缩写"><a href="#If-not-null-缩写" class="headerlink" title="If not null 缩写"></a>If not null 缩写</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> files = File(<span class="hljs-string">&quot;Test&quot;</span>).listFiles()<br><br>println(files?.size)<br></code></pre></td></tr></table></figure><h3 id="If-not-null-and-else-缩写"><a href="#If-not-null-and-else-缩写" class="headerlink" title="If not null and else 缩写"></a>If not null and else 缩写</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> files = File(<span class="hljs-string">&quot;Test&quot;</span>).listFiles()<br><br>println(files?.size ?: <span class="hljs-string">&quot;empty&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="if-null-执行一个语句"><a href="#if-null-执行一个语句" class="headerlink" title="if null 执行一个语句"></a>if null 执行一个语句</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> values = ……<br><span class="hljs-keyword">val</span> email = values[<span class="hljs-string">&quot;email&quot;</span>] ?: <span class="hljs-keyword">throw</span> IllegalStateException(<span class="hljs-string">&quot;Email is missing!&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="在可能会空的集合中取第一元素"><a href="#在可能会空的集合中取第一元素" class="headerlink" title="在可能会空的集合中取第一元素"></a>在可能会空的集合中取第一元素</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> emails = …… <span class="hljs-comment">// 可能会是空集合</span><br><span class="hljs-keyword">val</span> mainEmail = emails.firstOrNull() ?: <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><h3 id="if-not-null-执行代码"><a href="#if-not-null-执行代码" class="headerlink" title="if not null 执行代码"></a>if not null 执行代码</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> value = ……<br><br>value?.let &#123;<br>    …… <span class="hljs-comment">// 代码会执行到此处, 假如data不为null</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="映射可空值（如果非空的话）"><a href="#映射可空值（如果非空的话）" class="headerlink" title="映射可空值（如果非空的话）"></a>映射可空值（如果非空的话）</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> value = ……<br><br><span class="hljs-keyword">val</span> mapped = value?.let &#123; transformValue(it) &#125; ?: defaultValue <br><span class="hljs-comment">// 如果该值或其转换结果为空，那么返回 defaultValue。</span><br></code></pre></td></tr></table></figure><h3 id="返回-when-表达式"><a href="#返回-when-表达式" class="headerlink" title="返回 when 表达式"></a>返回 when 表达式</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">transform</span><span class="hljs-params">(color: <span class="hljs-type">String</span>)</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">when</span> (color) &#123;<br>        <span class="hljs-string">&quot;Red&quot;</span> -&gt; <span class="hljs-number">0</span><br>        <span class="hljs-string">&quot;Green&quot;</span> -&gt; <span class="hljs-number">1</span><br>        <span class="hljs-string">&quot;Blue&quot;</span> -&gt; <span class="hljs-number">2</span><br>        <span class="hljs-keyword">else</span> -&gt; <span class="hljs-keyword">throw</span> IllegalArgumentException(<span class="hljs-string">&quot;Invalid color param value&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="“try-catch”表达式"><a href="#“try-catch”表达式" class="headerlink" title="“try/catch”表达式"></a>“try/catch”表达式</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> result = <span class="hljs-keyword">try</span> &#123;<br>        count()<br>    &#125; <span class="hljs-keyword">catch</span> (e: ArithmeticException) &#123;<br>        <span class="hljs-keyword">throw</span> IllegalStateException(e)<br>    &#125;<br><br>    <span class="hljs-comment">// 使用 result</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="“if”表达式"><a href="#“if”表达式" class="headerlink" title="“if”表达式"></a>“if”表达式</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">foo</span><span class="hljs-params">(param: <span class="hljs-type">Int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">val</span> result = <span class="hljs-keyword">if</span> (param == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-string">&quot;one&quot;</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (param == <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-string">&quot;two&quot;</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-string">&quot;three&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="返回类型为-Unit-的方法的-Builder-风格用法"><a href="#返回类型为-Unit-的方法的-Builder-风格用法" class="headerlink" title="返回类型为 Unit 的方法的 Builder 风格用法"></a>返回类型为 <code>Unit</code> 的方法的 Builder 风格用法</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">arrayOfMinusOnes</span><span class="hljs-params">(size: <span class="hljs-type">Int</span>)</span></span>: IntArray &#123;<br>    <span class="hljs-keyword">return</span> IntArray(size).apply &#123; fill(-<span class="hljs-number">1</span>) &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单表达式函数"><a href="#单表达式函数" class="headerlink" title="单表达式函数"></a>单表达式函数</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">theAnswer</span><span class="hljs-params">()</span></span> = <span class="hljs-number">42</span><br></code></pre></td></tr></table></figure><p>等价于</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">theAnswer</span><span class="hljs-params">()</span></span>: <span class="hljs-built_in">Int</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span><br>&#125;<br></code></pre></td></tr></table></figure><p>单表达式函数与其它惯用法一起使用能简化代码，例如和 <em>when</em> 表达式一起使用：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">transform</span><span class="hljs-params">(color: <span class="hljs-type">String</span>)</span></span>: <span class="hljs-built_in">Int</span> = <span class="hljs-keyword">when</span> (color) &#123;<br>    <span class="hljs-string">&quot;Red&quot;</span> -&gt; <span class="hljs-number">0</span><br>    <span class="hljs-string">&quot;Green&quot;</span> -&gt; <span class="hljs-number">1</span><br>    <span class="hljs-string">&quot;Blue&quot;</span> -&gt; <span class="hljs-number">2</span><br>    <span class="hljs-keyword">else</span> -&gt; <span class="hljs-keyword">throw</span> IllegalArgumentException(<span class="hljs-string">&quot;Invalid color param value&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="对一个对象实例调用多个方法-（with）"><a href="#对一个对象实例调用多个方法-（with）" class="headerlink" title="对一个对象实例调用多个方法 （with）"></a>对一个对象实例调用多个方法 （<code>with</code>）</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Turtle</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">penDown</span><span class="hljs-params">()</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">penUp</span><span class="hljs-params">()</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">turn</span><span class="hljs-params">(degrees: <span class="hljs-type">Double</span>)</span></span><br>    <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">forward</span><span class="hljs-params">(pixels: <span class="hljs-type">Double</span>)</span></span><br>&#125;<br><br><span class="hljs-keyword">val</span> myTurtle = Turtle()<br>with(myTurtle) &#123; <span class="hljs-comment">// 画一个 100 像素的正方形</span><br>    penDown()<br>    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">4</span>) &#123;<br>        forward(<span class="hljs-number">100.0</span>)<br>        turn(<span class="hljs-number">90.0</span>)<br>    &#125;<br>    penUp()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="配置对象的属性（apply）"><a href="#配置对象的属性（apply）" class="headerlink" title="配置对象的属性（apply）"></a>配置对象的属性（<code>apply</code>）</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> myRectangle = Rectangle().apply &#123;<br>    length = <span class="hljs-number">4</span><br>    breadth = <span class="hljs-number">5</span><br>    color = <span class="hljs-number">0xFAFAFA</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这对于配置未出现在对象构造函数中的属性非常有用。</p><h3 id="Java-7-的-try-with-resources"><a href="#Java-7-的-try-with-resources" class="headerlink" title="Java 7 的 try with resources"></a>Java 7 的 try with resources</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> stream = Files.newInputStream(Paths.<span class="hljs-keyword">get</span>(<span class="hljs-string">&quot;/some/file.txt&quot;</span>))<br>stream.buffered().reader().use &#123; reader -&gt;<br>    println(reader.readText())<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="对于需要泛型信息的泛型函数的适宜形式"><a href="#对于需要泛型信息的泛型函数的适宜形式" class="headerlink" title="对于需要泛型信息的泛型函数的适宜形式"></a>对于需要泛型信息的泛型函数的适宜形式</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//  public final class Gson &#123;</span><br><span class="hljs-comment">//     ……</span><br><span class="hljs-comment">//     public &lt;T&gt; T fromJson(JsonElement json, Class&lt;T&gt; classOfT) throws JsonSyntaxException &#123;</span><br><span class="hljs-comment">//     ……</span><br><br><span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T: Any&gt;</span> Gson.<span class="hljs-title">fromJson</span><span class="hljs-params">(json: <span class="hljs-type">JsonElement</span>)</span></span>: T = <span class="hljs-keyword">this</span>.fromJson(json, T::<span class="hljs-keyword">class</span>.java)<br></code></pre></td></tr></table></figure><h3 id="使用可空布尔"><a href="#使用可空布尔" class="headerlink" title="使用可空布尔"></a>使用可空布尔</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> b: <span class="hljs-built_in">Boolean</span>? = ……<br><span class="hljs-keyword">if</span> (b == <span class="hljs-literal">true</span>) &#123;<br>    ……<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// `b` 是 false 或者 null</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="交换两个变量"><a href="#交换两个变量" class="headerlink" title="交换两个变量"></a>交换两个变量</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span><br>a = b.also &#123; b = a &#125;<br></code></pre></td></tr></table></figure><h3 id="TODO-：将代码标记为不完整"><a href="#TODO-：将代码标记为不完整" class="headerlink" title="TODO()：将代码标记为不完整"></a>TODO()：将代码标记为不完整</h3><p>Kotlin 的标准库有一个 <code>TODO()</code> 函数，该函数总是抛出一个 <code>NotImplementedError</code>。 其返回类型为 <code>Nothing</code>，因此无论预期类型是什么都可以使用它。 还有一个接受原因参数的重载：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">calcTaxes</span><span class="hljs-params">()</span></span>: BigDecimal = TODO(<span class="hljs-string">&quot;Waiting for feedback from accounting&quot;</span>)<br></code></pre></td></tr></table></figure><p>IntelliJ IDEA 的 kotlin 插件理解 <code>TODO()</code> 的语言，并且会自动在 TODO 工具窗口中添加代码指示。</p><h2 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h2><h3 id="源文件名称"><a href="#源文件名称" class="headerlink" title="源文件名称"></a>源文件名称</h3><p>如果 Kotlin 文件包含单个类（以及可能相关的顶层声明），那么文件名应该与该类的名称相同，并追加 .kt 扩展名。如果文件包含多个类或只包含顶层声明， 那么选择一个描述该文件所包含内容的名称，并以此命名该文件。 使用首字母大写的<a href="https://zh.wikipedia.org/wiki/%E9%A7%9D%E5%B3%B0%E5%BC%8F%E5%A4%A7%E5%B0%8F%E5%AF%AB">驼峰风格</a>（例如 <code>ProcessDeclarations.kt</code>）。</p><p>文件的名称应该描述文件中代码的作用。因此，应避免在文件名中使用诸如“Util”之类的无意义词语。</p><h3 id="源文件组织"><a href="#源文件组织" class="headerlink" title="源文件组织"></a>源文件组织</h3><p>鼓励多个声明（类、顶级函数或者属性）放在同一个 Kotlin 源文件中， 只要这些声明在语义上彼此紧密关联并且文件保持合理大小 （不超过几百行）。</p><p>特别是在为类定义与类的所有客户都相关的扩展函数时， 请将它们放在与类自身定义相同的地方。而在定义仅对指定客户有意义的扩展函数时，请将它们放在紧挨该客户代码之后。不要只是为了保存 “Foo 的所有扩展函数”而创建文件。</p><h3 id="类布局"><a href="#类布局" class="headerlink" title="类布局"></a>类布局</h3><p>通常，一个类的内容按以下顺序排列：</p><ul><li>属性声明与初始化块</li><li>次构造函数</li><li>方法声明</li><li>伴生对象</li></ul><p>不要按字母顺序或者可见性对方法声明排序，也不要将常规方法与扩展方法分开。而是要把相关的东西放在一起，这样从上到下阅读类的人就能够跟进所发生事情的逻辑。选择一个顺序（高级别优先，或者相反）并坚持下去。</p><p>将嵌套类放在紧挨使用这些类的代码之后。如果打算在外部使用嵌套类，而且类中并没有引用这些类，那么把它们放到末尾，在伴生对象之后。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Rule</title>
      <link href="/Android/Android%20rule/"/>
      <url>/Android/Android%20rule/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Git规范"><a href="#一、Git规范" class="headerlink" title="一、Git规范"></a>一、Git规范</h2><p>推荐使用 <strong>Github Desktop</strong> 客户端</p><h3 id="1-Git分支"><a href="#1-Git分支" class="headerlink" title="1. Git分支"></a>1. Git分支</h3><ol><li>master 存储正式发布历史的主分支，不能直接在<code>master</code>上进行修改代码和提交。</li><li>dev 作为开发分支，开发完成需要提交测试的功能合并到该分支，共同维护的开发分支。</li><li>release 上线前的 预览分支，可用于测试人员测试要上线的正式版，测试完成后PR到<code>master</code>。</li><li>feature 基于<code>dev</code>创建的临时分支，用于开发新功能或新模块，在本地与<code>dev</code>合并后PR到<code>dev</code>分支。</li></ol><h3 id="2-Git-命令行操作流程"><a href="#2-Git-命令行操作流程" class="headerlink" title="2. Git 命令行操作流程"></a>2. Git 命令行操作流程</h3>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs git">&#x2F;&#x2F; 本地分支 local<br> git pull origin local<br> git add .<br> git commit -m &#39;&#39;   &#x2F;&#x2F; 这里需写明这次提交的改动说明（必须提交），以便以后回退找到对应的指针<br> git push origin local<br> <br> git checkout dev <br> git pull origin dev <br> <br> git checkout local  &#x2F;&#x2F;切换到自己的分支<br> git merge dev   &#x2F;&#x2F; 有冲突解决冲突，让冲突发生在自己本地分支<br> <br> git checkeout dev <br> git merge local  &#x2F;&#x2F;更新代码到 dev 分支<br> <br> git add .<br> git commit -m &quot;merge local 实现的功能&quot;<br> git push origin dev<br></code></pre></td></tr></table></figure><h3 id="3-TAG命名"><a href="#3-TAG命名" class="headerlink" title="3. TAG命名"></a>3. TAG命名</h3><p>采用三段式＋日期，v版本.里程碑.序号，如v1.2.1-20200801</p><ul><li>Bug修复并上线，修改第3位   </li><li>架构升级或重大调整，修改第2位</li><li>新功能上线或者模块调整，修改第2位</li></ul><h3 id="4-gitignore文件"><a href="#4-gitignore文件" class="headerlink" title="4. .gitignore文件"></a>4. .gitignore文件</h3><p>Android 忽略文件模版</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs plain"># Built application 文件<br>*.apk<br>*.ap_<br><br># ART&#x2F;Dalvik VM 文件<br>*.dex<br><br># Java class 文件<br>*.class<br><br># Generated 文件夹<br>bin&#x2F;<br>gen&#x2F;<br>out&#x2F;<br><br># IntelliJ (IDE配置文件)<br>*.iml<br>&#x2F;.idea<br>.idea&#x2F;workspace.xml<br>.idea&#x2F;tasks.xml<br>.idea&#x2F;gradle.xml<br>.idea&#x2F;assetWizardSettings.xml<br>.idea&#x2F;dictionaries<br>.idea&#x2F;libraries<br>.idea&#x2F;caches<br><br># 本地配置文件 (sdk path, etc)<br>local.properties<br><br># Android Studio captures folder<br>captures&#x2F;<br><br># Log Files<br>*.log<br><br># Android Studio导航编辑器临时文件<br>.navigation&#x2F;<br><br># 在Android Studio 2.2及更高版本中生成的外部原生构建文件夹<br>.externalNativeBuild<br><br># 密钥储存库文件<br># 如果您不想检查密钥库文件，请取消注释以下行<br>#*.jks<br><br># 混淆文件<br>app&#x2F;proguard&#x2F;class_files.txt<br><br># Gradle files<br>.gradle&#x2F;<br>build&#x2F;<br><br># Mac<br>.DS_Store<br></code></pre></td></tr></table></figure><p>更新缓存 <code>git rm -r --cached .</code></p><hr><h2 id="二、注释规范"><a href="#二、注释规范" class="headerlink" title="二、注释规范"></a>二、注释规范</h2><ul><li>注释量必须不少于代码总量的15%</li><li>所有的类都必须添加创建者和创建日期</li><li>注释力求精简准确、表达到位，避免无用注释</li><li>中文注释描述，专有名词与关键字保持英文原文</li><li>代码和注释同步修改，尤其是参数、返回值等的修改</li><li>注释能够准确反应设计思想和代码逻辑，能描述业务含义</li><li>代码注释时除后续会恢复此段代码逻辑，否则应删除此段代码</li><li>多行注释与代码对齐，单行注释上方单独起一行，// 后空一个字符</li></ul><h3 id="1-文件头注释"><a href="#1-文件头注释" class="headerlink" title="1. 文件头注释"></a>1. 文件头注释</h3><p>Android Studio 中 Settings 搜索 File and Code Templates ，Includes下的File Header复制粘贴以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;**<br> * 文件描述<br> *<br> * @author wanggh8<br> * @version V1.0<br> * @date $&#123;DATE&#125;<br> *&#x2F;<br></code></pre></td></tr></table></figure><ul><li>auther：开发成员标识，格式英文字母</li><li>version：源文件当前版本，初始版本V1.0</li><li>date：源文件创建时间，格式：2020/8/10</li></ul><h3 id="2-方法、接口注释"><a href="#2-方法、接口注释" class="headerlink" title="2. 方法、接口注释"></a>2. 方法、接口注释</h3><p>每一个成员方法和功能方法、接口必须在上方做多行注释（方便不进入源码看注释），注释模板如下（使用<code>/**</code> + <code>Enter</code>自动生成）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;**<br> * 执行类型检查<br> *<br> * @param id:id,不用时传-1;<br> * @param execNo:执行唯一编码<br> *&#x2F;<br></code></pre></td></tr></table></figure><ul><li>方法概述和参数之间空一行</li><li>方法如有返回值，说明返回值类型</li><li>参数如果传值为标记值如-1、0、1，需指明</li><li>方法内逻辑比较复杂时，需使用单行注释标记说明</li></ul><h3 id="3-变量注释"><a href="#3-变量注释" class="headerlink" title="3. 变量注释"></a>3. 变量注释</h3><ul><li>单起一行的单行注释</li><li>容易歧义的变量声明必须注释</li><li>常量、全局变量声明时必须做功能注释</li><li>有意义的英文命名的变量，非标记变量可不注释</li><li>标记变量如flag（取值-1、0、1），必须注释并加值说明</li><li>实体类、请求体、返回体中的变量必须注释，标记变量添加值说明</li></ul><h3 id="4-块注释"><a href="#4-块注释" class="headerlink" title="4. 块注释"></a>4. 块注释</h3><ul><li>块注释使用单起一行的单行注释</li><li>嵌套条件语句过多时必须为条件添加注释</li><li>逻辑复杂不易理解时，应注释说明此段代码功能</li></ul><h3 id="5-特殊注释"><a href="#5-特殊注释" class="headerlink" title="5. 特殊注释"></a>5. 特殊注释</h3><ul><li><p>FIXME：表示错误不能工作，需要处理，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; FIXME: 2020&#x2F;8&#x2F;21 Bug描述 by yourname<br></code></pre></td></tr></table></figure></li></ul><ul><li><p>TODO：表示需要实现，但目前还未实现的功能，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">&#x2F;&#x2F; TODO: 2020&#x2F;8&#x2F;21 将要实现的功能 by yourname <br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="三、Java规范"><a href="#三、Java规范" class="headerlink" title="三、Java规范"></a>三、Java规范</h2><h3 id="1-命名规范"><a href="#1-命名规范" class="headerlink" title="1. 命名规范"></a>1. 命名规范</h3><ul><li>代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。</li><li>类名使用 UpperCamelCase 风格，必须遵从驼峰形式，但以下情形例外:DO / BO / DTO / VO / AO</li><li>方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式。</li><li>常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。</li><li>类中布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误。</li><li>杜绝完全不规范的缩写，避免望文不知义。</li><li>为了达到代码自解释的目标，任何自定义编程元素在命名时，使用尽量完整的单词组合来表达其意。</li><li>接口类中的方法和属性不要加任何修饰符号(public 也不要加)，保持代码的简洁性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。</li><li>枚举类名建议带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。</li></ul><h3 id="2-常量定义"><a href="#2-常量定义" class="headerlink" title="2. 常量定义"></a>2. 常量定义</h3><ul><li>尽量不让任何魔法值(即未经定义的常量)直接出现在代码中。</li><li>long 或者 Long 初始赋值时，使用大写的 L，不能是小写的 l，小写容易跟数字 1 混 淆，造成误解。</li><li>不要使用一个常量类维护所有常量，按常量功能进行归类，分开维护。</li><li>如果变量值仅在一个范围内变化，且带有名称之外的延伸属性，定义为枚举类。</li></ul><h3 id="3-代码格式"><a href="#3-代码格式" class="headerlink" title="3. 代码格式"></a>3. 代码格式</h3><ul><li><p>大括号的使用约定。如果是大括号内为空，则简洁地写成{}即可，不需要换行;如果是非空代码块则:</p><ul><li>左大括号前不换行。</li><li>左大括号后换行。</li><li>右大括号前换行。</li><li>右大括号后还有else等代码则不换行;表示终止的右大括号后必须换行。</li></ul></li><li><p>左小括号和字符之间不出现空格;同样，右小括号和字符之间也不出现空格。详见第 5 条下方正例提示。反例:if (空格a == b空格)</p></li><li><p>if/for/while/switch/do 等保留字与括号之间都必须加空格。</p></li><li><p>任何二目、三目运算符的左右两边都需要加一个空格</p></li><li><p>采用 4 个空格缩进，禁止使用 tab 字符。说明:如果使用 tab 缩进，必须设置 1 个 tab 为 4 个空格。Android Studio设置 tab 为 4 个空格时，请勿勾选Use tab character。</p></li><li><p>注释的双斜线与注释内容之间有且仅有一个空格。正例：// 注释内容</p></li><li><p>单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则: </p><ul><li>第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例。</li><li>运算符与下文一起换行。</li><li>方法调用的点符号与下文一起换行。</li><li>方法调用时，多个参数，需要换行时，在逗号后进行。</li><li>在括号前不要换行，见反例。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">正例：<br>StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();<br><span class="hljs-comment">// 超过 120 个字符的情况下，换行缩进 4 个空格，点号和方法名称一起换行 sb.append(&quot;zi&quot;).append(&quot;xin&quot;)...</span><br>    .append(<span class="hljs-string">&quot;huang&quot;</span>)... <br>    .append(<span class="hljs-string">&quot;huang&quot;</span>)... <br>    .append(<span class="hljs-string">&quot;huang&quot;</span>);<br><br>反例：<br>StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();<br><span class="hljs-comment">// 超过 120 个字符的情况下，不要在括号前换行 sb.append(&quot;zi&quot;).append(&quot;xin&quot;)...append</span><br>    (<span class="hljs-string">&quot;huang&quot;</span>);<br><span class="hljs-comment">// 参数很多的方法调用可能超过 120 个字符，不要在逗号前换行 </span><br>method(args1, args2, args3, ...<br>    , argsX); <br></code></pre></td></tr></table></figure></li><li><p>方法参数在定义和传入时，多个参数逗号后边必须加空格。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">method(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>IDE的text file encoding设置为UTF-8; IDE中文件的换行符使用Unix格式，不要使用 Windows 格式。</p></li><li><p>没有必要增加若干空格来使某一行的字符与上一行对应位置的字符对齐</p></li><li><p>方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义之间插入一个空行。相同业务逻辑和语义之间不需要插入空行。</p></li></ul><h3 id="4-控制语句"><a href="#4-控制语句" class="headerlink" title="4. 控制语句"></a>4. 控制语句</h3><ul><li><p>在一个 switch 块内，每个 case 要么通过 break/return 等来终止，要么注释说明程 序将继续执行到哪一个 case 为止;在一个 switch 块内，都必须包含一个 default 语句并且 放在最后，即使它什么代码也没有。</p></li><li><p>在 if/else/for/while/do 语句中必须使用大括号。即使只有一行代码，避免采用单行的编码方式:if (condition) statements;</p></li><li><p>表达异常的分支时，少用 if-else 方式，这种方式可以改写成:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (condition) &#123; <br>    ...<br>    <span class="hljs-keyword">return</span> obj; <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>如果非得使用 if()…else if()…else…方式表达逻辑，【强制】避免后续代码维护困难，请勿超过 3 层。超过 3 层的 if-else 的逻辑判断代码可以使用卫语句、策略模式、状态模式等来实现。</p></li><li><p>除常用方法(如 getXxx/isXxx)等外，不要在条件判断中执行其它复杂的语句，将复 杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。</p></li></ul><h3 id="5-异常处理"><a href="#5-异常处理" class="headerlink" title="5. 异常处理"></a>5. 异常处理</h3><ul><li>对大段代码进行 try-catch，这是不负责任的表现。catch 时请分清稳定代码和非稳 定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的 catch 尽可能进行区分 异常类型，再做对应的异常处理。</li><li>异常不要用来做流程控制，条件控制，因为异常的处理效率比条件分支低。</li><li>捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请 将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。</li><li>捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。</li><li>避免出现重复的代码(Don’t Repeat Yourself)，即DRY原则。必要时抽取共性方法，或者抽象公共类，甚至是组件化。</li></ul><hr><h2 id="四、Android规范"><a href="#四、Android规范" class="headerlink" title="四、Android规范"></a>四、Android规范</h2><p>注：采用模块化开发时，资源文件和源文件需带模块前缀，使用下划线与后面的内容分隔开。</p><h3 id="1-资源文件命名与使用"><a href="#1-资源文件命名与使用" class="headerlink" title="1. 资源文件命名与使用"></a>1. 资源文件命名与使用</h3><ul><li><p>layout文件的命名：单词间使用下划线分隔</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plain">Activity 的 layout 以 act_name 开头 <br>Fragment 的 layout 以 fragment_name 开头<br>Dialog 的 layout 以 dialog_name 开头<br>include 的 layout 以 layout_module 开头<br>ListView、GridView和RecyclerView等列表的行 layout 以 item_name 开头 <br>PopupWindow 的layout 以 pop_name<br></code></pre></td></tr></table></figure></li><li><p>drawable 资源名称以类型缩写_小写单词的方式命名，根据分辨率不同存放在不同的 drawable 目录下，如果介意包大小建议只使用一套，系统去进行缩放。采用规则如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">控件描述_业务功能描述_控件状态限定词<br></code></pre></td></tr></table></figure></li><li><p>anim 资源名称以小写单词+下划线的方式命名，采用以下规则:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">逻辑名称_[方向|序号]<br></code></pre></td></tr></table></figure></li><li><p>color 资源使用#RRGGBB 格式，写入 colors.xml 文件中，命名格式采用以下规则:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">逻辑名称_颜色<br></code></pre></td></tr></table></figure></li><li><p>dimen 资源以小写单词+下划线方式命名，写入 dimens.xml 文件中。</p></li><li><p>style 资源采用首字母大写的驼峰式方式命名，写入 styles.xml 文件中。</p></li><li><p>string 资源文件或者文本用到字符需要全部写入 strings.xml 文件中，字符串以小写单词+下划线的方式命名</p></li><li><p>Id 资源原则上以驼峰法命名，View 组件的资源 id 建议以 View 的缩写作为前缀。常用缩写表如下:</p><table><thead><tr><th align="center">控件</th><th align="center">缩写</th></tr></thead><tbody><tr><td align="center">LinearLayout</td><td align="center">ll</td></tr><tr><td align="center">RelativeLayout</td><td align="center">rl</td></tr><tr><td align="center">ConstraintLayout</td><td align="center">cl</td></tr><tr><td align="center">ListView</td><td align="center">lv</td></tr><tr><td align="center">ScollView</td><td align="center">sv</td></tr><tr><td align="center">TextView</td><td align="center">tv</td></tr><tr><td align="center">Button</td><td align="center">btn</td></tr><tr><td align="center">ImageView</td><td align="center">iv</td></tr><tr><td align="center">CheckBox</td><td align="center">cb</td></tr><tr><td align="center">RadioButton</td><td align="center">rb</td></tr><tr><td align="center">EditText</td><td align="center">et</td></tr></tbody></table><p>其它控件的缩写推荐使用小写字母并用下划线进行分割，例如:ProgressBar 对应</p><p>的缩写为 progress_bar;DatePicker 对应的缩写为 date_picker。</p></li><li><p>图片根据其分辨率，放在不同屏幕密度的 drawable 目录下管理</p><table><thead><tr><th align="center">dpi级别</th><th align="center">屏幕密度</th></tr></thead><tbody><tr><td align="center">ldpi</td><td align="center">120dpi</td></tr><tr><td align="center">mdpi</td><td align="center">160dpi</td></tr><tr><td align="center">hdpi</td><td align="center">240dpi</td></tr><tr><td align="center">xhdpi</td><td align="center">320dpi</td></tr><tr><td align="center">xxhdpi</td><td align="center">480dpi</td></tr><tr><td align="center">xxxhdpi</td><td align="center">640dpi</td></tr></tbody></table></li></ul><h3 id="2-基本组件"><a href="#2-基本组件" class="headerlink" title="2. 基本组件"></a>2. 基本组件</h3><p>Android 基 本 组 件 指 Activity 、 Fragment 、 Service 、 BroadcastReceiver 、ContentProvider 等等。</p><ul><li><p>Activity 间的数据通信，对于数据量比较大的，避免使用 Intent + Parcelable的方式，可以考虑 EventBus 等替代方案，以免造成TransactionTooLargeException。</p></li><li><p>Activity#onSaveInstanceState()方法不是 Activity 生命周期方法，也不保证一定会被调用。它是用来在 Activity 被意外销毁时保存 UI 状态的，只能用于保存临时性数据，例如 UI 控件的属性等，不能跟数据的持久化存储混为一谈。持久化存储应该在Activity#onPause()/onStop()中实行。</p></li><li><p>Activity 间通过隐式 Intent 的跳转，在发出 Intent 之前必须通过 resolveActivity 检查，避免找不到合适的调用组件，造成ActivityNotFoundException 的异常。</p></li><li><p>避免在 Service#onStartCommand()/onBind()方法中执行耗时操作，如果确实有需求，应改用 IntentService 或采用其他异步机制完成。</p></li><li><p>避免在 BroadcastReceiver#onReceive()中执行耗时操作，如果有耗时工作，应该创建 IntentService 完成，而不应该在 BroadcastReceiver 内创建子线程去做。</p><p>说明:</p><p>由于该方法是在主线程执行，如果执行耗时操作会导致 UI 不流畅。可以使用IntentService 、创 建 HandlerThread 或者调用Context#registerReceiver (BroadcastReceiver, IntentFilter, String, Handler)方法等方式，在其他 Wroker 线程执行 onReceive 方法。BroadcastReceiver#onReceive()方法耗时超过 10 秒钟，可能会被系统杀死。</p></li><li><p>避免使用隐式 Intent 广播敏感信息，信息可能被其他注册了对应 BroadcastReceiver 的 App 接收。</p></li><li><p>添 加 Fragment 时 ， 确 保 FragmentTransaction#commit() 在 Activity#onPostResume()或FragmentActivity#onResumeFragments()内调用。 不要随意使用 FragmentTransaction#commitAllowingStateLoss()来代替，任何 commitAllowingStateLoss()的使用必须经过 code review，确保无负面影响。</p><p>说明:</p><p>Activity 可能因为各种原因被销毁，Android 支持页面被销毁前通过Activity#onSaveInstanceState() 保存自己的状态。但如果FragmentTransaction.commit()发生在 Activity 状态保存之后，就会导致 Activity 重建、恢复状态时无法还原页面状态，从而可能出错。为了避免给用户造成不好的体验，系统会抛出IllegalStateExceptionStateLoss 异常。推荐的做法是在 Activity 的onPostResume() 或 onResumeFragments() ( 对 FragmentActivity ) 里执行 FragmentTransaction.commit()，如有必要也可在onCreate()里执行。不要随意改用FragmentTransaction.commitAllowingStateLoss() 或者直接使用 try-catch 避免 crash，这不是问题的根本解决之道，当且仅当你确认 Activity 重建、恢复状态时，本次 commit 丢失不会造成影响时才可这么做。</p></li><li><p>不要在 Activity#onDestroy()内执行释放资源的工作，例如一些工作线程的销毁和停止，因为 onDestroy()执行的时机可能较晚。可根据实际需要，在 Activity#onPause()/onStop()中结合 isFinishing() 的判断来执行。</p></li><li><p>如非必须，避免使用嵌套的 Fragment。Fragment 嵌套使用会有一些坑，容易出现 bug，比较常见的问题有如下几种:</p><ul><li>onActivityResult()方法的处理错乱，内嵌的 Fragment 可能收不到该方法的回调，需要由宿主 Fragment 进行转发处理;</li><li>突变动画效果;</li><li>被继承的 setRetainInstance() ，导致在 Fragment 重建时多次触发不必要的逻辑。</li></ul></li><li><p>总是使用显式Intent启动或者绑定Service，且不要为服务声明IntentFilter， 保证应用的安全性。如果确实需要使用隐式调用，则可为 Service 提供 Intent Filter 并从 Intent 中排除相应的组件名称，但必须搭配使用 Intent#setPackage()方法设置 Intent 的指定包名，这样可以充分消除目标服务的不确定性。</p></li><li><p>Service 需要以多线程来并发处理多个启动请求，建议使用 IntentService， 可避免各种复杂的设置。</p></li><li><p>对于只用于应用内的广播，优先使用 LocalBroadcastManager 来进行注册和发送，LocalBroadcastManager 安全性更好，同时拥有更高的运行效率。</p></li><li><p>当前 Activity 的 onPause 方法执行结束后才会创建(onCreate)或恢复 (onRestart)别的 Activity，所以在 onPause 方法中不适合做耗时较长的工作，这 会影响到页面之间的跳转效率。</p></li><li><p>Activity 或者 Fragment 中动态注册 BroadCastReceiver 时，registerReceiver() 和 unregisterReceiver()要成对出现。</p></li><li><p>Android 基础组件如果使用隐式调用，应在 AndroidManifest.xml 中使用 <intent-filter> 或在代码中使用 IntentFilter 增加过滤。</p></li></ul><h3 id="3-UI与布局"><a href="#3-UI与布局" class="headerlink" title="3. UI与布局"></a>3. UI与布局</h3><ul><li><p>布局中不得不使用 ViewGroup 多重嵌套时，不要使用 LinearLayout 嵌套，改用 RelativeLayout或ConstraintLayout，可以有效降低嵌套数。</p><p>说明:</p><p>Android 应用页面上任何一个 View 都需要经过 measure、layout、draw 三个步骤才能被正确的渲染。从 xml layout 的顶部节点开始进行 measure，每个子节点都需 要向自己的父节点提供自己的尺寸来决定展示的位置，在此过程中可能还会重新measure(由此可能导致 measure 的时间消耗为原来的 2-3 倍)。节点所处位置越深，嵌套带来的 measure 越多，计算就会越费时。这就是为什么扁平的 View 结构会性能更好。</p><p>同时，页面拥上的 View 越多，measure、layout、draw 所花费的时间就越久。要缩 短这个时间，关键是保持 View 的树形结构尽量扁平，而且要移除所有不需要渲染的View。理想情况下，总共的 measure，layout，draw 时间应该被很好的控制在16ms以内，以保证滑动屏幕时 UI 的流畅。要找到那些多余的 View(增加渲染延迟的 view)，可以用 Android Studio Monitor里的 Hierarchy Viewer 工具，可视化的查看所有的 view。</p></li><li><p>禁止在非 UI 线程进行 View 相关操作。</p></li><li><p>源文件统一采用 UTF-8 的形式进行编码。</p></li><li><p>文本大小使用单位 dp，View 大小使用单位 dp。对于 TextView，如果在文字大小确定的情况下推荐使用 wrap_content 布局避免出现文字显示不全的适配问题。</p></li><li><p>禁止在设计布局时多次为子 View 和父 View 设置同样背景进而造成页面过度绘制，推荐将不需要显示的布局进行及时隐藏（即不应在XML资源文件和java文件同时设置）。</p></li><li><p>不能在 Activity 没有完全显示时显示 PopupWindow 和 Dialog。</p></li><li><p>尽量不要使用 AnimationDrawable，它在初始化的时候就将所有图片加载 到内存中，特别占内存，并且还不能释放，释放之后下次进入再次加载时会报错。</p></li><li><p>不能使用 ScrollView 包裹 ListView/GridView/ExpandableListVIew;因为这样会把 ListView 的所有 Item 都加载到内存中，要消耗巨大的内存和 cpu 去绘制图面。推荐使用 NestedScrollView。</p></li><li><p>不要在 Android 的 Application 对象中缓存数据。基础组件之间的数据共享请使用 Intent 等机制，也可使用 SharedPreferences 等数据持久化机制。</p></li><li><p>使用 Toast 时，建议定义一个全局的 Toast 对象，这样可以避免连续显示 Toast 时不能取消上一次 Toast 消息的情况。即使需要连续弹出 Toast，也应避免直接调用 Toast#makeText。</p></li><li><p>使用 Adapter 的时候，如果你使用了 ViewHolder 做缓存，在 getView()的 方法中无论这项 convertView 的每个子控件是否需要设置属性(比如某个 TextView 设置的文本可能为 null，某个按钮的背景色为透明，某控件的颜色为透明等)，都需要为其显式设置属性(Textview 的文本为空也需要设置 setText(“”)，背景透明也需要设置)，否则在滑动的过程中，因为 adapter item 复用的原因，会出现内容的显示错乱。</p></li><li><p>在需要时刻刷新某一区域的组件时，建议通过以下方式避免引发全局 layout 刷新:</p><ul><li><p>设置固定的 View 大小的宽高，如倒计时组件等;</p></li><li><p>调用 View 的 layout 方法修改位置，如弹幕组件等;</p></li><li><p>通过修改 Canvas 位置并且调用 invalidate(int l, int t, int r, int b)等方式限定刷新</p><p>区域</p></li></ul></li></ul><h3 id="4-进程、线程与消息通信"><a href="#4-进程、线程与消息通信" class="headerlink" title="4. 进程、线程与消息通信"></a>4. 进程、线程与消息通信</h3><ul><li>不要通过 Intent 在 Android 基础组件之间传递大数据(binder transaction 缓存为 1MB)，可能导致 OOM。</li><li>在 Application 的业务初始化代码加入进程判断，确保只在自己需要的进程 初始化。特别是后台进程减少不必要的业务初始化。</li><li>新建线程时，必须通过线程池提供(AsyncTask 或者 ThreadPoolExecutor 或者其他形式自定义的线程池)，不允许在应用中自行显式创建线程。</li><li>线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</li><li>子线程中不能更新界面，更新界面必须在主线程中进行，网络操作不能在主线程中调用。</li><li>禁止在多进程之间用 SharedPreferences 共享数据，虽然可以 (MODE_MULTI_PROCESS)，但官方已不推荐。</li><li>谨慎使用 Android 的多进程，多进程虽然能够降低主进程的内存压力，但会遇到如下问题:<ul><li>首次进入新启动进程的页面时会有延时的现象(有可能黑屏、白屏几秒，是白屏还是黑屏和新 Activity 的主题有关);</li><li>应用内多进程时，Application 实例化多次，需要考虑各个模块是否都需要在所有进程中初始化。</li></ul></li></ul><h3 id="5-文件与数据库"><a href="#5-文件与数据库" class="headerlink" title="5. 文件与数据库"></a>5. 文件与数据库</h3><ul><li><p>任何时候不要硬编码文件路径，请使用 Android 文件系统 API 访问。</p></li><li><p>当使用外部存储时，必须检查外部存储的可用性。</p></li><li><p>应用间共享文件时，不要通过放宽文件系统权限的方式去实现，而应使用 FileProvider。</p></li><li><p>SharedPreference 中只能存储简单数据类型(int、boolean、String 等)，复杂数据类型建议使用文件、数据库等其他方式存储。</p></li><li><p>SharedPreference 提交数据时，尽量使用 Editor#apply()，而非 Editor#commit()。一般来讲，仅当需要确定提交结果，并据此有后续操作时，才使 用 Editor#commit()。</p><p>说明:</p><p>SharedPreference 相关修改使用 apply 方法进行提交会先写入内存，然后异步写入磁盘，commit 方法是直接写入磁盘。如果频繁操作的话 apply 的性能会优于 commit，apply 会将最后修改内容写入磁盘。但是如果希望立刻获取存储操作的结果，并据此做相应的其他操作，应当使用 commit。</p></li><li><p>数据库 Cursor 必须确保使用完后关闭，以免内存泄漏。</p></li><li><p>多线程操作写入数据库时，需要使用事务，以免出现同步问题。</p></li><li><p>大数据写入数据库时，请使用事务或其他能够提高 I/O 效率的机制，保证执行速度。</p></li><li><p>执行 SQL 语句时，应使用 SQLiteDatabase#insert()、update()、delete()， 不要使用SQLiteDatabase#execSQL()，以免 SQL 注入风险。</p></li><li><p>如果 ContentProvider 管理的数据存储在 SQL 数据库中，应该避免将不受 信任的外部数据直接拼接在原始 SQL 语句中。</p></li></ul><h3 id="6-图片与动画"><a href="#6-图片与动画" class="headerlink" title="6. 图片与动画"></a>6. 图片与动画</h3><ul><li>加载大图片或者一次性加载多张图片，应该在异步线程中进行。图片的加 载，涉及到 IO 操作，以及 CPU 密集操作，很可能引起卡顿。</li><li>在 ListView，ViewPager，RecyclerView，GirdView 等组件中使用图片时， 应做好图片的缓存，避免始终持有图片导致内存溢出，也避免重复创建图片，引起性能问题。建议使用 Glide (<a href="https://github.com/bumptech/glide)%E5%9B%BE%E7%89%87%E5%BA%93%E3%80%82">https://github.com/bumptech/glide)图片库。</a></li><li>png 图片使用 TinyPNG 或者类似工具压缩处理，减少包体积。</li><li>应根据实际展示需要，压缩图片，而不是直接显示原图。手机屏幕比较小，直接显示原图，并不会增加视觉上的收益，但是却会耗费大量宝贵的内存。</li><li>使用完毕的图片，应该及时回收，释放宝贵的内存。</li><li>在 Activity#onPause()或 Activity#onStop()回调中，关闭当前 activity 正在执 行的的动画。</li><li>在动画或者其他异步任务结束时，应该考虑回调时刻的环境是否还支持业 务处理。例如 Activity 的 onStop()函数已经执行，且在该函数中主动释放了资源， 此时回调中如果不做判断就会空指针崩溃。</li><li>当 View Animation 执行结束时，调用 View.clearAnimation()释放相关资源。</li><li>推荐使用 inBitmap 重复利用内存空间，避免重复开辟新内存。</li></ul><h3 id="7-安全"><a href="#7-安全" class="headerlink" title="7. 安全"></a>7. 安全</h3><ul><li>将 android:allowbackup 属性必须设置为 false，阻止应用数据被导出。</li><li>不要把敏感信息打印到 log 中。</li><li>确保应用发布版本的 android:debuggable 属性设置为 false。</li><li>MD5 和 SHA-1、SHA-256 等常用算法是 Hash 算法，有一定的安全性， 但不能代替加密算法。敏感信息的存储和传输，需要使用专业的加密机制。</li></ul><h3 id="8-日志"><a href="#8-日志" class="headerlink" title="8. 日志"></a>8. 日志</h3><ul><li><p>不能使用 System.out.println 打印 log。</p></li><li><p>Log 的 tag 不能是” “。应在每个文件定义TAG，TAG为相应文件名。例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">private static String TAG &#x3D; &quot;LoginActivity&quot;;<br></code></pre></td></tr></table></figure></li><li><p>临时debug的日志，使用后及时删除。</p></li></ul><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NestedScrollView</title>
      <link href="/Android/NestedScrollView/"/>
      <url>/Android/NestedScrollView/</url>
      
        <content type="html"><![CDATA[<p> 因此，我们可以简单的把 NestedScrollView类比为 ScrollView，其作用就是作为控件父布局，从而具备（嵌套）滑动功能。</p><p><strong><a href="https://developer.android.com/reference/android/support/v4/widget/NestedScrollView">NestedScrollView</a></strong> 与 <a href="https://developer.android.com/reference/android/widget/ScrollView.html">ScrollView</a> 的区别就在于 <strong><a href="https://developer.android.com/reference/android/support/v4/widget/NestedScrollView">NestedScrollView</a></strong> 支持 <em>嵌套滑动</em>，无论是作为父控件还是子控件，嵌套滑动都支持，且默认开启。</p><p>在一些需要支持嵌套滑动的情景中，比如一个 <a href="https://developer.android.com/reference/android/widget/ScrollView.html">ScrollView</a> 内部包裹一个 <code>RecyclerView</code>，那么就会产生滑动冲突，这个问题就需要你自己去解决。而如果使用 <strong><a href="https://developer.android.com/reference/android/support/v4/widget/NestedScrollView">NestedScrollView</a></strong> 包裹 <code>RecyclerView</code>，嵌套滑动天然支持，你无需做什么就可以实现前面想要实现的功能了。</p><p>我们通常为<code>RecyclerView</code>增加一个 Header 和 Footer 的方法是通过定义不同的 viewType来区分的，而如果使用 **<a href="https://developer.android.com/reference/android/support/v4/widget/NestedScrollView">NestedScrollView</a>**，我们完全可以把<code>RecyclerView</code>当成一个单独的控件，然后在其上面增加一个控件作为 Header，在其下面增加一个控件作为 Footer。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XRefreshView</title>
      <link href="/Android/XRefreshView/"/>
      <url>/Android/XRefreshView/</url>
      
        <content type="html"><![CDATA[<h1 id="Android万能上拉下拉刷新框架"><a href="#Android万能上拉下拉刷新框架" class="headerlink" title="Android万能上拉下拉刷新框架"></a>Android万能上拉下拉刷新框架</h1><p>XRefreshView 现阶段默认支持 ListView ， GridView ， WebView ，当然还可以支持 Scrollview ，TextView 对于任何想要刷新的 View ，只需要在想要刷新的 View 外面套一层 XRefreshView 就可以了</p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LiveData</title>
      <link href="/Android/LiveData/"/>
      <url>/Android/LiveData/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/2fa0aa513a32">https://www.jianshu.com/p/2fa0aa513a32</a></p><p><a href="https://www.jianshu.com/p/dab2ee97d680">https://www.jianshu.com/p/dab2ee97d680</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MVVM框架模式</title>
      <link href="/Android/MVVM/"/>
      <url>/Android/MVVM/</url>
      
        <content type="html"><![CDATA[<p>MVVM各个对应的层的职责相似：</p><p>Model层，主要负责数据的提供。Model层提供业务逻辑的数据结构（比如，实体类），提供数据的获取（比如，从本地数据库或者远程网络获取数据），提供数据的存储。<br>View层，主要负责界面的显示。View层不涉及任何的业务逻辑处理，它持有ViewModel层的引用，当需要进行业务逻辑处理时通知ViewModel层。<br>ViewModel层，主要负责业务逻辑的处理。ViewModel层不涉及任何的视图操作。通过官方提供的Data Binding库，View层和ViewModel层中的数据可以实现绑定，ViewModel层中数据的变化可以自动通知View层进行更新，因此ViewModel层不需要持有View层的引用。ViewModel层可以看作是View层的数据模型和Presenter层的结合。</p><p><a href="https://blog.csdn.net/u012317510/article/details/80247756">https://blog.csdn.net/u012317510/article/details/80247756</a></p><p><a href="https://github.com/darryrzhong/Android-MvvmComponent-App">https://github.com/darryrzhong/Android-MvvmComponent-App</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小技巧</title>
      <link href="/Android/Tips/"/>
      <url>/Android/Tips/</url>
      
        <content type="html"><![CDATA[<ul><li>在 XML 文件中，可以使用 FramLayout 或 RelativeLayout 来布局，每个控件都是覆盖显示的，后加进来的控件覆盖前面的控件。可以把控件写在最后，从而实现显示在最上层的效果。</li><li><code>view.bringToFront()</code>  可以将布局在下层的控件放到上层，不被其他控件挡住。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ButterKnife</title>
      <link href="/Android/ButterKnife/"/>
      <url>/Android/ButterKnife/</url>
      
        <content type="html"><![CDATA[<p>ButterKnife 是一个专注于Android系统的 View 注入框架。ButterKnife 用到的注解并不是在运行时反射的，而是在编译的时候生成新的 class 。与缓慢的反射相比，Butter Knife 使用再编译时生成的代码来执行 View 的查找，因此不必担心注解的性能问题。</p><ul><li>ButterKnife项目地址：<a href="https://github.com/JakeWharton/butterknife">https://github.com/JakeWharton/butterknife</a></li></ul><h2 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h2><ul><li>强大的 View绑定和Click事件处理功能，简化代码，提升开发效率</li><li>方便的处理Adapter里的ViewHolder绑定问题</li><li>运行时不会影响APP效率，使用配置方便</li><li>代码清晰，可读性强</li></ul><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">implementation <span class="hljs-string">&#x27;com.jakewharton:butterknife:8.8.1&#x27;</span><br>annotationProcessor <span class="hljs-string">&#x27;com.jakewharton:butterknife-compiler:8.8.1&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="Activity使用："><a href="#Activity使用：" class="headerlink" title="Activity使用："></a>Activity使用：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br><br>    <span class="hljs-comment">//获取控件</span><br>    <span class="hljs-meta">@BindView(R.id.name)</span><br>    EditText name;<br><br>    <span class="hljs-meta">@BindView(R.id.btn)</span><br>    Button btn;<br>    <span class="hljs-meta">@BindView(R.id.txt)</span><br>    TextView txt;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br><br>        <span class="hljs-comment">//绑定处理</span><br>        ButterKnife.bind(<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//按钮点击事件处理</span><br>    <span class="hljs-meta">@OnClick(R.id.btn)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onViewClicked</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span> (TextUtils.isEmpty(name.getText().toString().trim()))&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (name.getText().toString().trim().length() &lt; <span class="hljs-number">6</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        txt.setText(name.getText());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Fragment使用："><a href="#Fragment使用：" class="headerlink" title="Fragment使用："></a>Fragment使用：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BlankFragment</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fragment</span> </span>&#123;<br><br><br>    <span class="hljs-meta">@BindView(R.id.txt)</span><br>    TextView txt;<br>    <span class="hljs-meta">@BindView(R.id.btn)</span><br>    Button btn;<br><br><br>    Unbinder unbinder;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">onCreateView</span><span class="hljs-params">(LayoutInflater inflater, ViewGroup container,</span></span><br><span class="hljs-function"><span class="hljs-params">                             Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-comment">// Inflate the layout for this fragment</span><br>        View inflate = inflater.inflate(R.layout.fragment_blank, container, <span class="hljs-keyword">false</span>);<br>        unbinder = ButterKnife.bind(<span class="hljs-keyword">this</span>, inflate);<br>        <span class="hljs-keyword">return</span> inflate;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDestroyView</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onDestroyView();<br>        unbinder.unbind();<br>    &#125;<br><br>    <span class="hljs-meta">@OnClick(R.id.btn)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onViewClicked</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>颜色状态列表</title>
      <link href="/Android/Color/"/>
      <url>/Android/Color/</url>
      
        <content type="html"><![CDATA[<h2 id="代码颜色设置"><a href="#代码颜色设置" class="headerlink" title="代码颜色设置"></a>代码颜色设置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 通过16进制读取颜色</span><br>tv.setTextColor(Color.parseColor(<span class="hljs-string">&quot;#000000&quot;</span>));<br><span class="hljs-comment">// 根据资源文件读取颜色</span><br>tv.setTextColor(getResources().getColor(R.color.black)); <br><span class="hljs-comment">// 不能省略前面两个ff</span><br>tv.setTextColor(<span class="hljs-number">0xff000000</span>); <br><span class="hljs-comment">// Color中定义了常用颜色</span><br>tv.setTextColor(Color.BLACK); <br><span class="hljs-comment">// 根据RGB值来设置颜色</span><br>tv.setTextColor(Color.rgb(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)); <br></code></pre></td></tr></table></figure><h2 id="颜色属性"><a href="#颜色属性" class="headerlink" title="颜色属性"></a>颜色属性</h2><p>必须设置XML 命名空间</p><p><code>xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</code></p><p>定义在某些状态下使用的颜色，状态通过其属性来描述。必须是 `` 元素的子元素。</p><h3 id="颜色属性-1"><a href="#颜色属性-1" class="headerlink" title="颜色属性"></a>颜色属性</h3><ul><li><p><code>android:color</code></p><p>十六进制颜色。颜色通过 RGB 值和可选的 Alpha 通道指定。该值始终以井号 (#) 字符开头，后跟以下某种格式的“透明度、红、绿、蓝”(Alpha-Red-Green-Blue) 信息：#RGB#ARGB#RRGGBB#AARRGGBB</p></li><li><p><code>android:state_pressed</code></p><p>布尔值。如果此项应在按下对象时（例如轻触/点按了按钮时）使用，则为 <code>true</code> ；如果此项应在默认的非按下状态下使用，则为 <code>false</code> 。</p></li><li><p><code>android:state_focused</code></p><p>布尔值。如果此项应在聚焦对象时（例如使用轨迹球/方向键突出显示按钮时）使用，则为 <code>true</code> ；如果此项应在默认的非聚焦状态下使用，则为 <code>false</code> 。</p></li><li><p><code>android:state_selected</code></p><p>布尔值。如果此项应在选择对象时（例如打开标签页时）使用，则为 <code>true</code> ；如果此项应在未选择对象时使用，则为 <code>false</code> 。</p></li><li><p><code>android:state_checkable</code></p><p>布尔值。如果此项应在对象可勾选时使用，则为 <code>true</code> ；如果此项应在对象不可勾选时使用，则为 <code>false</code> 。（仅适用于对象可在可勾选和不可勾选的微件之间转换的情况。）</p></li><li><p><code>android:state_checked</code></p><p>布尔值。如果此项应在勾选对象时使用，则为 <code>true</code> ；如果应在取消勾选对象时使用，则为 <code>false</code> 。</p></li><li><p><code>android:state_enabled</code></p><p>布尔值。如果此项应在启用对象（能够接收轻触/点按事件）时使用，则为 <code>true</code> ；如果应在停用对象时使用，则为 <code>false</code> 。</p></li><li><p><code>android:state_window_focused</code></p><p>布尔值。如果此项应在应用窗口具有焦点（应用位于前台）时使用，则为 <code>true</code> ；如果此项应在应用窗口没有焦点时（例如通知栏下拉或出现一个对话框时）使用，则为 <code>false</code> 。</p></li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">selector</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span> &gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">item</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:color</span>=<span class="hljs-string">&quot;hex_color&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:state_pressed</span>=<span class="hljs-string">[</span>&quot;<span class="hljs-attr">true</span>&quot; | &quot;<span class="hljs-attr">false</span>&quot;]</span><br><span class="hljs-tag">        <span class="hljs-attr">android:state_focused</span>=<span class="hljs-string">[</span>&quot;<span class="hljs-attr">true</span>&quot; | &quot;<span class="hljs-attr">false</span>&quot;]</span><br><span class="hljs-tag">        <span class="hljs-attr">android:state_selected</span>=<span class="hljs-string">[</span>&quot;<span class="hljs-attr">true</span>&quot; | &quot;<span class="hljs-attr">false</span>&quot;]</span><br><span class="hljs-tag">        <span class="hljs-attr">android:state_checkable</span>=<span class="hljs-string">[</span>&quot;<span class="hljs-attr">true</span>&quot; | &quot;<span class="hljs-attr">false</span>&quot;]</span><br><span class="hljs-tag">        <span class="hljs-attr">android:state_checked</span>=<span class="hljs-string">[</span>&quot;<span class="hljs-attr">true</span>&quot; | &quot;<span class="hljs-attr">false</span>&quot;]</span><br><span class="hljs-tag">        <span class="hljs-attr">android:state_enabled</span>=<span class="hljs-string">[</span>&quot;<span class="hljs-attr">true</span>&quot; | &quot;<span class="hljs-attr">false</span>&quot;]</span><br><span class="hljs-tag">        <span class="hljs-attr">android:state_window_focused</span>=<span class="hljs-string">[</span>&quot;<span class="hljs-attr">true</span>&quot; | &quot;<span class="hljs-attr">false</span>&quot;] /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">selector</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="RGB颜色透明度转换"><a href="#RGB颜色透明度转换" class="headerlink" title="RGB颜色透明度转换"></a>RGB颜色透明度转换</h3><p>100% — FF<br>95% — F2<br>90% — E6<br>85% — D9<br>80% — CC<br>75% — BF<br>70% — B3<br>65% — A6<br>60% — 99<br>55% — 8C<br>50% — 80<br>45% — 73<br>40% — 66<br>35% — 59<br>30% — 4D<br>25% — 40<br>20% — 33<br>15% — 26<br>10% — 1A<br>5% — 0D<br>0% — 00</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android面试知识点整理</title>
      <link href="/Android/Android/"/>
      <url>/Android/Android/</url>
      
        <content type="html"><![CDATA[<h1 id="Activity的生命周期"><a href="#Activity的生命周期" class="headerlink" title="Activity的生命周期"></a>Activity的生命周期</h1><h2 id="Activity生命周期状态说明"><a href="#Activity生命周期状态说明" class="headerlink" title="Activity生命周期状态说明"></a>Activity生命周期状态说明</h2><table><thead><tr><th align="left">方法</th><th align="left">描述</th><th align="left">用途（以当前界面播放视频为例）</th><th align="left">下一个方法</th></tr></thead><tbody><tr><td align="left">onCreate()</td><td align="left">当Activity第一次创建时调用。该方法（如果有）会提供给你一个包含之前活动的冻结状态信息bundle包。</td><td align="left">进行一系列初始化操作，如：创建View，加载视频数据等。</td><td align="left">onStart()</td></tr><tr><td align="left">onRestart()</td><td align="left">当Activity被停止后调用，在重新开始之前</td><td align="left">当活动停止后重新启动该活动时调用（不常用），针对停止后重启操作。</td><td align="left">onStart()</td></tr><tr><td align="left">onStart()</td><td align="left">当Activity被展示在用户眼前时调用。如果活动出现在前台紧接着是onResume()，如果活动直接隐藏则紧接着是onStop()。</td><td align="left">该方法也不常用。</td><td align="left">onResume() or onStop()</td></tr><tr><td align="left">onResume()</td><td align="left">当Activity将开始与用户进行交互时调用。在这个时间点你的活动将会在活动堆栈的顶端，用户输入将会访问它。</td><td align="left">暂停后恢复我们会在该方法中进行一些操作，例如视频继续播放。</td><td align="left">onPause()</td></tr><tr><td align="left">onPause()</td><td align="left">当系统将要恢复一个之前的活动。这是一个有代表性的常常用于提交未被存储的改动信息为持久数据，停止动画和消耗CPU的东西等。实现该方法必须要特别的迅速，因为在此方法返回之前，下一个活动将不会恢复。如果活动将返回到前台则接下来调用onResume()，如果要隐藏到用户看不见的地方时，则调用onStop();</td><td align="left">该方法十分重要，用来做信息持久化存储操作以及停止消耗CPU资源操作，如记录视频播放进度时间，以及暂停视频播放操作等。</td><td align="left">onResume or onStop()</td></tr><tr><td align="left">onStop()</td><td align="left">当另一个活动被恢复且完全覆盖该活动，而该Activity将不在展示给用户时调用。这种情况将发生在一个新的活动将被开始，一个退出的活动将被恢复，又或者该活动将要被销毁。如果该活动将恢复与用户交互则调用onRestart(),如果该活动将被销毁则调用onDestory()。</td><td align="left">界面将会隐藏或销毁，做一些重要信息或未被存储的信息的存储操作。但也不要太耗时。如存储用户信息等操作，以及用户此次观看的视频地址以及时间，便于下次打开该界面时继续播放。</td><td align="left">onRestart() or onResume()</td></tr><tr><td align="left">onDestory()</td><td align="left">Activity被销毁钱最后一个被调用的方法。这个方法将会发生因为活动将会结束（在活动中调用finish()方法，或者系统临时销毁该实例节约空间。你可以使用isFinishing()方法区别这两种场景）。</td><td align="left">界面将要销毁，释放一些实例节约空间，如置空List集合等。</td><td align="left"></td></tr></tbody></table><h2 id="Activity4种本质状态："><a href="#Activity4种本质状态：" class="headerlink" title="Activity4种本质状态："></a>Activity4种本质状态：</h2><ul><li>运行： 当前显示在屏幕的activity(位于任务栈的顶部)，用户可见状态。 如果当前的activity在前台界面上时（堆栈顶端）。</li><li>暂停： 依旧在用户可见状态，但是界面焦点已经失去，此Activity无法与用户进行交互。 如果activity被另一个非全屏活动强占焦点并覆盖时（如弹窗dialog），它将会暂停。一个暂停的活动也是完全活跃的（它的所有的状态和成员信息将会保留，但activity本身将不会再依附于WindowsManager了），在内存极度缺乏的状态会被系统杀死。</li><li>停止： 用户看不到当前界面,也无法与用户进行交互 完全被覆盖.。如果activity完全被另一个全屏活动遮挡住时，它将会停止。该活动也仍保留全部的状态和成员信息，但将会被隐藏起来不再展示给用户，并且当内存在其他地方被需要时该活动就将会被系统杀死。</li><li>重启： 当前界面被销毁，等待这系统被回收 。如果activity处于暂停或者停止状态，系统将会在内存中终止该活动无论是结束活动或者杀死进程。当它再一次展示给用户时，它必须是完全重启并且恢复到之前的状态。</li></ul><h2 id="Activity的状态阶段"><a href="#Activity的状态阶段" class="headerlink" title="Activity的状态阶段"></a>Activity的状态阶段</h2><h2 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h2><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul><li>onCreate()：当我们点击activity的时候，系统会调用activity的oncreate()方法，在这个方法中我们会初始化当前布局setContentLayout（）方法。</li><li>onStart()：onCreate()方法完成后，此时activity进入onStart()方法,当前activity是用户可见状态，但没有焦点，与用户不能交互，一般可在当前方法做一些动画的初始化操作。</li><li>onResume()：onStart()方法完成之后，此时activity进入onResume()方法中，当前activity状态属于运行状态 (Running)，可与用户进行交互。</li><li>onPause()：当另外一个activity覆盖当前的acitivty时，此时当前activity会进入到onPause()方法中，当前activity是可见的，但不能与用户交互状态。</li><li>onStop()：onPause()方法完成之后，此时activity进入onStop()方法，此时activity对用户是不可见的，在系统内存紧张的情况下，有可能会被系统进行回收。所以一般在当前方法可做资源回收。</li><li>onDestory()：onStop()方法完成之后，此时activity进入到onDestory()方法中，结束当前activity</li><li>onRestart()：onRestart()方法在用户按下home()之后，再次进入到当前activity的时候调用。调用顺序onPause()-&gt;onStop()-&gt;onRestart()-&gt;onStart()-&gt;onResume().</li></ul><h2 id="Activity启动模式"><a href="#Activity启动模式" class="headerlink" title="Activity启动模式"></a>Activity启动模式</h2><h3 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h3><p>默认模式:</p><ul><li>每次启动时都会创建一个新的实例</li></ul><h3 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h3><p>栈顶模式:</p><ul><li>当启动Activity时,若该Activity位于栈顶,也就是正在前台与用户交互，那就复用这个Activity不会重新创建，该实例Activity.onNewIntent()方法会被调用.</li><li>当启动Activity时,若该Activity位于没有位于栈顶则创建和默认模式一样重新创建一个新的实例</li></ul><h3 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h3><p>栈内唯一模式:</p><ul><li>在启动activity时，若没有该Activity的实例存在于栈内,则会重新创建该Activity的实例.</li><li>在启动activity时，若该栈内存在于该Activity的实例并且位于栈顶,则不会重新创建,而是复用该实例,并且会调用Activity.onNewIntent()方法.</li><li>在启动activity时，若该栈内存在于该Activity的实例并且没有位于栈顶，那么这个Activity实例会被置为栈顶，并且移除其上面的所有Activity,并调用Activity.onNewIntent()方法</li></ul><h3 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h3><p>应用内栈唯一模式:<br> Activity的实例会存在于单独的任务栈内</p><ul><li>在启动activity时，若该实例存在则<br>其会被置为栈顶并且调用其 Activity.onNewIntent()方法.</li><li>在启动activity时，若该实例不存在,则要启动一个新activity实例,并且会存在于一个单独的任务栈中</li></ul><h2 id="Activity状态保存"><a href="#Activity状态保存" class="headerlink" title="Activity状态保存"></a>Activity状态保存</h2><h3 id="onSaveInstanceState-Bundle-outState"><a href="#onSaveInstanceState-Bundle-outState" class="headerlink" title="onSaveInstanceState(Bundle outState)"></a>onSaveInstanceState(Bundle outState)</h3><ul><li>onSaveInstanceState函数在Activity生命周期中执行。</li><li>outState 参数作用 :数据保存 : Activity 声明周期结束的时候, 需要保存 Activity 状态的时候, 会将要保存的数据使用键值对的形式 保存在 Bundle 对象中;</li><li>用户主动销毁不会调用 : 当用户点击回退键 或者 调用了 finish() 方法, 不会调用该方法; </li><li>调用时机不固定 : 该方法一定是在 onStop() 方法之前调用, 但是不确定是在 onPause() 方法之前 还是 之后调用; </li><li>布局中组件状态存储 : 每个组件都 实现了 onSaveInstance() 方法, 在调用函数的时候, 会自动保存组件的状态, 注意, 只有有 id 的组件才会保存;</li><li>关于默认的 super.onSaveInstanceState(outState) : 该默认的方法是实现 组件状态保存的;</li><li>调用时机 :<ol><li>Activity 被销毁的时候调用, 也可能没有销毁就调用了;</li><li>按下Home键 : Activity 进入了后台, 此时会调用该方法;</li><li>按下电源键 : 屏幕关闭, Activity 进入后台;</li><li>启动其它 Activity : Activity 被压入了任务栈的栈底;</li><li>横竖屏切换 : 会销毁当前 Activity 并重新创建；</li></ol></li></ul><h3 id="onRestoreInstanceState-Bundle-outState"><a href="#onRestoreInstanceState-Bundle-outState" class="headerlink" title="onRestoreInstanceState(Bundle outState)"></a>onRestoreInstanceState(Bundle outState)</h3><ul><li>方法回调时机 : 在 Activity 被系统销毁之后 恢复 Activity 时被调用, 只有销毁了之后重建的时候才调用, 如果内存充足, 系统没有销毁这个 Activity, 就不需要调用;</li><li>Bundle 对象传递 : 该方法保存的 Bundle 对象在 Activity 恢复的时候也会通过参数传递到 onCreate() 方法中;</li></ul><h2 id="Activity切换"><a href="#Activity切换" class="headerlink" title="Activity切换"></a>Activity切换</h2><p> 当AActivity切换BActivity的所执行的方法： </p><ul><li><p>AActivity:onCreate()-&gt;onStart()-&gt;onResume()-&gt;onPause()</p></li><li><p>BActivity:onCreate()-&gt;onStart()-&gt;onResume()</p></li><li><p>AActivity:onStop()-&gt;onDestory()</p><p>当AActivity切换BActivity（此activity是以dialog形式存在的）所执行的方法: </p></li><li><p>AActivity:onCreate()-&gt;onStart()-&gt;onResume()-&gt;onPause()</p></li><li><p>BActivity:onCreate()-&gt;onStart()-&gt;onResume() </p></li></ul><h1 id="Fragment的生命周期和方法"><a href="#Fragment的生命周期和方法" class="headerlink" title="Fragment的生命周期和方法"></a>Fragment的生命周期和方法</h1><h2 id="碎片与活动"><a href="#碎片与活动" class="headerlink" title="碎片与活动"></a>碎片与活动</h2><p><code>Fragment</code>的生命周期与<code>Activity</code>的生命周期密切相关。 <code>Activity</code>管理<code>Fragment</code>生命周期的方式是在<code>Activity</code>的生命周期方法中调用<code>FragmentManager</code>的对应方法，通过<code>FragmentManager</code>将现有的<code>Fragment</code>迁移至下一个状态，同时触发相应的生命周期函数。</p><h2 id="Fragment使用注意"><a href="#Fragment使用注意" class="headerlink" title="Fragment使用注意"></a>Fragment使用注意</h2><ul><li>使用Fragment时，必要构建一个无参构造函数，系统会默认带。但一但写有参构造函数，就必要构建无参构造函数。一般来说我们传参数给Fragment，会通过bundle，而不会用构造方法传 </li><li>Fragment是直接从Object继承的，而Activity是Context的子类。 </li><li>Fragment是依赖于Activity的，不能独立存在的。</li><li>一个Activity里可以有多个Fragment。</li><li>一个Fragment可以被多个Activity重用。</li><li>Fragment有自己的生命周期，并能接收输入事件。</li><li>我们能在Activity运行时动态地添加或删除Fragment。</li></ul><ul><li><input disabled="" type="checkbox"> Activity的四种启动模式、在app中的应用场景</li><li><input disabled="" type="checkbox"> View在Activity中显示出来的步骤、执行方法名、用途</li><li><input disabled="" type="checkbox"> rxjava、rxjava名字</li><li><input disabled="" type="checkbox"> mvc具体 数据库存取在那个、网络请求涉及那个</li><li><input disabled="" type="checkbox"> 数据库存储在主线程会引发啥</li><li><input disabled="" type="checkbox"> ANR  Application Not Responding 是</li><li><input disabled="" type="checkbox"> 为啥耗时操作要多线程</li><li><input disabled="" type="checkbox"> 界面绘制、居中最简单操作</li><li><input disabled="" type="checkbox"> activity和fragmeng的区别和方法</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>笔试知识点整理</title>
      <link href="/IT/Exam/"/>
      <url>/IT/Exam/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h1><ul><li><p>在数据库中存储的是<strong>数据以及数据之间的联系</strong>  </p></li><li><p>指针最优，单目运算优于双目运算。如正负号。 大多数运算符结合方向是“自左至右”，即：先左后右，也叫“左结合性”， C 语言有三类运算符的结合方向是从右至左，也叫“右结合性”，即：单目运算符、条件运算符、以及赋值运算符。<code>i++</code>优先级高于<code>++i</code>。 <a href="https://baike.baidu.com/item/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/4752611?fr=aladdin">百度百科</a> </p></li><li><p><strong>extern</strong> 提示编译器遇到此变量或函数时，在其它模块中寻找其定义，另外，extern也可用来进行链接指定，表明变量或者函数是定义在其他其他文件中的。 一个c文件需要调用另一个c文件里的变量或者函数，而不能从.h文件中调用变量</p><ul><li>在一个源文件里定义了一个数组：char a[6]; 在另外一个文件里用下列语句进行了声明：extern char *a； 程序运行时会告诉你非法访问。原因在于，指向类型T的指针并不等价于类型T的数组。extern char *a声明的是一个指针变量而不是字符数组，因此与实际的定义不同，从而造成运行时非法访问。应该将声明改为extern char a[ ]</li><li><strong>定义只能出现在一处</strong>。也就是说，不管是int a;还是int a=0;都只能出现一次，而那个<strong>extern int a可以出现很多次</strong>。 </li></ul></li><li><p>通过insert-values插入。未指定的列赋空值</p></li><li><p>数据库系统中 数据的<strong>一致性</strong>指的是<strong>同步更新</strong>。 事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。保证数据库一致性是指当事务完成时，必须使所有数据都具有一致的状态。在关系型数据库中，所有的规则必须应用到事务的修改上，以便维护所有数据的完整性。 </p></li><li><p>数据库系统减少了数据冗余 。数据的共享本身又可极大地减少数据冗余性，不仅减少了不必要的存储空间，更为重要的是可以避免数据的不一致性。所谓数据的一致性是指在系统中同一数据在不同位置出现时应保持相同的值 </p></li><li><p>数组初始化。C语言中，数组初始化的方式主要有三种：</p><ol><li>声明时，使用 {0} 初始化；<ul><li><code>char array[ARRAY_SIZE_MAX] = &#123;0&#125;;</code>  </li><li><code>int a[5] = &#123; 1 &#125;;    // 只有第一个为1，其余为0</code></li><li><code>string a[5] = &#123; &quot;foo&quot; &#125;;// 第一个为foo，其余为&quot;&quot;</code></li></ul></li><li><strong>使用memset；</strong>  <code>memset(array, 0, ARRAY_SIZE_MAX);</code> </li><li><strong>用for循环赋值。</strong> </li></ol></li><li><p>malloc和free、new和delete</p></li><li><p>数据模型的三要素:数据结构、数据操作、数据的完整性约束 </p></li><li><p>分解关系的基本原则：保持数据的独立性、保持函数依赖性</p></li><li><p>ALTER TABLE 语句用于在已有的表中添加、删除或修改列 </p><ol><li><code>ALTER TABLE table_name   ADD column_name datatype</code> </li><li><code>ALTER TABLE table_name   DROP COLUMN column_name</code> </li><li><code>ALTER TABLE table_name   MODIFY column_name datatype</code>或 <code>ALTER TABLE table_name   ALTER COLUMN column_name datatype</code> </li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> IT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MVC框架</title>
      <link href="/IT/MVC%E6%A1%86%E6%9E%B6/"/>
      <url>/IT/MVC%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="MVC框架"><a href="#MVC框架" class="headerlink" title="MVC框架"></a>MVC框架</h1><p>MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller) </p><p>Model：模型层，负责处理数据的加载或存储。<br>View：视图层，负责界面数据的展示，与用户进行交互。<br>Controller：控制器层，负责逻辑业务的处理。 </p><p>1.View接受用户的请求，然后将请求传递给Controller。<br>2.Controller进行业务逻辑处理后，通知Model去更新。<br>3.Model数据更新后，通知View去更新界面显示。 </p><p>框架模式有哪些？</p><p>MVC、MTV、<a href="https://baike.baidu.com/item/MVP/3714550">MVP</a>、CBD、<a href="https://baike.baidu.com/item/ORM">ORM</a>等等；</p><p>框架有哪些？</p><p><a href="https://baike.baidu.com/item/C%2B%2B">C++</a>语言的QT、MFC、gtk，Java语言的<a href="https://baike.baidu.com/item/SSH">SSH</a> 、<a href="https://baike.baidu.com/item/SSI"><strong>SSI</strong></a>，<a href="https://baike.baidu.com/item/php">php</a>语言的 smarty(MVC模式)，<a href="https://baike.baidu.com/item/python">python</a>语言的django(MTV模式)等等</p><p>设计模式有哪些？</p><p><a href="https://baike.baidu.com/item/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F">工厂模式</a>、适配器模式、策略模式等等</p><p>简而言之：框架是大智慧，用来对软件设计进行分工；设计模式是小技巧，对具体问题提出解决方案，以提高代码复用率，降低耦合度。</p>]]></content>
      
      
      
        <tags>
            
            <tag> IT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试知识点汇总</title>
      <link href="/IT/interview/"/>
      <url>/IT/interview/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="JAVA、Android"><a href="#JAVA、Android" class="headerlink" title="JAVA、Android"></a>JAVA、Android</h1><ul><li><p><input disabled="" type="checkbox">  == 和equal  <a href="https://www.cnblogs.com/zhuyeshen/p/10954275.html">1</a></p></li><li><p><input disabled="" type="checkbox">  面向对象和面向过程</p></li><li><p><input disabled="" type="checkbox">  C++和java的区别  <a href="https://www.sohu.com/a/233598512_100180425">1</a>  <a href="https://blog.csdn.net/u010120125/article/details/78261480">2</a></p></li><li><p><input disabled="" type="checkbox">  String 、Stringbuffer 、Stringbuild</p></li><li><p><input disabled="" type="checkbox">  重写和重载 举例</p></li><li><p><input disabled="" type="checkbox">  java三大特性 封装、继承、多态</p></li><li><p><input disabled="" type="checkbox">  http请求长地址网页</p></li><li><p><input disabled="" type="checkbox">  tcp udp区别</p></li><li><p><input disabled="" type="checkbox">  数据结构的几种</p></li><li><p><input disabled="" type="checkbox">  类加载的过程</p></li><li><p><input disabled="" type="checkbox">  成员变量和局部变量</p></li><li><p><input disabled="" type="checkbox">  进程和线程的区别</p></li><li><p><input disabled="" type="checkbox">  线程的状态</p></li><li><p><input disabled="" type="checkbox">  java线程和线程池</p></li><li><p><input disabled="" type="checkbox">  java多线程方法</p></li><li><p><input disabled="" type="checkbox">  多线程可以在单cpu执行吗</p></li><li><p><input disabled="" type="checkbox">  两个800m内存可以在1g内存运行吗</p></li><li><p><input disabled="" type="checkbox">  单例模型、饿汉式、懒汉、线程安全</p></li><li><p><input disabled="" type="checkbox">  web请求过程</p></li><li><p><input disabled="" type="checkbox">  http协议 post、get区别</p></li><li><p><input disabled="" type="checkbox">  tcp 、dns 、ip、http处于那个层</p></li><li><p><input disabled="" type="checkbox">  选择排序 时间复杂度、最优、最差</p></li><li><p><input disabled="" type="checkbox">  平衡二叉树</p></li><li><p><input disabled="" type="checkbox">  堆排序</p></li><li><p><input disabled="" type="checkbox">  哈希表</p></li><li><p><input disabled="" type="checkbox">  数据库表非常大时</p></li><li><p><input disabled="" type="checkbox">  链表反转</p></li><li><p><input disabled="" type="checkbox">  指针指向int和double有啥区别</p></li><li><p><input disabled="" type="checkbox">  快速排序</p></li><li><p><input disabled="" type="checkbox">  hashmap和hashtable</p></li><li><p><input disabled="" type="checkbox">  有那些可以用在快速索引</p></li><li><p><input disabled="" type="checkbox">  vue渲染过程</p></li><li><p><input disabled="" type="checkbox">  kmp回文查找</p></li><li><p><input disabled="" type="checkbox">  ios开发基础、对ios了解多少</p></li><li><p><input disabled="" type="checkbox">  http请求过程</p></li><li><p><input disabled="" type="checkbox">  如何请求服务器不存在</p></li><li><p><input disabled="" type="checkbox">  mvc怎么实现，各个部分如何联系</p></li><li><p><input disabled="" type="checkbox">  android数据绑定问题</p></li><li><p><input disabled="" type="checkbox">  tcp如何实现重传</p></li><li><p><input disabled="" type="checkbox">  tcp没有收到服务器回应，如何重传</p></li><li><p><input disabled="" type="checkbox">  tcp拥塞控制、慢开始</p></li><li><p><input disabled="" type="checkbox">  oc垃圾回收机制、java垃圾回收机制</p></li><li><p><input disabled="" type="checkbox">  java内存分配</p></li><li><p><input disabled="" type="checkbox">  http响应头</p></li><li><p><input disabled="" type="checkbox">  进程线程区别</p></li><li><p><input disabled="" type="checkbox">  进程如何通信</p></li><li><p><input disabled="" type="checkbox">  P、V如何做到多线程互斥，加锁的底层原理</p></li><li><p><input disabled="" type="checkbox">  面对对象和基于事件的区别</p></li><li><p><input disabled="" type="checkbox">  adapter底层如何实现数据绑定</p></li><li><p><input disabled="" type="checkbox">  找两个链表重叠的开始结点（双指针）</p></li><li><p><input disabled="" type="checkbox">  面向对象对于面向过程有什么优势 </p></li><li><p><input disabled="" type="checkbox">  对多线程的理解（我答提高并发度，安卓ANR需要多线程解决） </p></li><li><p><input disabled="" type="checkbox">  假如只有一个cpu，单核，多线程还有用吗 </p></li><li><p><input disabled="" type="checkbox">  hashmap和hashtable有啥不同（我说底层实现差不多，但是hashtable是线程安全的，因为访问的时候会加锁） </p></li><li><p><input disabled="" type="checkbox">  怎么做到线程互斥 </p></li><li><p><input disabled="" type="checkbox">  synchronized描述的一个静态方法和一个普通方法都对一个变量count进行访问，能保证线程安全吗（答不能，对象锁和类锁不是同一个东西） </p></li><li><p><input disabled="" type="checkbox">  对反射有了解吗（答了动态获取对象，在注解上的应用） </p></li><li><p><input disabled="" type="checkbox">  activity生命周期</p></li><li><p><input disabled="" type="checkbox">  databind</p></li><li><p><input disabled="" type="checkbox">  view绑定和传递</p></li><li><p><input disabled="" type="checkbox">  OOM</p><p>​    </p></li></ul><p>编程题：</p><ul><li><input disabled="" type="checkbox"> 用2个队列实现栈</li><li><input disabled="" type="checkbox"> 计算两数和的下标</li><li><input disabled="" type="checkbox"> 计算树的节点的最大距离</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> IT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java知识点整理</title>
      <link href="/Java/Java/"/>
      <url>/Java/Java/</url>
      
        <content type="html"><![CDATA[<h1 id="Java知识点整理"><a href="#Java知识点整理" class="headerlink" title="Java知识点整理"></a>Java知识点整理</h1><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><h4 id="1-面对对象和面向过程"><a href="#1-面对对象和面向过程" class="headerlink" title="1. 面对对象和面向过程"></a>1. 面对对象和面向过程</h4><ul><li>面向对象就是构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。 易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护。</li><li>面向过程分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候依次调用。性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源。 </li></ul><h4 id="2-C-和Java区别"><a href="#2-C-和Java区别" class="headerlink" title="2. C++和Java区别"></a>2. C++和Java区别</h4><ul><li><strong>Java 没有指针的概念</strong> 。 有效地防止了一系列由指针引起的操作层失误（如指针悬空所造成的系统崩溃），更有利于 Java 程序的安全 。</li><li><strong>Java不支持多重继承</strong> 。多重继承即 一个类允许继承多个父类， Java 不支持多重继承，但允许一个类实现多个接口 。</li><li><strong>Java 是完全面向对象的语言</strong>，所有方法和数据都必须是<strong>类</strong>的一部分。除了<strong>基本数据类型</strong>之外，其余类型的数据都作为<strong>对象型数据</strong> 。</li><li><strong>自动内存管理</strong> 。 <strong>Java 自动进行无用内存回收操作，不再需要程序员进行手动删除。</strong>Java 程序中所有的对象都是用 <strong>new 操作符</strong>建立在堆栈上的。 当 Java 中一个对象不再被用到时，无须使用内存回收器，只需要给它添加删除标签，无用内存的回收器便利用空闲时间在后台运行。</li><li><strong>Java 不支持操作符重载</strong> 。</li><li><strong>预处理功能</strong>。 Java 允许预处理，但不支持预处理器功能，因为 Java 没有预处理器，所以为了实现预处理，它提供了引入语句（<code>import</code>）。</li><li><strong>缺省参数函数</strong> 。 <strong>Java 不支持缺省参数函数，而 C++支持</strong> </li><li><strong>字符串</strong>。 <strong>C 和 C++不支持字符串变量</strong>，在 C 和 C++程序中使用**<code>Null</code><strong>终止符</strong>代表字符串的结束。在 Java 中字符串是用<strong>类对象</strong>（<code>String</code> 和 <code>StringBuffer</code>）来实现的，在整个系统中建立字符串和访问字符串元素的方法是一致的 </li><li><strong><code>goto</code> 语句</strong>。  Java 不提供 <code>goto</code> 语句 </li><li><strong>类型转换</strong>。 在 C 和 C++中，有时会出现数据类型的隐含转换，这就涉及了自动强制类型转换问题。 Java 不支持 C++中的自动强制类型转换，如果需要，必须由程序显式进行强制类型转换。 </li></ul><h4 id="3-编译型语言和解释型语言"><a href="#3-编译型语言和解释型语言" class="headerlink" title="3. 编译型语言和解释型语言"></a>3. 编译型语言和解释型语言</h4><ul><li><strong>编译型语言</strong>：把做好的源程序全部编译成二进制代码的可运行程序。然后，可直接运行这个程序。 编译型语言，执行速度快、效率高；依靠编译器、跨平台性差。 包括：<code>C</code>、<code>C++</code>、<code>Delphi</code>、<code>Pascal</code>、<code>Fortran</code> 。</li><li><strong>解释型语言</strong>：把做好的源程序翻译一句，然后执行一句，直至结束！解释型语言，执行速度慢、效率低；依靠解释器、跨平台性好 。 包括：<code>Java</code>、<code>Basic</code>、<code>javascript</code>。</li></ul><h4 id="4-Java三大特性"><a href="#4-Java三大特性" class="headerlink" title="4. Java三大特性"></a>4. Java三大特性</h4><ul><li><p><strong>封装</strong>： 将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问 </p><ul><li><p><strong>特点</strong>： 只能通过规定的方法访问数据，  隐藏类的实例细节，方便修改和实现 </p></li><li><table><thead><tr><th align="center">访问修饰符</th><th align="center">本类</th><th align="center">同包</th><th align="center">子类</th><th align="center">其他</th></tr></thead><tbody><tr><td align="center">private</td><td align="center">true</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">默认</td><td align="center">true</td><td align="center">true</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">protected</td><td align="center">true</td><td align="center">true</td><td align="center">true</td><td align="center"></td></tr><tr><td align="center">public</td><td align="center">true</td><td align="center">true</td><td align="center">true</td><td align="center">true</td></tr></tbody></table></li><li><p><strong>this关键字</strong>：代表当前对象，可以区别函数参数名和成员函数 </p></li><li><p><strong>内部类（ Inner Class ）</strong>：定义在另外一个类里面的类，包含内部类的类被称为外部类 。内部类的方法可以直接访问外部类的所有数据，包括<strong>私有的数据</strong>。内部类提供了<strong>更好的封装</strong>，可以把内部类<strong>隐藏</strong>在外部类之内，<strong>不允许</strong>同一个包中的其他类访问该类 。 使用内部类可以非常方便的编写事件驱动程序。 </p><ul><li><p><strong>成员内部类</strong>  ：</p></li><li><p><img src= "/img/loading.gif" data-lazy-src="../../assets/1189312-20170701101227446-1394544109.jpg" alt="1189312-20170701101227446-1394544109"></p></li></ul><ol><li>必须使用外部类对象来创建内部类对象,即：<strong>内部类 对象名 = 外部类对象.new 内部类( );</strong>  <ol start="2"><li>外部类是<strong>不能直接使用</strong>内部类的成员和方法;  如果外部类和内部类具有<strong>相同的成员变量或方法</strong>，内部类<strong>默认访问自己的成员变量或方法</strong>，如果要访问外部类的成员变量，可以使用 <strong>外部类类名.this 关键字</strong>。</li></ol></li></ol><ul><li><p><strong>静态内部类</strong> ： </p><p><img src= "/img/loading.gif" data-lazy-src="../../assets/1189312-20170701104143321-1802037961-1590229596136.jpg" alt="img"> </p><ol><li>静态内部类<strong>不能直接访问</strong>外部类的<strong>非静态成员</strong>，但可以通过 <strong>new 外部类().成员</strong> 的方式访问</li></ol></li></ul><ol start="2"><li>创建静态内部类的对象时，不需要外部类的对象，可以<strong>直接</strong>创建 **内部类 对象名= new 内部类()<ol start="3"><li>如果外部类的静态成员与内部类的成员<strong>名称相同</strong>，可通过“<strong>类名.静态成员</strong>”访问外部类的静态成员；如果外部类的静态成员与内部类的成员名称<strong>不相同</strong>，则可通过“<strong>成员名”</strong>直接调用外部类的静态成员。 </li></ol></li></ol><ul><li><p><strong>方法内部类</strong>  ：　方法内部类就是内部类定义在外部类的<strong>方法中</strong>，方法内部类只在该方法的内部可见，即<strong>只在该方法内可以使用</strong>。  方法内部类<strong>不能使用访问控制符和 static 修饰符</strong> </p><p><img src= "/img/loading.gif" data-lazy-src="../../assets/1189312-20170701104546883-1086970331-1590229599911.jpg" alt="img"></p></li></ul></li></ul></li></ul><pre><code>-  **匿名内部类**　　    ![img](../../assets/1189312-20170701111354524-354111187-1590229606069.png)    ![img](../../assets/1189312-20170701112249571-1791571271-1590229609729.png)   1.  匿名类是**不能有名称的类**，无法引用。必须在创建时，作为**new语句**的一部分来声明他们。   2.  使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口   3.  匿名内部类中是不能定义构造函数的。   4.  匿名内部类中不能存在任何的静态成员变量和静态方法   5.  匿名内部类为局部内部类（即方法内部类），所以局部内部类的所有限制同样对匿名内部类生效。 6.  匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。   7.  当所在的方法的形参需要被内部类里面使用时，该形参必须为final ，保证形参不改变</code></pre><ul><li><p><strong>继承</strong>：</p></li><li><p><strong>多态</strong>：</p></li></ul><h4 id="5-引用拷贝、浅拷贝、深拷贝"><a href="#5-引用拷贝、浅拷贝、深拷贝" class="headerlink" title="5. 引用拷贝、浅拷贝、深拷贝"></a>5. 引用拷贝、浅拷贝、深拷贝</h4><h4 id="6-单处理器可以多线程吗"><a href="#6-单处理器可以多线程吗" class="headerlink" title="6. 单处理器可以多线程吗"></a>6. 单处理器可以多线程吗</h4>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LoopBack进阶</title>
      <link href="/Backend/LoopBack2/"/>
      <url>/Backend/LoopBack2/</url>
      
        <content type="html"><![CDATA[<h2 id="Loopback远程方法"><a href="#Loopback远程方法" class="headerlink" title="Loopback远程方法"></a>Loopback远程方法</h2><a id="more"></a><p>Loopback远程方法需要调用<code>remoteMethod</code></p><p><img src= "/img/loading.gif" data-lazy-src="../../assets/1560444222607.png" alt="1560444222607"></p><p>样例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">Account.remoteMethod(<br>    <span class="hljs-string">&#x27;findByName&#x27;</span>,<br>    &#123;<br>      http: &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/findByName&#x27;</span>, <span class="hljs-attr">verb</span>: <span class="hljs-string">&#x27;get&#x27;</span> &#125;,<br>      accepts: &#123; <span class="hljs-attr">arg</span>: <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;string&#x27;</span>, <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">http</span>: &#123; <span class="hljs-attr">source</span>: <span class="hljs-string">&#x27;query&#x27;</span> &#125; &#125;,<br>      returns: &#123; <span class="hljs-attr">arg</span>: <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;object&#x27;</span> &#125;<br>    &#125;);<br></code></pre></td></tr></table></figure><p>同时模型进行相应的操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">Account.findByName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, cb</span>) </span>&#123;<br>    Account.find(&#123;<span class="hljs-attr">where</span>: &#123;<span class="hljs-attr">UserName</span>:name&#125;&#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, instance</span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.info(instance.id);<br>      cb(<span class="hljs-literal">null</span>, instance);  <br>    &#125;);  <br>  &#125;;<br></code></pre></td></tr></table></figure><h2 id="持久化模型"><a href="#持久化模型" class="headerlink" title="持久化模型"></a>持久化模型</h2><p>对于持久化模型，Loopback封装了很多增删查改的操作，本次用到的有：</p><h3 id="计数操作"><a href="#计数操作" class="headerlink" title="计数操作"></a>计数操作</h3><p><img src= "/img/loading.gif" data-lazy-src="../../assets/1560444381570.png" alt="1560444381570"></p><p>样例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">Account.count(&#123;<span class="hljs-attr">PhoneNumber</span>:user.PhoneNumber&#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, count</span>) </span>&#123;<br>     <span class="hljs-built_in">console</span>.info(count);&#125;);<br></code></pre></td></tr></table></figure><h3 id="创建操作"><a href="#创建操作" class="headerlink" title="创建操作"></a>创建操作</h3><p><img src= "/img/loading.gif" data-lazy-src="../../assets/1560444447894.png" alt="1560444447894"></p><p>样例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">Account.create(user, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, instance</span>) </span>&#123;<br>          cb(<span class="hljs-literal">null</span>, <span class="hljs-string">&#x27;successful&#x27;</span>);<br>        &#125;);<br></code></pre></td></tr></table></figure><h3 id="更新操作"><a href="#更新操作" class="headerlink" title="更新操作"></a>更新操作</h3><p><img src= "/img/loading.gif" data-lazy-src="../../assets/1560444635314.png" alt="1560444635314"></p><p>样例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">Account.updateAll(&#123;<span class="hljs-attr">PhoneNumber</span>:user.PhoneNumber&#125;,user, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, instance</span>) </span>&#123;<br>          <span class="hljs-built_in">console</span>.info(instance.id);<br>          cb(<span class="hljs-literal">null</span>, <span class="hljs-string">&#x27;successful&#x27;</span>);  <br>        &#125;); <br></code></pre></td></tr></table></figure><h3 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h3><p><img src= "/img/loading.gif" data-lazy-src="../../assets/1560444681867.png" alt="1560444681867"></p><p>样例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">Account.find(&#123;<span class="hljs-attr">where</span>: &#123;<span class="hljs-attr">PhoneNumber</span>:phone&#125;&#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, instance</span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.info(instance.id);<br>      cb(<span class="hljs-literal">null</span>, instance);  <br>    &#125;);<br></code></pre></td></tr></table></figure><h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p><img src= "/img/loading.gif" data-lazy-src="../../assets/1560444768616.png" alt="1560444768616"></p><p>样例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">Account.destroyAll(&#123;<span class="hljs-attr">PhoneNumber</span>:phone&#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, info</span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.info(info.id);<br>      cb(<span class="hljs-literal">null</span>, info);  <br>    &#125;);<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Backend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LoopBack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LoopBack基础</title>
      <link href="/Backend/LoopBack/"/>
      <url>/Backend/LoopBack/</url>
      
        <content type="html"><![CDATA[<h2 id="使用Loopback创建一个应用"><a href="#使用Loopback创建一个应用" class="headerlink" title="使用Loopback创建一个应用"></a>使用Loopback创建一个应用</h2><a id="more"></a><p>在一个空文件夹里使用loopback-cli 命令<code>lb</code>创建一个新的应用，之后根据提示进行操作，使用<code>npm install</code>安装依赖</p><h3 id="创建一个数据模型"><a href="#创建一个数据模型" class="headerlink" title="创建一个数据模型"></a>创建一个数据模型</h3><p>完成初始项目的构建后，进入项目目录，输入命令<code>lb model</code>创建一个自动具有REST API接口的模型。</p><p><img src= "/img/loading.gif" data-lazy-src="../../assets/1559749834993.png" alt="1559749834993"></p><p>属性可以在模型的json文件中修改，使用数据库进行存储，之前我已经配置好了数据库。</p><p>模型是LoopBack的核心，表示如数据库或其他后端服务（REST，SOAP等）等后端数据源。 LoopBack模型是具有Node和REST API的JavaScript对象。</p><p>LoopBack的一个关键功能是当您定义一个模型时，它将自动附带预定义的REST API，并具有完整的创建，读取，更新和删除操作。</p><p>Basic模型对象具有添加钩子和验证数据的方法。其他模型对象都“继承”它。模型具有继承层次结构，将模型附加到持久性数据源时，它将成为具有创建，检索，更新和删除操作的连接模型。</p><p>模型生成器将在应用程序的 <code>common / models</code> 目录中创建两个定义模型的文件： <code>.json</code> 和 <code>.js</code>。</p><h3 id="运行应用程序"><a href="#运行应用程序" class="headerlink" title="运行应用程序"></a>运行应用程序</h3><p>使用<code>$ node .</code>可以运行应用程序，</p><p><img src= "/img/loading.gif" data-lazy-src="../../assets/1559750395709.png" alt="1559750395709"> </p><p>打开第一个可以看到初始的信息</p><p><img src= "/img/loading.gif" data-lazy-src="../../assets/1559750432936.png" alt="1559750432936"></p><p> 打开第二个可以看到API信息</p><p><img src= "/img/loading.gif" data-lazy-src="../../assets/1559750472490.png" alt="1559750472490"></p><p>展开后可以看到具体的模型，以我以及实现的account为例</p><p><img src= "/img/loading.gif" data-lazy-src="../../assets/1559750582959.png" alt="1559750582959"></p><p>测试一下<code>get</code></p><p><img src= "/img/loading.gif" data-lazy-src="../../assets/1559750621087.png" alt="1559750621087"></p><h2 id="将API连接到数据源"><a href="#将API连接到数据源" class="headerlink" title="将API连接到数据源"></a>将API连接到数据源</h2><p>使用<code>$ lb datasource</code>打开数据源生成器定义数据源</p><p>根据提示进行选择，这里选择的是<code>postgreSQL</code></p><p><img src= "/img/loading.gif" data-lazy-src="../../assets/1559750791631.png" alt="1559750791631"></p><p>之后在<code>model-config.json</code>中将<code>account</code>的<code>dataSoucre</code>设置为<code>ios</code></p><p><img src= "/img/loading.gif" data-lazy-src="../../assets/1559751129573.png" alt="1559751129573"></p><p>可以直接尝试执行一些SQL语句，不过<code>LoopBack</code>提供了一个<code>Node API</code>，可以自动执行一个称作<code>auto-migration</code>的程序，主要用于保存一些测试数据到数据源。</p><p>通过<code>LoopBack</code>，添加一个远程方法，可以访问任何标准模型创建，检索，更新和删除方法来执行数据处理和验证，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">Account.getName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">id, cb</span>) </span>&#123;<br>    Account.findById(id, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, instance</span>) </span>&#123;<br>      <span class="hljs-keyword">var</span> response = instance.name;<br>      cb(<span class="hljs-literal">null</span>, response);<br>      <span class="hljs-built_in">console</span>.log(response);<br>    &#125;);<br>  &#125;;<br>  Account.remoteMethod(<br>    <span class="hljs-string">&#x27;getName&#x27;</span>,<br>    &#123;<br>      http: &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/getname&#x27;</span>, <span class="hljs-attr">verb</span>: <span class="hljs-string">&#x27;get&#x27;</span> &#125;,<br>      accepts: &#123; <span class="hljs-attr">arg</span>: <span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;number&#x27;</span>, <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">http</span>: &#123; <span class="hljs-attr">source</span>: <span class="hljs-string">&#x27;query&#x27;</span> &#125; &#125;,<br>      returns: &#123; <span class="hljs-attr">arg</span>: <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;string&#x27;</span> &#125;<br>    &#125;<br>  );<br></code></pre></td></tr></table></figure><h3 id="远程钩子介绍"><a href="#远程钩子介绍" class="headerlink" title="远程钩子介绍"></a>远程钩子介绍</h3><p>远程钩子（remote hook）是一个在远程方法（自定义远程方法或内置CRUD方法）之前或之后执行的功能。</p><ul><li><code>beforeRemote()</code>在远程方法之前运行。</li><li><code>afterRemote()</code>在远程方法之后运行。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Backend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LoopBack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系分第五次作业</title>
      <link href="/SSAD/SSAD-homework5/"/>
      <url>/SSAD/SSAD-homework5/</url>
      
        <content type="html"><![CDATA[<h2 id="使用-UMLet-建模"><a href="#使用-UMLet-建模" class="headerlink" title="使用 UMLet 建模"></a>使用 UMLet 建模</h2><a id="more"></a> <h3 id="1、根据订旅馆建模文档，Asg-RH-pdf"><a href="#1、根据订旅馆建模文档，Asg-RH-pdf" class="headerlink" title="1、根据订旅馆建模文档，Asg-RH.pdf"></a>1、根据订旅馆建模文档，<a href="https://sysu-swsad.github.io/swad-guide/material/Asg_RH.pdf">Asg-RH.pdf</a></h3><ul><li>绘制用例图模型（到子用例）</li></ul><p><img src= "/img/loading.gif" data-lazy-src="/assets/1558875626185.png" alt="1558875626185"> </p><ul><li>给出 make reservation 用例的活动图</li></ul><p><img src= "/img/loading.gif" data-lazy-src="/assets/1558876541613.png" alt="1558876541613"> </p><h3 id="2、根据课程练习“投递员使用投递箱给收件人快递包裹”的业务场景"><a href="#2、根据课程练习“投递员使用投递箱给收件人快递包裹”的业务场景" class="headerlink" title="2、根据课程练习“投递员使用投递箱给收件人快递包裹”的业务场景"></a>2、根据课程练习“投递员使用投递箱给收件人快递包裹”的业务场景</h3><ul><li><p>分别用多泳道图建模三个场景的业务过程</p><ul><li><p>x科技公司发明了投递柜，它们自建了投递柜以及远程控制系统。注册的投递员在推广期免费使用投递柜。由于缺乏资源，仅能使用y移动平台向客户发送短信通知。</p><p><img src= "/img/loading.gif" data-lazy-src="/assets/1558881150062.png" alt="1558881150062"> </p></li><li><p>随着产品推广，x公司与各大快递z公司达成协议。x公司在快递柜上添加了二维码扫描装置，z公司的快递员不仅可在快递柜上登陆（由z公司提供认证服务），且可扫描快递单号，投递入柜后自动由z公司发短信给客户。客户取件后，自动发送给z公司投递完成。</p><p><img src= "/img/loading.gif" data-lazy-src="/assets/1558882207236-0659641.png" alt="1558882207236"></p></li></ul></li></ul><ul><li><p>x公司进一步优化服务，开发了微信小程序实现扫码取快递。如果用户关注了该公司公众号，直接通过过公众号推送给用户取件码等信息。不再发送短信。</p><p><img src= "/img/loading.gif" data-lazy-src="/assets/1558882225054.png" alt="1558882225054"> </p></li></ul><ul><li><p>根据上述流程，给出快递柜系统最终的用例图模型</p><ul><li>用正常色彩表示第一个业务流程反映的用例</li><li>用绿色背景表述第二个业务场景添加或修改的用例，以及支持 Actor</li><li>用黄色背景表述第三个业务场景添加或修改的用例，以及支持 Actor</li></ul></li></ul><p><img src= "/img/loading.gif" data-lazy-src="/assets/1558883745281.png" alt="1558883745281"> </p>]]></content>
      
      
      
        <tags>
            
            <tag> 系分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系分第四次作业</title>
      <link href="/SSAD/SSAD-homework4/"/>
      <url>/SSAD/SSAD-homework4/</url>
      
        <content type="html"><![CDATA[<h2 id="1、简答题"><a href="#1、简答题" class="headerlink" title="1、简答题"></a>1、简答题</h2><h3 id="用例的概念"><a href="#用例的概念" class="headerlink" title="用例的概念"></a>用例的概念</h3><a id="more"></a> <p>用例是文本形式的情节描述，广泛应用于需求的发现和记录工作中，用以说明某参与者使用系统以实现某些目标。用例是描述参与者使用系统去达到某种目的一系列相关的成功和失败情景。它通过定义角色和系统之间的交互，来实现业务目标。</p><h3 id="用例和场景的关系？什么是主场景或-happy-path？"><a href="#用例和场景的关系？什么是主场景或-happy-path？" class="headerlink" title="用例和场景的关系？什么是主场景或 happy path？"></a>用例和场景的关系？什么是主场景或 happy path？</h3><p>关系：用例包含多个场景，包括主场景和可选场景，即用例就是一组相关的成功和失败场景集合，用来描述参与者如何使用系统来实现其目标。<br>主场景：对应主要的系统交互，通常是成功场景。</p><h3 id="用例有哪些形式？"><a href="#用例有哪些形式？" class="headerlink" title="用例有哪些形式？"></a>用例有哪些形式？</h3><p>摘要：简洁的一段式概要，通常是主场景，便于快速创建。<br>非正式l：非正式的段落格式，多个段落对应多个场景。<br>详述：详细编写所有步骤及各种变化， 同时具有补充部分， 如前置条件和成功保证。</p><h3 id="对于复杂业务，为什么编制完整用例非常难？"><a href="#对于复杂业务，为什么编制完整用例非常难？" class="headerlink" title="对于复杂业务，为什么编制完整用例非常难？"></a>对于复杂业务，为什么编制完整用例非常难？</h3><p>复杂业务的业务流程很复杂，涉及很多的场景，场景之间的关联也非常多，很难将所有的用例和场景按照一定顺序列举出来。同时，如果用例编写者对各个业务流程的理解存在偏差，用例的准确性和完整性就难以保证。</p><h3 id="什么是用例图？"><a href="#什么是用例图？" class="headerlink" title="什么是用例图？"></a>什么是用例图？</h3><p>用例图是指由参与者、用例，边界以及它们之间的关系构成的用于描述系统功能的视图，也是外部用户所能观察到的系统功能的模型图。</p><h3 id="用例图的基本符号与元素？"><a href="#用例图的基本符号与元素？" class="headerlink" title="用例图的基本符号与元素？"></a>用例图的基本符号与元素？</h3><p>小人（参与者）</p><p><img src= "/img/loading.gif" data-lazy-src="/assets/1558857923140.png" alt="1558857923140"> </p><p>椭圆（用例）</p><p><img src= "/img/loading.gif" data-lazy-src="/assets/1558857938597.png" alt="1558857938597"> </p><p>矩形（系统边界）</p><p><img src= "/img/loading.gif" data-lazy-src="/assets/1558858026998.png" alt="1558858026998"> </p><p>关系<br>直线（关联关系），表示两间之间是双向交互的协议</p><p><img src= "/img/loading.gif" data-lazy-src="/assets/1558858058725.png" alt="1558858058725"> </p><p>带箭头的虚线（包含关系），表示子用例是父用例的一部分，通常强调离开这个特性，父用例无法达成目标或失去意义， <strong>箭头指向子用例</strong></p><p> <img src= "/img/loading.gif" data-lazy-src="/assets/1558858071245.png" alt="1558858071245"></p><p>带箭头的虚线（扩展关系），表示子用例是父用例的可选场景或技术特征，<strong>箭头指向父用例</strong></p><p><img src= "/img/loading.gif" data-lazy-src="/assets/1558858077931.png" alt="1558858077931"> </p><p>空心三角实线箭头（泛化关系：泛化关系即为继承关系，这种关系存在于父用例与子用例之间；泛化关系中的父用例和子用例粒度相同，而包含关系是把大粒度用例分成了小粒度用例。 ）</p><p><img src= "/img/loading.gif" data-lazy-src="/assets/1558858100057.png" alt="1558858100057"> </p><h3 id="用例图的画法与步骤"><a href="#用例图的画法与步骤" class="headerlink" title="用例图的画法与步骤"></a>用例图的画法与步骤</h3><ul><li><p>确定研究系统<br>使用system框表示我们要研究的系统，并给它命名，绘制系统边界</p></li><li><p>识别actor</p><ul><li>识别使用系统的主要参与者（primary actors）/角色(roles)，使用用例图 actor符号 表示，绘制参与者，画在系统边界以外，通常放在系统框左边；</li></ul></li><li><p>确定系统依赖的外部系统，绘制关联的外部支持系统，用线将支持系统和对应的用例关联起来，通常放在系统框右边。</p></li><li><p>识别用例，用线将用例和参与者关联起来</p><ul><li>确定用户级别用例，并画在系统框里面<ul><li>确定子功能级别用例（用户用例下包含的操作），并画在系统框里面</li><li>确定用户用例与子用例之间的关系（include、extend，其中include由用户用例指向子用例，必须实现，extend由子用例指向用户用例，可选择实现），并用上面说的关系连线连接<br>确定参与者actor与用例之间的关系</li></ul></li></ul></li><li><p>建立参与者actor与用例之间的关系，绘制用例间的关系：如包含关系、扩展关系和泛化关系<br>确认参与者actor与用例之间关系后，使用无箭头的实现连接参与者与用例</p></li></ul><h3 id="用例图给利益相关人与开发者的价值有哪些？"><a href="#用例图给利益相关人与开发者的价值有哪些？" class="headerlink" title="用例图给利益相关人与开发者的价值有哪些？"></a>用例图给利益相关人与开发者的价值有哪些？</h3><ul><li><p>明确了业务范围，功能范围</p></li><li><p>表示了潜在的技术需求，可以提前进行技术规划与学习</p></li><li><p>帮助确定开发边界，评估工作量</p></li><li><p>用例图清晰地展示了系统的功能组成</p></li><li><p>系统架构的设计更加准确</p></li><li><p>系统的工作量评估也变得方便</p></li><li><p>可以简单修改用例图来表达需求变更的想法</p><h2 id="2、建模练习题（用例模型）"><a href="#2、建模练习题（用例模型）" class="headerlink" title="2、建模练习题（用例模型）"></a>2、建模练习题（用例模型）</h2></li></ul><p>选择2-3个你熟悉的类似业务的在线服务系统（或移动 APP），如定旅馆（携程、去哪儿等）、定电影票、背单词APP等，分别绘制它们用例图。并满足以下要求：</p><ul><li>请使用用户的视角，描述用户目标或系统提供的服务</li><li>粒度达到子用例级别，并用 include 和 exclude 关联它们</li><li>请用色彩标注出你认为创新（区别于竞争对手的）用例或子用例</li><li>尽可能识别外部系统和服务</li></ul><p>酒店预订系统：</p><p><img src= "/img/loading.gif" data-lazy-src="/assets/1558872803314.png" alt="1558872803314"> </p><p>定电影票：</p><p><img src= "/img/loading.gif" data-lazy-src="/assets/1558873092053.png" alt="1558873092053"> </p><h4 id="为什么相似系统的用例图是相似的？"><a href="#为什么相似系统的用例图是相似的？" class="headerlink" title="为什么相似系统的用例图是相似的？"></a>为什么相似系统的用例图是相似的？</h4><p>因为相似的系统目标人群和功能是相似的，导致用例相似，进而导致用户与用例，用例与子用例之间的关系也是相似的，最后整个用例图就很相似</p><h4 id="如果是定旅馆业务，请对比-Asg-RH-用例图，简述如何利用不同时代、不同地区产品的用例图，展现、突出创新业务和技术"><a href="#如果是定旅馆业务，请对比-Asg-RH-用例图，简述如何利用不同时代、不同地区产品的用例图，展现、突出创新业务和技术" class="headerlink" title="如果是定旅馆业务，请对比 Asg_RH 用例图，简述如何利用不同时代、不同地区产品的用例图，展现、突出创新业务和技术"></a>如果是定旅馆业务，请对比 Asg_RH 用例图，简述如何利用不同时代、不同地区产品的用例图，展现、突出创新业务和技术</h4><p>随着时代变化，新技术不断产生，会发生新技术替换/丰富旧用例图中的技术，如使用支付宝支付、微信支付<br>对于不同的地区，则应该充分考虑结合当地特色，为用户推荐当地特色美食，尊重当地饮食习惯进行推荐</p><h4 id="如何利用用例图定位创新思路（业务创新、或技术创新、或商业模式创新）在系统中的作用"><a href="#如何利用用例图定位创新思路（业务创新、或技术创新、或商业模式创新）在系统中的作用" class="headerlink" title="如何利用用例图定位创新思路（业务创新、或技术创新、或商业模式创新）在系统中的作用"></a>如何利用用例图定位创新思路（业务创新、或技术创新、或商业模式创新）在系统中的作用</h4><p>通过在用例图定位的创新思路（标记的创新用例），可以方便项目经理（业务创新）、需求方（商业模式创新）、开发者（技术创新）明确创新点。</p><h4 id="请使用-SCRUM-方法，选择一个用例图，编制某定旅馆开发的需求（backlog）开发计划表"><a href="#请使用-SCRUM-方法，选择一个用例图，编制某定旅馆开发的需求（backlog）开发计划表" class="headerlink" title="请使用 SCRUM 方法，选择一个用例图，编制某定旅馆开发的需求（backlog）开发计划表"></a>请使用 SCRUM 方法，选择一个用例图，编制某定旅馆开发的需求（backlog）开发计划表</h4><table><thead><tr><th align="center">ID</th><th align="center">Name</th><th align="center">Imp</th><th align="center">Est</th><th align="center">How to demo</th><th>Notes</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">注册系统</td><td align="center">30</td><td align="center">5</td><td align="center">注册，检验注册是否可以正常运作</td><td>需要注意用户账号间冲突的情形，使用验证码验证邮箱和手机号，然后通过注册，一个邮箱手机号对应一个账号，防止乱注册</td></tr><tr><td align="center">2</td><td align="center">登录系统</td><td align="center">30</td><td align="center">4</td><td align="center">注册后使用注册的账号进行登录，通过邮箱找回密码</td><td>使用 Cookie 或 Token 维持登录状态，安全性</td></tr><tr><td align="center">3</td><td align="center">订单系统</td><td align="center">50</td><td align="center">30</td><td align="center">根据地区查找旅馆，选择旅馆，选择房间，下订单，取消订单，完成订单</td><td>注重真实性，保证旅馆信息安全可靠</td></tr><tr><td align="center">4</td><td align="center">支付系统</td><td align="center">50</td><td align="center">10</td><td align="center">可以通过多方支付，包括支付宝支付，微信支付，信用卡支付</td><td>注重安全性，保证用户资金安全</td></tr></tbody></table><h4 id="根据任务4，参考-使用用例点估算软件成本，给出项目用例点的估算"><a href="#根据任务4，参考-使用用例点估算软件成本，给出项目用例点的估算" class="headerlink" title="根据任务4，参考 使用用例点估算软件成本，给出项目用例点的估算"></a>根据任务4，参考 <a href="https://www.ibm.com/developerworks/cn/rational/edge/09/mar09/collaris_dekker/index.html">使用用例点估算软件成本</a>，给出项目用例点的估算</h4><table><thead><tr><th align="center">用例</th><th align="center">事务</th><th align="center">计算</th><th align="center">原因</th><th align="center">UC权重</th></tr></thead><tbody><tr><td align="center">注册</td><td align="center">3</td><td align="center">3</td><td align="center">注册，查询和输入验证</td><td align="center">简单</td></tr><tr><td align="center">登陆</td><td align="center">2</td><td align="center">2</td><td align="center">登录和密码找回</td><td align="center">简单</td></tr><tr><td align="center">订单</td><td align="center">10</td><td align="center">8查找旅馆，选择旅馆，选择房间，下订单，取消订单，完成订单等操作</td><td align="center"></td><td align="center">复杂</td></tr><tr><td align="center">支付</td><td align="center">6</td><td align="center">6</td><td align="center">多种支付方式</td><td align="center">平均</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 系分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS数据库</title>
      <link href="/IOS/iOS%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/IOS/iOS%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库模糊查询"><a href="#数据库模糊查询" class="headerlink" title="数据库模糊查询"></a>数据库模糊查询</h2><p><code> NSString *NSsql=[NSString stringWithFormat:@&quot;SELECT id,name,age FROM t_person WHERE name like &#39;%%%@%%&#39; ORDER BY age ASC;&quot;,condition];</code></p><p> 注意：name like ‘西门’,相当于是name = ‘西门’。name like ‘%西%’,为模糊搜索，搜索字符串中间包含了’西’，左边可以为任意字符串，右边可以为任意字符串，的字符串。但是在 stringWithFormat:中%是转义字符，两个%才表示一个%。</p><p>实际操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">&#x2F;&#x2F; 查询数据<br>        FMResultSet *rs &#x3D; [self.db executeQuery:@&quot;SELECT * FROM user WHERE  UserName like &#39;%%%@%%&#39; AND Password like &#39;%%%@%%&#39; AND UserIcon like &#39;%%%@%%&#39; AND PhoneNumber like &#39;%%%@%%&#39; AND Email like &#39;%%%@%%&#39; AND Introduction like &#39;%%%@%%&#39; AND Sex like &#39;%%%@%%&#39; AND Birthday like &#39;%%%@%%&#39; AND Region like &#39;%%%@%%&#39; AND PostNum like &#39;%%%@%%&#39; AND PraiseNum like &#39;%%%@%%&#39; AND AttentionNum like &#39;%%%@%%&#39; AND FanNum like &#39;%%%@%%&#39;;&quot;, input, input, input, input, input, input, input, input, input, input, input, input, input];<br></code></pre></td></tr></table></figure><h2 id="图片转换"><a href="#图片转换" class="headerlink" title="图片转换"></a>图片转换</h2><p>//NSData转换为UIImage</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">NSData *imageData &#x3D; [NSData dataWithContentsOfFile: imagePath];<br>UIImage *image &#x3D; [UIImage imageWithData: imageData];<br></code></pre></td></tr></table></figure><p>//UIImage转换为NSData</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">NSData *imageData &#x3D; UIImagePNGRepresentation(image);<br>NSData *imageData &#x3D; UIImageJPEGRepresentation(image,1.0f);&#x2F;&#x2F;第二个参数为压缩倍数<br></code></pre></td></tr></table></figure><h2 id="NSMutableArray初始化"><a href="#NSMutableArray初始化" class="headerlink" title="NSMutableArray初始化"></a>NSMutableArray初始化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">NSMutableArray *array &#x3D;［NSMutableArray alloc] init];&#x2F;&#x2F;这并不是一个好方法<br><br>NSMutableArray *array &#x3D; [NSMutableArray arrayWithCapacity:10];&#x2F;&#x2F;创建一个可变的数组长度为10<br>&#x2F;&#x2F;1. arrayWithCapacity是类autorelease的.<br>&#x2F;&#x2F;2. [NSMutableArray alloc]initWithCapacity需要自己release.<br><br>[array addObject:User];&#x2F;&#x2F;添加一个元素<br>[array insertObject:@&quot;zero&quot; atIndex:0];&#x2F;&#x2F;给指定位置插入一个元素<br>[array removeObjectsInArray:arr];  &#x2F;&#x2F;数组arr有的元素在mArray中删除<br>[array removeObject:@&quot;three&quot; inRange:NSMakeRange(0, mArray.count)];&#x2F;&#x2F;按照范围删除<br>[array removeLastObject];  &#x2F;&#x2F;删除最后一个元素<br>[array removeObject:@&quot;six&quot;];  &#x2F;&#x2F;删除特定元素<br>[array removeObjectAtIndex:2];  &#x2F;&#x2F;按照下标删除<br>[array replaceObjectAtIndex:0 withObject:@&quot;third&quot;];&#x2F;&#x2F;按照下标替换元素<br>[array exchangeObjectAtIndex:1 withObjectAtIndex:2];&#x2F;&#x2F;按照下标交换元素<br><br>    NSMutableArray *mArray2 &#x3D; [NSMutableArray arrayWithObjects:@&quot;one&quot;,@&quot;two&quot;,@&quot;three&quot;,@&quot;four&quot;,@&quot;five&quot;,@&quot;six&quot;,@&quot;seven&quot;, nil];<br>    <br>&#x2F;&#x2F;    第一种遍历可变数组的方法－－快速枚举法<br>    for (id x in mArray2) &#123;<br>        NSLog(@&quot;%@&quot;,x);<br>    &#125;<br>    <br>&#x2F;&#x2F;    第二种遍历可变数组的方法－－一般循环法<br>    for (int i&#x3D;0; i&lt;mArray2.count; i++) &#123;<br>        NSLog(@&quot;%@&quot;,[mArray2 objectAtIndex:i]);<br>    &#125;<br>    <br>&#x2F;&#x2F;    第三种遍历可变数组的方法－－使用枚举器遍历<br>    NSEnumerator *enu &#x3D;[mArray2 objectEnumerator];<br>    id x;<br>    while (x&#x3D;[enu nextObject]) &#123;<br>        NSLog(@&quot;%@&quot; ,x);<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="数据库存储图片"><a href="#数据库存储图片" class="headerlink" title="数据库存储图片"></a>数据库存储图片</h2><h3 id="将图片转化成base64编码格式的字符串，直接以字符串的形式存放入数据库"><a href="#将图片转化成base64编码格式的字符串，直接以字符串的形式存放入数据库" class="headerlink" title="将图片转化成base64编码格式的字符串，直接以字符串的形式存放入数据库"></a>将图片转化成base64编码格式的字符串，直接以字符串的形式存放入数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">&#x2F;&#x2F;图片转化为base64字符串<br>UIImage *originImage &#x3D; [UIImage imageNamed:@&quot;origin.png&quot;];<br>NSData *data &#x3D; UIImageJPEGRepresentation(originImage, 1.0f);<br>NSString *encodedImageStr &#x3D; [data base64Encoding];<br>NSLog(@&quot;Encoded image:%@&quot;, encodedImageStr);<br><br>&#x2F;&#x2F;base64字符串转化为图片<br>NSData *decodedImageData &#x3D; [[NSData alloc] initWithBase64Encoding:encodedImageStr];<br>UIImage *decodedImage &#x3D; [UIImage imageWithData:decodedImageData];<br>NSLog(@&quot;Decoded image size: %@&quot;, NSStringFromCGSize(decodedImage.size));<br></code></pre></td></tr></table></figure><h3 id="利用FMDB数据库的blob类型的数据存取"><a href="#利用FMDB数据库的blob类型的数据存取" class="headerlink" title="利用FMDB数据库的blob类型的数据存取"></a>利用FMDB数据库的blob类型的数据存取</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">UIImage *UserIconImage &#x3D; model.UserIcon;<br>NSData *UserIcon &#x3D; UIImageJPEGRepresentation(UserIconImage,1.0f);<br>BOOL result &#x3D; [self.db executeUpdate:@&quot;INSERT INTO user (UserName, Password, UserIcon, PhoneNumber, Email, Introduction, Sex, Birthday, Region, PostNum, PraiseNum, AttentionNum, FanNum) value(?,?,?,?,?,?,?,?,?,?,?,?,?)&quot;,UserName, Password, UserIcon, PhoneNumber, Email, Introduction, Sex, Birthday, Region, PostNum, PraiseNum, AttentionNum, FanNum];<br><br>&#x2F;&#x2F;显示图片<br>FMResultSet *rs &#x3D; [self.db executeQuery:@&quot;SELECT * FROM user;&quot;];<br>NSData *ImageData &#x3D; [rs dataForColumn:@&quot;UserIcon&quot;];<br>User.UserIcon &#x3D; [UIImage imageWithData: ImageData];<br><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Objective-C </tag>
            
            <tag> iOS </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库设计</title>
      <link href="/IOS/Datebase%20storage/"/>
      <url>/IOS/Datebase%20storage/</url>
      
        <content type="html"><![CDATA[<h2 id="Document-相关操作"><a href="#Document-相关操作" class="headerlink" title="Document 相关操作"></a>Document 相关操作</h2><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">&#x2F;&#x2F;获得document<br>+(NSString *)documentsPath &#123;<br>NSArray *paths &#x3D; NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);<br><br>return [paths objectAtIndex:0];<br>&#125;<br><br>&#x2F;&#x2F;读取工程文件<br>+(NSString *) ProductPath:(NSString*)filename&#123;<br>    NSString *path &#x3D; [[NSBundlemainBundle] pathForResource:filename ofType:@&quot;&quot;];<br><br>    return  path;<br>&#125;<br><br>&#x2F;&#x2F;获得document文件路径，名字方便记忆<br>+(NSString *) DocumentPath:(NSString *)filename &#123;<br>NSString *documentsPath &#x3D; [self documentsPath];<br>    &#x2F;&#x2F; NSLog(@&quot;documentsPath&#x3D;%@&quot;,documentsPath);<br>return [documentsPath stringByAppendingPathComponent:filename];<br>&#125;<br><br>&#x2F;&#x2F;获得document文件路径<br>+(NSString *)fullpathOfFilename:(NSString *)filename &#123;<br>NSString *documentsPath &#x3D; [self documentsPath];<br>   &#x2F;&#x2F; NSLog(@&quot;documentsPath&#x3D;%@&quot;,documentsPath);<br>return [documentsPath stringByAppendingPathComponent:filename];<br>&#125;<br><br>&#x2F;&#x2F;写入文件沙盒位置NSDictionary<br>+(void)saveNSDictionaryForDocument:(NSDictionary *)list  FileUrl:(NSString*) FileUrl  &#123;<br>    NSString *f &#x3D; [self fullpathOfFilename:FileUrl];<br>[list writeToFile:f atomically:YES];<br>&#125;<br><br>&#x2F;&#x2F;写入文件存放到工程位置NSDictionary<br>+(void)saveNSDictionaryForProduct:(NSDictionary *)list  FileUrl:(NSString*) FileUrl  &#123;<br>    NSString *ProductPath &#x3D;[[NSBundlemainBundle]  resourcePath];<br>    NSString *f&#x3D;[ProductPath stringByAppendingPathComponent:FileUrl];<br>[list writeToFile:f atomically:YES];<br>&#125;<br><br>&#x2F;&#x2F;写入文件 Array 工程<br>+(void)saveOrderArrayListProduct:(NSMutableArray *)list  FileUrl :(NSString*) FileUrl &#123;<br>    NSString *ProductPath &#x3D;[[NSBundlemainBundle]  resourcePath];<br>NSString *f&#x3D;[ProductPath stringByAppendingPathComponent:FileUrl];<br>[list writeToFile:f atomically:YES];<br>&#125;<br><br>&#x2F;&#x2F;写入文件 Array 沙盒<br>+(void)saveOrderArrayList:(NSMutableArray *)list  FileUrl :(NSString*) FileUrl &#123;<br>NSString *f &#x3D; [self fullpathOfFilename:FileUrl];<br>[list writeToFile:f atomically:YES];<br>&#125;<br><br>&#x2F;&#x2F;加载文件沙盒NSDictionary<br>+(NSDictionary *)loadNSDictionaryForDocument  : (NSString*) FileUrl &#123;<br>NSString *f &#x3D; [self fullpathOfFilename:FileUrl];<br>NSDictionary *list &#x3D; [ [NSDictionaryalloc] initWithContentsOfFile:f];<br>return [list autorelease];<br>&#125;<br><br>&#x2F;&#x2F;加载文件工程位置NSDictionary<br>+(NSDictionary *)loadNSDictionaryForProduct   : (NSString*) FileUrl &#123;<br>NSString *f &#x3D; [self ProductPath:FileUrl];<br>NSDictionary *list &#x3D;[NSDictionarydictionaryWithContentsOfFile:f];<br>return list;<br>&#125;<br><br>&#x2F;&#x2F;加载文件沙盒NSArray<br>+(NSArray *)loadArrayList   : (NSString*) FileUrl &#123;<br><br> NSString *f &#x3D; [self fullpathOfFilename:FileUrl];<br>NSArray *list &#x3D; [NSArray  arrayWithContentsOfFile:f];<br>return list;<br>&#125;<br><br>&#x2F;&#x2F;加载文件工程位置NSArray<br>+(NSArray *)loadArrayListProduct   : (NSString*) FileUrl &#123;<br>NSString *f &#x3D; [self ProductPath:FileUrl];<br>NSArray *list &#x3D; [NSArray  arrayWithContentsOfFile:f];<br>return list;<br>&#125;<br><br>&#x2F;&#x2F;拷贝文件到沙盒<br>+(int) CopyFileToDocument:(NSString*)FileName&#123;<br>NSString *appFileName &#x3D;[self fullpathOfFilename:FileName];<br>NSFileManager *fm &#x3D; [NSFileManagerdefaultManager];  <br>&#x2F;&#x2F;判断沙盒下是否存在 <br>    BOOL isExist &#x3D; [fm fileExistsAtPath:appFileName];  <br>    if (!isExist)   &#x2F;&#x2F;不存在，把工程的文件复制document目录下<br>    &#123;  <br>        &#x2F;&#x2F;获取工程中文件<br>        NSString *backupDbPath &#x3D; [[NSBundle mainBundle]  <br>                                  pathForResource:FileName  <br>                                  ofType:@&quot;&quot;];    <br>       &#x2F;&#x2F;这一步实现数据库的添加，  <br>      &#x2F;&#x2F; 通过NSFileManager 对象的复制属性，把工程中数据库的路径复制到应用程序的路径上  <br>        BOOL cp &#x3D; [fm copyItemAtPath:backupDbPath toPath:appFileName error:nil];  <br>        return cp;<br>    &#125; else &#123;<br>        return  -1; &#x2F;&#x2F;已经存在<br>    &#125; <br>&#125;<br><br>&#x2F;&#x2F;判断文件是否存在<br>+(BOOL) FileIsExists:(NSString*) checkFile&#123;<br>    if([[NSFileManagerdefaultManager]fileExistsAtPath:checkFile])<br>    &#123;<br>        return true;<br>    &#125;<br>    return  false;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ios单例模式"><a href="#ios单例模式" class="headerlink" title="ios单例模式"></a>ios单例模式</h2><pre><code>     单例模式主要实现唯一实例，存活于整个程序范围内，一般存储用户信息经常用到单例，比如用户密码，密码在登录界面用一次，在修改密码界面用一次，而使用单例，就能保证密码唯一实例。如果不用单例模式，init 两个的实例的堆栈地址不一样，所以存放的数据的位置也不一样，当其中一个数据改变，另一个数据依然不变。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">#ifndef Singleton_h<br>#define Singleton_h<br><br>@interface Singleton : NSObject<br>@property (nonatomic, copy) NSString *pass;<br>+ (Singleton *) sharedInstance;<br><br>@end<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">#import &lt;Foundation&#x2F;Foundation.h&gt;<br>#import &quot;Singleton.h&quot;<br><br>@implementation Singleton<br>static id sharedSingleton &#x3D; nil;<br>+ (id)allocWithZone:(struct _NSZone *)zone<br>&#123;<br>if (sharedSingleton &#x3D;&#x3D; nil) &#123;<br>static dispatch_once_t onceToken;<br>dispatch_once(&amp;onceToken, ^&#123;<br>sharedSingleton &#x3D; [super allocWithZone:zone];    <br>&#125;);<br>&#125;<br>return sharedSingleton;<br>&#125;<br><br>- (id)init<br>&#123;<br>    static dispatch_once_t onceToken;<br>    dispatch_once(&amp;onceToken, ^&#123;<br>        sharedSingleton &#x3D; [super init];<br>    &#125;);<br>    return sharedSingleton;<br>&#125;<br><br>+ (instancetype)sharedInstance<br>&#123;<br>return [[self alloc] init];<br>&#125;<br>+ (id)copyWithZone:(struct _NSZone *)zone<br>&#123;<br>return sharedSingleton;<br>&#125;<br>+ (id)mutableCopyWithZone:(struct _NSZone *)zone<br>&#123;<br>return sharedSingleton;<br>&#125;<br><br>@end<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">+(UserDao *)sharedUserDao;<br>@implementation UserDao<br><br>static UserDao *userFmdb &#x3D; nil;<br>+(instancetype)allocWithZone:(struct _NSZone *)zone&#123;<br>    <br>    static dispatch_once_t onceToken;<br>    dispatch_once(&amp;onceToken, ^&#123;<br>        <br>        if (userFmdb &#x3D;&#x3D; nil) &#123;<br>            userFmdb &#x3D; [[UserDao alloc] init];<br>            &#x2F;&#x2F;创建数据库<br>            [userFmdb createDataBase];<br>            &#x2F;&#x2F;创建表<br>            [userFmdb createTable];<br>        &#125;<br>        <br>    &#125;);<br>    <br>    return userFmdb;<br>    <br>&#125;<br><br>+(UserDao *)shareduserDao&#123;<br>    <br>    return [[self alloc]init];<br>    <br>&#125;<br><br>-(id)copyWithZone:(NSZone *)zone<br>&#123;<br>    return userFmdb;<br>&#125;<br>-(id)mutableCopyWithZone:(NSZone *)zone<br>&#123;<br>    return userFmdb;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="iOS-图片本地存储、本地获取、本地删除"><a href="#iOS-图片本地存储、本地获取、本地删除" class="headerlink" title="iOS 图片本地存储、本地获取、本地删除"></a>iOS 图片本地存储、本地获取、本地删除</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">&#x2F;&#x2F;将图片保存到本地<br><br>\+ (void)SaveImageToLocal:(UIImage*)image Keys:(NSString*)key &#123;<br><br>    <br><br>    &#x2F;&#x2F;首先,需要获取沙盒路径<br><br>    NSString *picPath&#x3D;[NSString stringWithFormat:@&quot;%@&#x2F;Documents&#x2F;%@.png&quot;,NSHomeDirectory(),key];<br><br>    <br><br>    NSLog(@&quot;将图片保存到本地  %@&quot;,picPath);<br><br>    <br><br>    BOOL isHaveImage &#x3D; [self LocalHaveImage:key];<br><br>    if (isHaveImage) &#123;<br><br>        NSLog(@&quot;本地已经保存该图片、无需再次存储...&quot;);<br><br>        return ;<br><br>    &#125;<br><br>    <br><br>    NSData *imgData &#x3D; UIImageJPEGRepresentation(image,0.5);<br><br>    [imgData writeToFile:picPath atomically:YES];    <br><br>&#125;<br><br><br>&#x2F;&#x2F;从本地获取图片<br><br>\+ (UIImage*)GetImageFromLocal:(NSString*)key &#123;    <br><br>    if ([JKBlankTool isBlankString:key]) &#123;<br>        return nil;<br>    &#125;<br>    <br><br>    &#x2F;&#x2F;读取本地图片非resource<br><br>    NSString *picPath&#x3D;[NSString stringWithFormat:@&quot;%@&#x2F;Documents&#x2F;%@.png&quot;,NSHomeDirectory(),key];<br><br>    NSLog(@&quot;获取图片   %@&quot;,picPath); <br><br>    UIImage *img&#x3D;[[UIImage alloc]initWithContentsOfFile:picPath];<br><br>    return img;   <br><br>&#125;<br><br>&#x2F;&#x2F;本地是否有图片<br><br>\+ (BOOL)LocalHaveImage:(NSString*)key &#123;<br>  <br><br>    if ([JKBlankTool isBlankString:key]) &#123;<br>        return NO;<br>    &#125;<br>  <br>    &#x2F;&#x2F;读取本地图片非resource<br><br>   NSString *picPath&#x3D;[NSString stringWithFormat:@&quot;%@&#x2F;Documents&#x2F;%@.png&quot;,NSHomeDirectory(),key];  <br><br>   NSLog(@&quot;查询是否存在 %@&quot;,picPath);<br>   <br><br>    UIImage *img&#x3D;[[UIImage alloc]initWithContentsOfFile:picPath];   <br><br>   if (img) &#123;<br><br>        return YES;<br>    &#125;<br><br>    return NO;  <br><br>&#125;<br><br><br>&#x2F;&#x2F;将图片从本地删除<br><br>\+ (void)RemoveImageToLocalKeys:(NSString*)key &#123;<br><br>    <br><br>    NSString *picPath&#x3D;[NSString stringWithFormat:@&quot;%@&#x2F;Documents&#x2F;%@.png&quot;,NSHomeDirectory(),key];<br><br>    NSLog(@&quot;将图片从本地删除  %@&quot;,picPath);<br><br>    [[NSFileManager defaultManager] removeItemAtPath:picPath error:nil];<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="iOS-SQLite存取图片、视频、音频"><a href="#iOS-SQLite存取图片、视频、音频" class="headerlink" title="iOS SQLite存取图片、视频、音频"></a>iOS SQLite存取图片、视频、音频</h2><h4 id="1、设计数据库"><a href="#1、设计数据库" class="headerlink" title="1、设计数据库"></a>1、设计数据库</h4><p>数据库的表的结构：m_data 类型是blob用来存储NSData二进制数据</p><p>建表语句：</p><p><code>CREATE TABLE myTable(m_id integer primary key autoincrement not null,m_name text,m_type text,m_time text,m_data blob)</code></p><h3 id="2、上传图片、视频、音频到数据库"><a href="#2、上传图片、视频、音频到数据库" class="headerlink" title="2、上传图片、视频、音频到数据库"></a>2、上传图片、视频、音频到数据库</h3><h4 id="向数据库中添加数据的方法："><a href="#向数据库中添加数据的方法：" class="headerlink" title="向数据库中添加数据的方法："></a>向数据库中添加数据的方法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">&#x2F;&#x2F;添加图片、音乐、视频(数据类型、数据名、数据)<br>-(void)insertWithDataName:(NSString*)dataName DataType:(NSString*)dataType data:(NSData*)data&#123;<br><br>    [self openDB];<br>    NSString *sqlString&#x3D;@&quot;insert into myTable (m_name ,m_type,m_data,m_time) values (?,?,?,?)&quot;;<br>  <br>    sqlite3_stmt *stmt&#x3D;NULL;<br>      <br>    int result &#x3D; sqlite3_prepare(db, sqlString.UTF8String, -1, &amp;stmt, NULL);<br>    <br>    if (result&#x3D;&#x3D;SQLITE_OK) &#123;<br>        <br>        NSLog(@&quot;预执行正确&quot;);<br>        <br>        &#x2F;&#x2F;绑定参数<br>        &#x2F;&#x2F;第1个问号<br>        sqlite3_bind_text(stmt, 1, dataName.UTF8String, -1, NULL);<br>        &#x2F;&#x2F;第2个问号<br>        sqlite3_bind_text(stmt, 2, dataType.UTF8String, -1, NULL);<br>        &#x2F;&#x2F;第3个问号<br>        sqlite3_bind_blob(stmt, 3, [data bytes], (int)[data length], NULL);<br>        &#x2F;&#x2F;第4个问号<br>        sqlite3_bind_text(stmt, 4, [self getNowDate].UTF8String, -1, NULL);<br>        <br>        &#x2F;&#x2F;执行<br>        if(sqlite3_step(stmt)&#x3D;&#x3D;SQLITE_DONE)<br>            NSLog(@&quot;插入成功&quot;);<br>        else NSLog(@&quot;插入失败&quot;);<br>        <br>    &#125;<br>    else NSLog(@&quot;预执行错误&quot;);<br><br>    sqlite3_finalize(stmt);<br>    [self closeDB]; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="调用方法添加数据："><a href="#调用方法添加数据：" class="headerlink" title="调用方法添加数据："></a>调用方法添加数据：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">&#x2F;&#x2F;将数据写入到数据库<br>-(void)button2Action:(UIButton*)sender&#123;<br>    NSLog(@&quot;添加数据&quot;);<br><br>     NSBundle *mainBundle &#x3D;[NSBundle mainBundle];<br>    <br>    NSLog(@&quot;添加 芦田爱菜.png&quot;);<br>    NSString *picPath &#x3D; [mainBundle pathForResource:@&quot;芦田爱菜&quot; ofType:@&quot;png&quot;];<br>    NSData *dataPic &#x3D; [[NSData alloc]initWithContentsOfFile:picPath];<br>    <br>    if (![[MyDataBaseHandle shareDatabase]checkWithDataName:@&quot;芦田爱菜&quot; DataType:@&quot;png&quot;]) &#123;<br>         [[MyDataBaseHandle shareDatabase] insertWithDataName:@&quot;芦田爱菜&quot; DataType:@&quot;png&quot; data:dataPic];<br>    &#125;<br>    else &#123;<br>         [[MyDataBaseHandle shareDatabase] updateWithDataName:@&quot;芦田爱菜&quot; DataType:@&quot;png&quot; data:dataPic];<br>    &#125;<br><br>     NSLog(@&quot;添加 平凡之路-片段.mp3&quot;);<br>    NSString *MP3Path &#x3D; [mainBundle pathForResource:@&quot;平凡之路-片段&quot; ofType:@&quot;mp3&quot;];<br>       <br>    NSData *dataMP3 &#x3D; [[NSData alloc]initWithContentsOfFile:MP3Path];<br>     <br>    if (![[MyDataBaseHandle shareDatabase]checkWithDataName:@&quot;平凡之路-片段&quot; DataType:@&quot;mp3&quot;]) &#123;<br>        [[MyDataBaseHandle shareDatabase] insertWithDataName:@&quot;平凡之路-片段&quot; DataType:@&quot;mp3&quot; data:dataMP3];<br>    &#125;<br>    else &#123;<br>        [[MyDataBaseHandle shareDatabase] updateWithDataName:@&quot;平凡之路-片段&quot; DataType:@&quot;mp3&quot; data:dataMP3];<br>    &#125;<br><br>   <br>    NSLog(@&quot;添加 SNH 赵粤.mp4&quot;);<br>     NSString *MP4Path &#x3D; [mainBundle pathForResource:@&quot;SNH 赵粤&quot; ofType:@&quot;mp4&quot;];<br>     NSData *dataMP4 &#x3D; [[NSData alloc]initWithContentsOfFile:MP4Path];<br>    <br>    if (![[MyDataBaseHandle shareDatabase]checkWithDataName:@&quot;SNH 赵粤&quot; DataType:@&quot;mp4&quot;]) &#123;<br>        [[MyDataBaseHandle shareDatabase] insertWithDataName:@&quot;SNH 赵粤&quot; DataType:@&quot;mp4&quot; data:dataMP4];<br>    &#125;<br>    else &#123;<br>        <br>        [[MyDataBaseHandle shareDatabase] updateWithDataName:@&quot;SNH 赵粤&quot; DataType:@&quot;mp4&quot; data:dataMP4];<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、下载图片、视频、音频，并存入本地文件夹"><a href="#3、下载图片、视频、音频，并存入本地文件夹" class="headerlink" title="3、下载图片、视频、音频，并存入本地文件夹"></a>3、下载图片、视频、音频，并存入本地文件夹</h3><h4 id="从数据库获取数据的方法："><a href="#从数据库获取数据的方法：" class="headerlink" title="从数据库获取数据的方法："></a>从数据库获取数据的方法：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">&#x2F;&#x2F;查<br>-(NSData *)selectWithDataName:(NSString*)dataName DataType:(NSString*)dataType&#123;<br>    <br>    [self openDB];<br>    NSData * data &#x3D; nil;<br>    NSString *sqlString&#x3D;@&quot;select m_data from myTable where m_name&#x3D;? and m_type &#x3D; ?&quot;;<br>    <br>    &#x2F;&#x2F;2.伴随指针<br>    sqlite3_stmt *stmt&#x3D;NULL;<br>    <br>    &#x2F;&#x2F;3.预执行<br>    int result &#x3D; sqlite3_prepare(db, sqlString.UTF8String, -1, &amp;stmt, NULL);<br>    <br>    if (result&#x3D;&#x3D;SQLITE_OK) &#123;<br>        <br>        NSLog(@&quot;语句正确&quot;);<br>        <br>        &#x2F;&#x2F;4.绑定参数<br>        sqlite3_bind_text(stmt, 1, dataName.UTF8String, -1, NULL);<br>         sqlite3_bind_text(stmt, 2, dataType.UTF8String, -1, NULL);<br>        <br>        &#x2F;&#x2F;5.执行(N次,因为有可能有N条数据符合条件)&#x2F;&#x2F;循环判断是否还有符合查询条件的数据<br>        while (sqlite3_step(stmt)&#x3D;&#x3D;SQLITE_ROW) &#123;<br>            <br>           data &#x3D;[[NSData alloc] initWithBytes:sqlite3_column_blob(stmt, 0) length: sqlite3_column_bytes(stmt, 0)];<br>            <br>        &#125;<br>        <br>    &#125;<br>    else NSLog(@&quot;语句错误&quot;);<br>    <br>    &#x2F;&#x2F;6.关闭伴随指针<br>    sqlite3_finalize(stmt);<br>  [self closeDB];<br>    return data;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="调用方法，并将数据存储到本地文件夹："><a href="#调用方法，并将数据存储到本地文件夹：" class="headerlink" title="调用方法，并将数据存储到本地文件夹："></a>调用方法，并将数据存储到本地文件夹：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">&#x2F;&#x2F;从数据库获取数据-并存储到本地文件夹<br>-(void)button3Action:(UIButton*)sender&#123;<br><br>    NSString * destDateString &#x3D;[self getNowDate];<br><br>    NSLog(@&quot;搜索数据&quot;);<br><br>    &#x2F;&#x2F;&#x2F;&#x2F;获取png图片并写到本地<br>    NSData * data2&#x3D;[[MyDataBaseHandle shareDatabase] selectWithDataName:@&quot;芦田爱菜&quot; DataType:@&quot;png&quot;];<br>       <br>    UIImage *image2 &#x3D; [UIImage imageWithData:data2];<br>    [self.myIMV setImage:image2];<br>    <br>    NSString  *filePic&#x3D;  [self.filesPath stringByAppendingPathComponent:[NSString stringWithFormat:@&quot;&#x2F;%@芦田爱菜.png&quot;,destDateString]];<br>    [data2 writeToFile:filePic atomically:YES];<br><br><br>    &#x2F;&#x2F;获取Mp3并写到本地<br>   NSData * data3&#x3D;[[MyDataBaseHandle shareDatabase] selectWithDataName:@&quot;平凡之路-片段&quot; DataType:@&quot;mp3&quot;];<br>    <br>    NSString  *filemp3&#x3D;  [self.filesPath stringByAppendingPathComponent:[NSString stringWithFormat:@&quot;&#x2F;%@平凡之路-片段.mp3&quot;,destDateString]];<br>    [data3 writeToFile:filemp3 atomically:YES];<br><br> <br>    &#x2F;&#x2F;获取Mp4并写到本地<br>    NSData * data4&#x3D;[[MyDataBaseHandle shareDatabase] selectWithDataName:@&quot;SNH 赵粤&quot; DataType:@&quot;mp4&quot;];<br>    <br>    NSString  *filemp4&#x3D;  [self.filesPath stringByAppendingPathComponent:[NSString stringWithFormat:@&quot;&#x2F;%@SNH 赵粤.mp4&quot;,destDateString]];<br>    <br>    [data4 writeToFile:filemp4 atomically:YES];<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Objective-C </tag>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/SYSU/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/SYSU/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="知识框架"><a href="#知识框架" class="headerlink" title="知识框架"></a>知识框架</h2><a id="more"></a> <h2 id="知识梳理"><a href="#知识梳理" class="headerlink" title="知识梳理"></a>知识梳理</h2><h3 id="第1章-操作系统概述"><a href="#第1章-操作系统概述" class="headerlink" title="第1章 操作系统概述"></a>第1章 操作系统概述</h3><p>1.1 操作系统的基本概念<br>操作系统是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境的程序集合。</p><p>并发是指两个多多个事件在同一时间间隔内发生，引入进程的目的是使程序能并发执行。<br>注意：同一时间间隔（并发）和同一时刻（并行）的区别。微观上这些程序还是分时交替执行。<br>共享是指系统中的资源可供内存中多个并发执行的进程共同使用，可分为互斥共享方式、同时访问方式。<br>并发和共享是操作系统两个最基本的特征。<br>虚拟是指把一个物理上的实体变为若干个逻辑上的对应物，如虚拟处理器、虚拟内存、虚拟外部设备。<br>异步：在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底，而是走走停停，以不可预知的速度向前推进。</p><p>操作系统作为计算机系统资源的管理者：处理机管理、存储器管理、文件管理、设备管理<br>操作系统作为用户与计算机硬件系统之间的接口：<br>1）命令接口：联机命令接口又称交互式命令接口，适用于分时或实时系统的接口，由一组键盘操作命令组成；脱机命令接口又称批处理命令接口，即适用于批处理系统，由一组作业控制命令组成。<br>2）程序接口：由一组系统调用命令（简称系统调用，也称广义指令）组成<br>操作系统用作扩充机器</p><p>选择题</p><p>8.单处理机系统中，可并行的是（II、III、IV）<br>I. 进程与进程<br>II. 处理机与设备<br>III. 处理机与通道<br>IV. 设备与设备</p><p>12.操作系统提供给编程人员的接口是（系统调用）</p><p>19.计算机开机后，操作系统最终被加载到（RAM）</p><p>1.2 操作系统的发展与分类<br>手工操作阶段（此阶段无操作系统）<br>批处理阶段（操作系统开始出现）：<br>1）单道批处理系统：自动性、顺序性、单道性<br>2）多道批处理系统：多道、宏观上并行、微观上串行<br>分时操作系统：同时性、交互性、独立性、及时性<br>实时操作系统：及时性、可靠性<br>网络操作系统：网络中各种资源的共享以及各台计算机之间的通信<br>分布式计算机系统：分布性、并行性<br>分布式操作系统与网络操作系统本质上的不同之处在于分布式操作系统中，若干台计算机相互协同完成同一任务。<br>个人计算机操作系统</p><p>选择题</p><p>1.提高单机资源利用率的关键技术是（多道程序设计技术）</p><p>2.批处理系统的主要缺点是（无交互能力）</p><p>8.实时系统的进程调度，通常采用（抢占式的优先级高者优先）算法</p><p>9.（资源利用率）不是设计实时操作系统的主要追求目标</p><p>10.（航空订票、机床控制、股票交易系统）应用工作最好采用实时操作系统平台</p><p>11.分时系统的一个重要性能是系统的响应时间，对操作系统（优先级+非抢占式调度算法）因素进行改进有利于改善系统的响应时间</p><p>12.分时系统追求的目标是（比较快速响应用户）</p><p>13.在分时系统中，时间片一定时，（用户数越多）响应时间越长（T=Q*N，Q为时间片，N为用户数）</p><p>1.3 操作系统的运行环境<br>操作系统内核包括：时钟管理、中断机制、原语、系统控制的数据结构及处理</p><p>中断，也称外中断，指来自CPU执行指令以外的事件的发生<br>异常，也称内中断、例外或陷入，指源自CPU执行指令内部的事件</p><p>如果程序的运行由用户态转到核心态，会用到访管指令，访管指令是在用户态使用的，所以它不可能是特权指令。</p><p>选择题</p><p>2.下列说法正确的是（II、IV）<br>I. 批处理的主要缺点是需要大量内存（错误，缺少交互性）<br>II. 当计算机提供了核心态和用户态时，输入/输出指令必须在核心态下执行（正确）<br>III. 操作系统中采用多道程序设计技术的最主要原因是为了提高CPU和外部设备的可靠性（错误，提高系统资源利用率和吞吐量）<br>IV. 操作系统中，通道技术是一种硬件技术（正确）</p><p>4.（中断处理）是操作系统必须提供的功能</p><p>5.用户程序在用户态下要使用特权指令引起的中断属于（访管中断）</p><p>8.在中断发生后，进入中断处理的程序属于（操作系统程序）</p><p>10.下列选项中，在用户态执行的是（A）<br>A 命令解释程序（命令接口）<br>B 缺页处理程序<br>C 进程调度程序<br>D 时钟中断处理程序</p><p>11.下列选项中，不可能在用户态发生的事件是（C）<br>A 系统调用 B 外部中断 C 进程切换 D 缺页</p><p>13.访管指令（仅在用户态下）使用</p><p>15.在操作系统中，下列只能在核心态下执行的指令是（广义指令）（调用可能在用户态）</p><p>16.输入/输出指令必须在核心态下执行</p><p>17.当CPU处于核心态时，可以执行的指令是（除访管指令的全部指令）</p><h3 id="第2章-进程管理"><a href="#第2章-进程管理" class="headerlink" title="第2章 进程管理"></a>第2章 进程管理</h3><p>2.1 进程与线程<br>进程控制块PCB，描述进程的基本情况和运行状态，进而控制和管理进程。<br>由程序段、相关数据段和PCB三部分构成了进程映像（进程实体）。<br>注意：进程映像是静态的，进程是动态的。PCB是进程存在的唯一标志</p><p>进程是进程实体的运行过程，是系统进行资源分配合调度的一个独立单位，其特征包括：动态性（最基本）、并发性、独立性、异步性、结构性。<br>进程的状态：运行、就绪、阻塞（等待）、创建、结束<br>就绪-&gt;运行<br>运行-&gt;就绪<br>运行-&gt;阻塞（主动的行为）<br>阻塞-&gt;就绪（被动的行为）</p><p>进程：<br>1）进程控制块PCB：进程创建时，操作系统就新建一个PCB，它之后就常驻内存，在进程结束时删除，PCB是进程实体的一部分，是进程存在的唯一标志<br>2）程序段<br>3）数据段</p><p>进程的通信是指进程之间的信息交换<br>1）共享存储：基于数据结构的共享（低级）；基于存储区的共享（高级）<br>2）消息传递：直接通信方式、间接通信方式<br>3）管道通信：管道是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件</p><p>引入进程的目的，是为了更好地使多道程序并发执行，以提高资源利用率和系统吞吐量，增加并发程序<br>引入线程的目的，是为了减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能</p><p>线程：“轻量级进程”，CPU执行单元，也是程序执行流的最小单元，由线程ID、程序计数器、寄存器集合和堆栈组成，线程自己不拥有系统资源</p><p>线程是独立调度的基本单位，进程是拥有资源的基本单位。在同一进程中，线程的切换不会引起进程切换；在不同进程中进行线程切换，会引起进程切换。</p><p>线程的属性：<br>1）线程不拥有系统资源<br>2）不同的线程可以执行相同的程序<br>3）同一进程中的各个线程共享该进程所拥有的资源<br>4）线程是处理机的独立调度单位，多个线程是可以并发执行的</p><p>用户级线程：有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在<br>内核级线程：线程管理的所有工作都由内核完成<br>组合方式的多线程实现：内核级线程数目小于等于用户级线程的数目</p><p>多线程模型：<br>1）多对一模型：将多个用户级线程映射到一个内核级线程<br>2）一对一模型：每个用户级线程映射到一个内核级线程<br>3）多对多模型：将n个用户级线程映射到m个内核级线程上，要求m≤n</p><p>选择题</p><p>4.进程与程序的根本区别是（静态和动态特点）</p><p>7.一个进程的状态变化（不一定）引起另一个进程的状态变化</p><p>12.并发进程失去封闭性，是指（并发进程共享变量，其执行结果与速度有关）</p><p>16.在多对一的线程模型中，当一个多线程进程中的某个线程被阻塞后（整个进程都将阻塞）</p><p>20.全局赋值变量（正文段）、未赋值的局部变量（栈段）、函数调用实参传递值（栈段）、用malloc要求动态分配的存储区（堆段）、常量值（正文段）、进程的优先级（PCB）</p><p>22.系统动态DLL库中的系统线程，被不同的进程所调用，它们是（相同）的线程</p><p>27.在具有通道设备的单处理器系统中实现并发技术后（各进程在某一时间段内并发运行，CPU与I/O设备间并行工作）</p><p>29.对进程的管理和控制使用（原语）</p><p>41.（一个进程从运行状态变为就绪状态）必会引起进程切换</p><p>2.2 处理机调度<br>调度层次：<br>作业调度（高级调度）：选择处于后备状态的作业分配资源，发生频率最低<br>内存调度（中级调度）：选择暂时不能运行的进程调出内存，发生频率中等<br>进程调度（低级调度）：选择就绪队列中合适的进程分配处理机，发生频率最高，最基本，不可或缺</p><p>进程调度方式：<br>剥夺式调度方式，又称抢占方式：有更为重要或紧迫的进程需要使用处理，立即分配<br>非剥夺式调度方式，又称非抢占方式：有更为重要或紧迫的进程需要使用处理机，仍让当前进程继续执行</p><p>周转时间 = 作业完成时间 - 作业提交时间<br>平均周转时间 = （作业1的周转时间 + … + 作业n的周转时间）/ n<br>带权周转时间 = 作业周转时间 / 作业实际运行时间<br>平均带权周转时间 = （作业1的带权周转时间 + … + 作业n的带权周转时间）/ n</p><p>调度算法：<br>先来先服务FCFS：选择最先进入队列的，属于不可剥夺算法，对长作业比较有利，但对短作业不利，有利于CPU繁忙型作业，不利于I/O繁忙型作业<br>短作业优先SJF：选择完成时间最短的，对长作业不利，“饥饿”现象，SJF的平均等待时间、平均周转时间最少<br>优先级调度：选择优先级别最高的<br>1）非剥夺式优先级调度算法<br>2）剥夺式优先级调度算法<br>1）静态优先级<br>2）动态优先级<br>高响应比优先：选择响应比最高的，对FCFS调度和SJF算法的一种平衡，有利于短作业，克服了“饥饿”，兼顾了长作业<br>响应比Rp=（等待时间+要求服务时间）/ 要求服务时间<br>时间片轮转：总是选择就绪队列中第一个进程，但仅能运行一个时间片，主要适用于分时系统<br>多级反馈队列：时间片轮转调度算法和优先级调度算法的综合和发展，终端型作业用户：短作业优先；短批处理作业用户：周转时间较短；长批处理作业用户：不会长期得不到处理<br>1）应设置多个就绪队列，并为各个队列赋予不同的优先级<br>2）赋予各个队列中进程执行时间片的大小也各不相同，在优先级越高的队列中，每个进程的运行时间片就越小</p><p>选择题</p><p>6.若每个作业只能建立一个进程，为了照顾短作业用户，应采用（短作业优先调度算法）；为了照顾紧急作业用户，应采用（剥夺式优先级调度算法）；为了实现人机交互，应采用（时间片轮转调度算法）；而能使短作业、长作业和交互作业用户都满意，应采用（多级反馈队列调度算法）</p><p>14.（时间片轮转）调度算法是绝对可抢占的</p><p>29.满足短作业优先且不会发生饥饿现象的是（高响应比）调度算法</p><p>30.不可能导致饥饿现象的是（时间片轮转）调度算法</p><p>2.3 进程同步<br>同步：需要在某些位置上协调进程之间的工作次序而等待、传递信息所产生的制约关系<br>互斥：当一个进程进入临界区使用临界资源时，其他要求进入临界区必须等待</p><p>临界资源：一次仅允许一个进程使用的资源<br>对临界资源的访问，必须互斥地进行，在每个进程中，访问临界资源的那段代码称为临界区<br>临界资源的访问过程分为四个部分：<br>1）进入区<br>2）临界区<br>3）退出区<br>4）剩余区</p><p>原则：空闲让进、忙则等待、有限等待、让权等待</p><p>实现临界区互斥的基本方法：<br>软件实现<br>1）单标志法：违背“空闲让进”原则<br>2）双标志法先检查：违背“忙则等待”原则<br>3）双标志法后检查：会导致“饥饿”现象<br>4）皮特森算法：单标志法和双标志法后检查的结合<br>硬件实现<br>中断屏蔽法：进区关中断，出区开中断<br>硬件指令法：设立原子操作指令：TestAndSet指令、Swap指令</p><p>信号量：只能被两个标准的原语wait(S)和signal(S)来访问，利用PV操作实现互斥<br>原语是指完成某种功能且不被分割不被中断执行的操作序列。</p><p>当信号量K&gt;0时，表示还有K个相关资源可用；<br>当信号量K=0时，表示临界区外无进程等待；<br>当信号量K&lt;0时，表示临界区中有一个进程，且临界区外有|K|个进程在等待该资源；<br>当资源信号量小于0时，表示所有资源已经全部用完，而且还有进程正在等待该资源，等待的进程数就是资源量的绝对值。</p><p>管程：由一组数据以及定义在这组数据之上的对这组数据的操作组成的软件模块，这组操作能初始化并改变管程的数据和同步过程<br>管程的组成：<br>1）局部于管程的共享结构数据说明<br>2）对该数据结构进行操作的一组过程<br>3）对局部于管程的共享数据设置初始值的语句<br>管程的基本特性：<br>1）局部于管程的数据只能被局部于管程内的过程所访问<br>2）一个进程只有通过调用管程内的过程才能进入管程访问共享数据<br>3）每次仅允许一个进程在管程内执行某个内部过程</p><p>经典同步问题：<br>生产者-消费者问题<br>读者-写者问题<br>哲学家进餐问题<br>吸烟者问题</p><p>选择题</p><p>1.临界区是指进程中用于访问共享资源的那段代码</p><p>7.临界区是指并发进程访问共享变量段的（代码程序）</p><p>11.在操作系统中，要对并发进程进行同步的原因是（并发进程是异步的）</p><p>13.在操作系统红，PV操作是一种（低级进程通信原语）</p><p>14.P操作可能导致（进程阻塞）</p><p>18.在用信号量机制实现互斥时，互斥信号量的初值为（1）</p><p>19.用PV操作实现进程同步，信号量的初值为（由用户确定）</p><p>32.如果系统有n个进程，则就绪队列中进程的个数最多有（n-1）个；阻塞队列中进程的个数最多有（n）个</p><p>33.PV操作是一种低级进程通信原语，PV操作是由两个不可被中断的过程组成</p><p>2.4 死锁<br>死锁：多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进</p><p>死锁产生的原因<br>1）系统资源的竞争：只有对不可剥夺资源的竞争才可能产生死锁，对可剥夺资源的竞争是不会引起死锁的<br>2）进程推进顺序非法：请求和释放资源的顺序不当；信号量使用不当也会造成死锁<br>3）死锁产生的必要条件：<br>互斥：在一段时间内某资源仅为一个进程所占有<br>不剥夺：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走（只能是主动释放）<br>请求和保持：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有<br>循环等待：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被链中下一个进程所请求</p><p>资源分配图含圈而系统又不一定有死锁的原因是同类资源数大于1。但若系统中每类资源都只有一个资源，则资源分配图含圈就变成了系统出现死锁的充分必要条件。</p><p>资源分配策略    各种可能模式    主要优点    主要缺点<br>死锁预防    保守，宁可资源闲置    一次请求所有资源，资源剥夺，资源按序分配    适用于做突发式处理的进程，不必进行剥夺    效率低，进程初始化时间延长；剥夺次数过多；不便灵活申请新资源<br>死锁避免    是“预防”和“检测”的折中（在运行时判断是否死锁）    寻找可能的安全允许顺序    不必进行剥夺    必须知道将来的资源需求；进程不能被长时间阻塞<br>死锁检测    宽松，只要允许就分配资源    定期检查死锁是否已经发生    不延长进程初始化时间，允许对死锁进行现场处理    通过剥夺解除死锁，造成损失<br>死锁预防<br>破坏互斥条件：有些资源必须互斥使用，无法破坏互斥条件<br>破坏不剥夺条件：增加系统开销，降低吞吐量<br>破坏请求和保持条件：严重浪费系统资源，还可能导致饥饿现象<br>破坏循环等待条件：浪费系统资源，并造成编程不便</p><p>死锁避免<br>系统安全状态：能找到一个分配资源的序列能让所有进程都顺利完成<br>并非所有的不安全状态都是死锁状态，但当系统进入不安全状态后，便可能进入死锁状态；反之，只要系统处于安全状态，系统便可以避免进入死锁状态。<br>银行家算法：采用预分配策略检查分配完成时系统是否处在安全状态</p><p>死锁检测<br>1）资源分配图：圆圈代表一个进程，框代表一类资源，进程到资源的有向边叫请求边，资源到进程的边叫分配边<br>2）死锁定理：S为死锁的条件是当且仅当S状态的资源分配图是不可完全简化的；若能消去图中所有的边，则称该图是可完全简化的。</p><p>死锁解除<br>资源剥夺法：挂起某些死锁进程并抢夺它的资源，以便让其他进程继续推进<br>撤销进程法：强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源<br>进程回退法：让一个或多个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而不是被剥夺</p><p>选择题</p><p>3.一次分配所有资源的方法可以预防死锁的产生，它破坏的死锁四个必要条件中的（占有并请求）</p><p>5.死锁的避免是根据（防止系统进入不安全状态）采取措施实现的</p><p>12.属于死锁预防策略的是（B）<br>A 银行家算法（避免）<br>B 资源有序分配算法（预防）<br>C 死锁检测算法（检测）<br>D 资源分配图化简法（检测）</p><p>25.死锁定理是用于处理死锁的（检测死锁）方法</p><h3 id="第3章-内存管理"><a href="#第3章-内存管理" class="headerlink" title="第3章 内存管理"></a>第3章 内存管理</h3><p>3.1 内存管理概念<br>内存管理的功能：<br>1）内存空间的分配与回收<br>2）地址转换：逻辑地址-&gt;物理地址<br>3）内存空间的扩充：利用虚拟存储技术或自动覆盖技术，从逻辑上扩充内存<br>4）存储保护</p><p>编译、链接、装入<br>静态链接：在程序运行之前，先将各目标模块及它们所需的库函数链接成一个完整的可执行程序，以后不再拆开<br>装入时动态链接：将用户源程序编译后所得到的一组目标模块，在装入内存时，采用边装入边链接的链接方式<br>运行时动态链接：对某些目标模块的链接，是在程序执行中需要该目标模块时，才对它进行的链接，便于修改和更新，便于实现对目标模块的共享<br>绝对装入：在编译时，如果知道程序将驻留在内存的某个位置，编译程序将产生绝对地址的目标代码。绝对装入程序按照装入模块中的地址，将程序和数据装入内存。只适用于单道程序环境。<br>可重定位装入：根据内存当前情况，将装入模块装入到内存的适当位置，装入时对目标程序中指令和数据的修改过程称为重定位，地址变换通常是在装入时一次完成的，所以又称为静态重定位。静态重定位的特点是在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，在整个运行期间不能在内存中移动，也不能再申请内存空间。<br>动态运行时装入：也称动态重定位，装入程序并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到程序真正要执行时才进行。装入内存后的所有地址均为相对地址，需要一个重定位寄存器的支持。动态重定位的特点是可以将程序分配到不连续的存储空间；在程序运行之前可以只装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存；便于程序段的共享。</p><p>当装入程序将可执行代码装入内存时，必须通过地址转换将逻辑地址转换成物理地址，这个过程称为地址重定位。</p><p>内存保护<br>1）在CPU中设置一对上、下限寄存器，存放用户作业在主存中的下限和上限地址，每当CPU访问一个地址时，分别和两个寄存器的值相比，判断有无越界。<br>2）采用重定位寄存器（基址寄存器）和界地址寄存器（限长寄存器），内存管理机构动态地将逻辑地址与界地址寄存器进行比较，如果未发生地址越界，则加上重定位寄存器的值后映射成物理地址，再送交内存单元。</p><p>扩充内存<br>1）覆盖：把用户空间分成一个固定区和若干个覆盖区，将经常活跃的部分放在固定区，其余部分按调用关系分段，首先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统再将其调入覆盖区，替换覆盖区中原有的段。特点是打破了必须将一个进程的全部信息装入主存后才能运行的限制。<br>2）交换：把处于等待状态（或在CPU调度原则下被剥夺运行权利）的程序从内存移到辅存，把内存空间腾出来，这一过程叫“换出”，把准备好竞争CPU运行的程序从辅存移到内存，这一过程叫“换入2”<br>交换技术主要是在不同进程（或作业）之间进行，而覆盖则用于同一个程序或进程中。</p><p>连续分配管理方式：<br>单一连续分配：优点是简单、无外部碎片，可以采用覆盖技术；缺点是只能用于单用户、单任务的操作系统中，有内部碎片，存储器的利用率极低<br>固定分区分配——内部碎片<br>动态分区分配，可变分区分配，产生外部碎片，可用紧凑技术解决<br>1）首次适应算法：空闲分区以地址递增的次序链接，分配内存时顺序查找，找到大小能满足要求的第一个空闲分区<br>2）最佳适应算法：空闲分区以容量递增形成分区链，找到第一个能满足要求的空闲分区<br>3）最坏适应算法：又称最大适应算法，空闲分区以容量递减的次序链接，找到第一个也即是最大的分区<br>4）邻近适应算法：又称循环首次适应算法，分配内存时从上次查找结束的位置开始继续查找<br>首次适应算法可能比最佳适应算法效果好，而它们两者一定比最大适应算法效果好。</p><p>非连续分配管理方式<br>1）基本分页存储管理：不会产生外部碎片，地址空间是一维的<br>进程中的块称为页，内存中的块称为页框（或页帧），外存也以同样的单位进行划分，直接称为块。</p><p>地址结构：0~11位为页内地址，即每页大小为4KB；12 ~ 32位为页号，地址空间最多允许有2^20页</p><p>31…12    11…0<br>页号P    页内偏移量W<br>页表由页表项组成，页表项包括两部分，第一部分为页号，第二部分为物理内存中的块号，系统为每个进程建立一张页表，记录页面在内存中对应的物理块号，实现从页号到物理块号的地址映射。</p><p>基本地址变换结构（重要，限于篇幅）：<br>页面大小L，逻辑地址A，物理块号b<br>页号P=A/L，页内偏移量W=A%L<br>物理地址E=b*L+W</p><p>快表：具有并行查找能力的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程</p><p>建立多级页表的目的在于建立索引，不用浪费主存空间去存储无用的页表项，也不用盲目地顺序式查找页表项</p><p>基本分段存储管理：段内要求连续，段间不要求连续，地址空间是二维的<br>在页式系统中，逻辑地址的页号和页内偏移量对用户是透明的；在段式系统中，段号和段内偏移量必须由用户显示提供。</p><p>地址结构：段号为16位，段内偏移量为16位，则一个作业最多有2^16=65536个段，最大段长为64KB</p><p>31…16    15…0<br>段号S    段内偏移量W<br>段表用于实现从逻辑段到物理内存区的映射</p><p>地址变换结构</p><p>段页式存储管理：段表只有一个，而页表可能有多个，地址空间是二维的</p><p>地址结构：</p><p>段号S    页号P    页内偏移量W<br>选择题</p><p>1.在虚拟内存管理中，地址变换机构将逻辑地址变换为物理地址，形成该逻辑地址的阶段是（链接）</p><p>3.在使用交换技术时，如果一个进程正在（I/O操作）时，则不能交换出主存。</p><p>5.分区分配内存管理方式的主要保护措施是（界地址保护）</p><p>7.段页式存储管理中，地址映射表是（每个进程一张段表，每个段一张页表）</p><p>8.内存保护需要由（操作系统和硬件机构合作）完成，以保证进程空间不被非法访问</p><p>13.动态重定位是在作业的（执行过程）中进行的</p><p>17.分页式存储管理、固定分区式存储管理、段页式存储管理会产生内部碎片，分段式存储管理产生外部碎片</p><p>21.采用分页或分段管理后，提供给用户的物理地址空间（不能确定）</p><p>22.分页系统中的页面是为（操作系统所感知的）</p><p>24.对重定位存储管理方式，应（在整个系统中设置一个重定位寄存器）</p><p>25.采用段式存储管理时，一个程序如何分段式在（用户编程）时决定的</p><p>30.动态分区又称为可变式分区，它是在系统运行过程中（在作业装入时）动态建立的</p><p>42.在段式分配中，CPU每次从内存中取一次数据需要（2）次访问内存</p><p>43.在段页式分配中，CPU每次从内存中取一次数据需要（3）次访问内存</p><p>48.段页式存储管理汲取了页式管理和段式管理的长处，其实现原理结合了页式和段氏管理的基本思想，及（用分段方法来分配和管理用户地址空间，用分页方法来管理物理存储空间）</p><p>53.属于多级页表优点的是（D）<br>A 加快地址变换速度（错误，是减慢）<br>B 减少缺页中断次数（错误，是增加）<br>C 减少页表项所占字节数<br>D 减少页表所占的连续内存空间</p><p>3.2 虚拟内存管理<br>局部性原理：时间局部性、空间局部性<br>虚拟存储器三个特征：多次性、对换性、虚拟性</p><p>虚拟内存的实现：需要有一定的硬件支持<br>1）请求分页存储管理 2）请求分段存储管理 3）请求段页式存储管理</p><p>页面置换算法：<br>1）最佳置换OPT：被淘汰页面是以后永不使用的，或者是在最长时间内不再被访问的页面，该算法无法实现<br>2）先进先出FIFO：优先淘汰最早进入内存的页面，即在内存中驻留时间最久的页面，当所分配的物理块数增大而页故障数不减反增的异常现象称为Belady异常，LRU和OPT不会出现该异常<br>3）最近最久未使用LRU：认为过去一段时间内未访问过的页面，在最近的将来可能也不会被访问；需要寄存器和栈的硬件支持，是堆栈类算法，不可能出现Belady异常<br>4）时钟CLOCK置换算法：又称为最近未用NRU算法<br>改进型的CLOCK算法：<br>1）从指针的当前位置开始，扫描帧缓冲区，在这次扫描过程中，对使用位不做任何修改，选择遇到的第一个帧（u=0，m=0）用于替换<br>2）如果第1步失败，则重新扫描，查找（u=0，m=1）的帧。选择遇到的第一个这样的帧用于替换。在这个扫描过程中，对每个跳过的帧，把它的使用位设置成0（u=0）<br>3）如果第2步失败，指针将回到它的最初位置，并且集合中所有帧的使用位均为0，重复第1步，并且如果有必要，重复第2步，这样就可以找到供替换的帧。<br>改进型的CLOCK算法优于简单CLOCK算法之处在于替换时首选没有变化的页。</p><p>页面分配策略：<br>1）固定分配局部置换<br>2）可变分配全局置换<br>3）可变分配局部置换</p><p>调入页面的时机：<br>1）预调页策略<br>2）请求调页策略<br>预调页实际上就是运行前的调入，请求调页实际上就是运行期间调入。</p><p>请求分页系统中的外存分为两部分：用于存放文件的文件区和用于存放对换页面的对换区。对换区通常是采用连续分配方式，而文件区采用离散分配方式，故对换区的磁盘I/O速度比文件区的更快<br>1）系统拥有足够的对换区空间：可以全部从对换区调入所需页面<br>2）系统缺少足够的对换区空间：凡不会被修改的文件都直接从文件区调入；而当换出这些页面时，由于它们未被修改而不必再将它们换出。但对于那些可能被修改的部分，换出时须调到对换区，以后需要时再从对换区调入<br>3）UNIX方式：未运行过的页面，都应从文件区调入，曾经运行过但又被换出的页面，由于是被放在对换区，因此下次调入时应从对换区调入</p><p>抖动（颠簸）：刚刚换出的页面马上又要换入主存，刚刚换入的页面马上就要换出主存，频繁的页面调度行为。如果一个进程在换页上的时间多于执行时间，那么这个进程就在颠簸。<br>频繁的发生缺页中断（抖动），其主要原因是某个进程频繁访问的页面数目高于可用的物理页帧数目。</p><p><strong>工作集（驻留集）</strong>是指在某段时间间隔内，进程要访问的页面集合。经常被使用的页面需要在工作集中，而长期不被使用的页面要从工作集中被丢弃。<br>工作集模型的原理是：让操作系统跟踪每个进程的工作集，并为进程分配大于其工作集的物理块。</p><p>选择题</p><p>1.下列关于虚拟存储器的叙述中，正确的是（虚拟存储只能基于非连续分配技术）</p><p>2.请求分页存储管理中，若把页面尺寸增大一倍而且可容纳的最大页数不变，则在程序顺序执行时缺页中断次数会（减少）</p><p>3.进程在执行中发生了缺页中断，经操作系统处理后，应让其执行（被中断的那一条）指令</p><p>9.（不必将作业全部装入内存）是请求分页存储管理方式和基本分页存储管理方式的区别</p><p>14.虚拟存储器的最大容量（由计算机的地址结构决定）</p><p>16.引起LRU算法的实现耗费高的原因是（需要对所有的页进行排序）</p><p>20.使用（覆盖、交换）方法可以实现虚拟存储</p><p>3.3 本章疑难点<br>分页管理    分段管理<br>目的    页是信息的物理单位，分页是为实现离散分配方式，提高内存的利用率    段是信息的逻辑单位，是为了能更好地满足用户的需要<br>长度    页的大小固定且由系统决定，分为页号和页内地址，在系统中只能有一种大小的页面    段的长度不固定，决定于用户所编写的程序<br>地址空间    一维的，即单一的线性地址空间，程序员只需利用一个记忆符，即可表示一个地址    二维的，需给出段名和段内地址<br>碎片    有内部碎片无外部碎片    有外部碎片无内部碎片<br>共享和动态链接    不容易实现    容易实现</p><h3 id="第4章-文件管理"><a href="#第4章-文件管理" class="headerlink" title="第4章 文件管理"></a>第4章 文件管理</h3><p>4.1 文件系统基础<br>文件是以计算机硬盘为载体存储在计算机上的信息集合。在系统运行时，计算机以进程为基本单位进行资源的调度和分配，而在用户进行的输入、输出中，则以文件为基本单位。</p><p>无结构文件：又称流式文件，将数据按顺序组织成记录并积累保存<br>有结构文件：又称记录式文件，由一组相似记录组成</p><p>文件的属性：<br>1）名称：唯一<br>2）标识符：唯一标签，对人不可读的一种内部名称<br>3）类型<br>4）位置<br>5）大小<br>6）保护<br>7）时间、日期和用户标识<br>所有文件的信息都保存在目录结构中，而目录结构保存在外存上，目录条目包括文件名称及其唯一标识符。</p><p>文件的基本操作：<br>1）创建文件<br>2）写文件<br>3）读文件<br>4）文件重定位（文件寻址）<br>5）删除文件<br>6）截断文件</p><p>系统调用open通常返回一个指向打开文件表中的一个条目的指针，通过使用该指针（而非文件名）进行所有I/O操作。在open调用完成之后，操作系统对该文件的任何操作，都不再需要文件名，只需要open调用返回的指针。</p><p>无结构文件：又称流式文件，将数据按顺序组织成记录并积累保存，如源程序文件、目标代码文件等<br>有结构文件：又称记录式文件，由一组相似记录组成<br>1）顺序文件<br>串结构：记录之间的顺序与关键字无关<br>顺序结构：记录之间的顺序与关键字有关<br>2）索引文件：为变长文件建立索引表，提高查找速度，变长记录文件只能顺序查找，索引表本身是定长记录的顺序文件<br>3）索引顺序文件：顺序文件和索引文件的结合<br>4）直接文件或散列文件：通过哈希函数直接决定记录的物理地址，没有顺序的特性</p><p>文件控制块：用来存放控制文件需要的各种信息的数据结构，以实现“按名存取”。FCB的有序集合称为文件目录，一个FCB就是一个文件目录项。为了创建一个新文件，系统将分配一个FCB并存放在文件目录中，成为目录项。<br>FCB主要包含以下信息：基本信息、存取控制信息、使用信息</p><p>单级目录结构：在整个文件系统中只建立一张目录表，每个文件占一个目录项<br>两级目录结构：将分件目录分成主文件目录和用户文件目录<br>多级目录结构（树形目录结构）：可以很方便地对文件进行分类<br>无环图目录结构：实现文件共享</p><p>文件共享<br>1）基于索引结点的共享方式（硬链接）<br>2）利用符号链实现文件共享（软链接）<br>硬链接和软链接都是文件系统中的静态共享方法，硬链接的查找速度会比软链接快。</p><p>文件保护<br>1）口令保护：通过口令访问文件，时间和空间开销不多，缺点是口令直接存在系统内部，不够安全<br>2）加密保护：对文件进行加密处理，节省了存储空间，不过编码和译码要花费一定时间<br>3）访问控制：根据访问者的身份进行限制</p><p>选择题</p><p>1.设置当前工作目录的主要目的是（加快文件的检索速度）</p><p>3.从用户的观点看，操作系统中引入文件系统的目的是（实现对文件的按名存取）</p><p>5.打开文件操作的主要工作是（把指定文件的目录复制到内存指定的区域）</p><p>6.UNIX操作系统中，输入/输出设备看做是（特殊文件）</p><p>13.用户在删除某文件的过程中，操作系统不可能执行的操作是（删除此文件所在的目录）</p><p>17.文件系统采用多级目录结构的目的是（解决命名冲突）</p><p>24.对一个文件的访问，常由（用户访问权限和文件属性）共同限制</p><p>4.2 文件系统实现<br>目录实现<br>1）线性列表：使用存储文件名和数据块指针的线性表<br>无序：查找文件较慢，新建文件较快<br>有序：查找文件较快，新建文件较慢<br>2）哈希表：根据文件名得到一个值，并返回一个指向线性列表中元素的指针<br>查找、新建速度都较快，要处理冲突</p><p>文件实现<br>文件分配方式：<br>1）连续分配：在磁盘上连续存放文件，寻道数和寻道时间最小，支持顺序访问和直接访问<br>优点：实现简单、存取速度快<br>缺点：文件长度不宜动态增加，会产生外部碎片，只适用于长度固定的文件<br>2）链接分配：采取离散分配的方式，消除了外部碎片，提高磁盘空间的利用率<br>隐式：采用类似链表的结构，无法直接访问盘块，只能通过指针顺序访问文件<br>显式：把隐式文件中的指针单独抽离出来，存放在内存的一张链接表（文件分配表）中，该表在整个磁盘仅设置一张，每个表项中存放对应块的下一块链接指针，即下一个盘块号<br>3）索引分配：每个文件所有的盘块号都集中存放，建立索引表，支持直接访问，且没有外部碎片问题</p><p>访问第n个记录    优点    缺点<br>顺序分配    需访问磁盘1次    速度快，可根据文件起始地址及记录长度进行随机访问    要求连续存储空间，会产生外部碎片，不利于动态扩展<br>链接分配    需访问磁盘n次    可以解决外部碎片问题，提高外存空间利用率，动态增长较方便    只能按照文件的指针链顺序访问<br>索引分配    m级需访问磁盘m+1次    可以随机访问，易于文件的增删    索引表增加存储空间的开销，对文件系统效率影响较大<br>存储空间管理：<br>空闲表：属于连续分配方式，把所有空闲块组织成表<br>空闲链表法：把所有空闲块组织成链表<br>位示图：利用二进制的每位记录空闲块<br>盘块的分配：盘块号b=n(i-1)+j<br>盘块的回收：i=(b-1) DIV n + 1；j=(b-1) MOD n + 1<br>成组链接：空闲表和空闲链表的结合，适合大的文件系统</p><p>选择题</p><p>1.适合随机访问且易于文件扩展的是（索引结构）</p><p>5.为支持CD-ROM中视频文件的快速随机播放，播放性能最好的文件数据块组织方式是（连续结构）</p><p>4.3 磁盘组织与管理<br>磁盘地址结构：柱面号、盘面号、扇区号</p><p>寻道时间：将磁头移动到指定磁道所需要的时间，Ts=m*n+s<br>延迟时间：磁头定位到某一磁道的扇区所需要的时间，Tr=1/(2r)<br>传输时间：从磁盘读出或向磁盘写入数据所经历的时间，Tt=b/(rN)<br>启动时间（一般忽略）：控制器的启动时间</p><p>调度算法:<br>1）先来先服务：根据进程请求访问磁盘的先后顺序进行调度<br>2）最短寻找时间优先：选择当前磁头所在磁道距离最近的磁道，会产生“饥饿”现象<br>3）扫描算法：，又称电梯调度，在磁头当前移动方向上选择与当前磁头所在磁道距离最近的请求<br>4）循环扫描：在扫描算法的基础上规定磁头单向移动来提供服务，回返时直接快速移动至起始端而不服务任何请求</p><p>优点    缺点<br>FCFS算法    公平、简单    平均寻道距离大，仅应用在磁盘I/O较少的场合<br>SSTF算法    性能比FCFS好    不能保证平均寻道时间最短，可能出现“饥饿”现象<br>SCAN算法    寻道性能较好，可避免“饥饿”现象    不利于远离磁头一端的访问请求<br>C-SCAN算法    消除了对两端磁道请求的不公平    -<br>磁盘管理：<br>1）磁盘初始化：对磁盘进行低级格式化和逻辑格式化<br>低级格式化（物理分区）：在磁盘存储数据之前，必须分成扇区以便磁盘控制器能进行读和写操作<br>逻辑格式化：对物理分区进行逻辑格式化，操作系统将初始的文件系统数据结构存储到磁盘上，这些数据结构包括空闲和已分配的空间以及一个初始为空的目录<br>2）引导块：存放自举程序<br>3）坏块：对于损坏扇区的处理，使系统不去使用坏块，坏块属于硬件故障，操作系统是不能修复的</p><p>选择题</p><p>1.磁盘是可共享设备，但在每一时刻（至多能由一个）作业启动它</p><p>2.用磁带做文件存储介质时，文件只能组织成（顺序文件）</p><p>3.既可以随机访问又可以顺序访问的有（I、III、IV）<br>I. 光盘 II. 磁带 III. U盘 IV. 磁盘</p><p>9.（最短寻找时间优先）可能出现“饥饿”现象</p><p>18.下列选项中，磁盘逻辑格式化程序所做的工作是（II、IV）<br>I. 对磁盘进行分区<br>II. 建立文件系统的根目录<br>III. 确定磁盘扇区校验码所占位数<br>IV. 对保存空间磁盘块信息的数据结构进行初始化</p><h3 id="第5章-输入-输出（I-O）管理"><a href="#第5章-输入-输出（I-O）管理" class="headerlink" title="第5章 输入/输出（I/O）管理"></a>第5章 输入/输出（I/O）管理</h3><p>5.1 I/O管理概述<br>设备分类<br>按传输速率分：<br>低速：如键盘、鼠标<br>中速：如行式打印机、激光打印机<br>高速：如磁带机、磁盘机、光盘机<br>按信息交换单位分：<br>块设备：如磁盘<br>字符设备：如键盘、打印机</p><p>I/O控制方式<br>程序直接控制：程序直接对设备循环测试<br>中断驱动：引入中断机制，当设备准备完成时发生中断<br>DMA：在I/O设备与主存之间开辟直接数据通路，彻底解放CPU<br>1）基本单位是数据块<br>2）所传送的数据，是从设备直接送入内存的，或者相反<br>3）仅在传送一个或多个数据块的开始和结束时，才需CPU干预，整块数据的传送是在DMA控制器的控制下完成的<br>中断驱动方式数据传送是在中断处理时由CPU控制完成的，而DMA控制方式则是在DMA控制器的控制下完成的。<br>通道控制：引入专门的I/O处理机进行管理，可以实现CPU、通道和I/O设备三者的并行操作<br>I/O通道与一般处理机的区别是：通道指令的类型单一，没有自己的内存，通道所执行的通道程序是放在主机的内存中的，也就是说通道与CPU共享内存。<br>I/O通道与DMA方式的区别是：DMA方式需要CPU来控制传输的数据块大小、传输的内存位置，而通道方式中这些信息是由通道控制的。另外，每个DMA控制器对应一台设备与内存传递数据，而一个通道可以控制多台设备与内存的数据交换。</p><p>I/O子系统层次结构：<br>用户层I/O软件：实现与用户交互的接口<br>设备独立性软件：实现用户程序与设备驱动器的统一接口、设备命令、设备保护以及设备分配与释放<br>设备驱动程序：与硬件直接相关，负责具体实现系统对设备发出的操作指令<br>中断处理程序：用于处理中断相关事项<br>硬件设备：包括一个机械部件（设备本身）和一个电子部件（控制器）</p><p>选择题</p><p>3.磁盘设备的I/O控制主要是采取（DMA）方式</p><p>4.为了便于上层软件的编制，设备控制器通常需要提供（控制寄存器、状态寄存器和控制命令）</p><p>5.在设备控制器中用于实现对设备控制功能的是（I/O逻辑（即设备控制器））</p><p>6.在设备管理中，设备映射表（DMT）的作用是（建立逻辑设备与物理设备的对应关系）</p><p>7.DMA方式是在（I/O设备和主存）之间建立一条直接数据通路。</p><p>9.在操作系统中，（通道技术）指的是一种硬件技术</p><p>12.（字节多路通道）用作连接大量的低速后中速I/O设备</p><p>13.（及时性）不是设备分配中应考虑的问题</p><p>14.将系统中的每一台设备按某种原则统一进行的编号，这些编号作为区分硬件和识别设备的代号，该编号称为设备的（绝对号）</p><p>15.通道控制设备控制器、设备控制器控制设备工作</p><p>22.用户程序发出磁盘I/O请求后，系统的正确处理流程是（用户程序-&gt;系统调用处理程序-&gt;设备驱动程序-&gt;中断处理程序）</p><p>23.操作系统的I/O子系统通常由四个层次组成，每一层明确定义了与邻近层次的接口，其合理的层次组织排列顺序是（用户级I/O软件、设备无关软件、设备驱动程序、中断处理程序）</p><p>5.2 I/O核心子系统<br>I/O调度：确定一个好的顺序来执行I/O请求</p><p>磁盘高速缓存：在逻辑上属于磁盘，物理上则是驻留在内存中的盘块，分为两种形式：<br>1）在内存中开辟一个单独的存储空间作为磁盘高速缓存<br>2）把未利用的内存空间作为一个缓冲池，供请求分页系统和磁盘I/O分时共享</p><p>引入缓冲区的目的：<br>1）缓和CPU与I/O设备间速度不匹配的矛盾<br>2）减少对CPU的中断频率，放宽对CPU中断响应时间的限制<br>3）解决基本数据单元大小（即数据粒度）不匹配的问题<br>4）提高CPU与I/O设备之间的并行性</p><p>单缓冲：先把被交换数据写入缓冲区，然后需要数据的设备或处理机从缓冲区取走数据，处理C，输入T，传送M，用时Max(C, T)+M<br>双缓冲：用时Max(C+M, T)<br>循环缓冲<br>缓冲池</p><p>高速缓存和缓冲区的区别：<br>高速缓存：存放的是低速设备上的某些数据的复制数据，也就是高速缓存上有的低速设备上面必然有；如果高速设备要访问的数据不在高速缓存中，高速设备就需要访问低速设备<br>缓冲区：存放的是低速设备给高速设备的数据（或者相反），而这些数据在低速设备（或高速设备）不一定有备份，这些数据再从缓冲区传送到高速设备（或低速设备）；高速设备和低速设备的通信要经过缓冲区，高速设备永远不会直接去访问低速设备</p><p>设备的分配与回收<br>设备分配是指根据用户的I/O请求分配所需的设备。<br>1）独占式使用设备：设备被使用时不再允许其他进程使用该设备<br>2）分时式共享使用设备<br>3）SPOOLing技术：即假脱机I/O技术，实质上就是对I/O操作进行批处理，是一种以空间换时间的技术，将独占设备改造为共享设备<br>分配的总原则：即要充分发挥设备的使用效率，又要避免造成进程死锁，还要将用户程序和具体设备隔离开<br>分配方式<br>静态分配：在用户作业开始执行前，由系统一次性分配该作业所要求的全部设备<br>动态分配：在进程执行过程中根据执行需要进行分配</p><p>设备分配的数据结构<br>设备控制表DCT、控制器控制表COCT、通道控制表CHCT、系统设备表SDT<br>设备控制表DCT和控制器控制表COCT是一一对应的关系；<br>通道控制表CHCT和控制器控制表COCT是一对多的关系。<br>整个系统只有一张系统设备表SDT</p><p>设备分配的策略<br>1）静态分配：主要用于对独占设备的分配，由系统一次性分配该作业所要求的全部设备、控制器，并不符合分配的总原则<br>2）动态分配：在进程执行过程中根据执行需要进行<br>设备分配算法：现请求先分配、优先级高者优先<br>设备分配的安全性<br>1）安全分配方式：每当进程发出I/O请求后进入阻塞状态，直到I/O操作完成时才被唤醒，CPU和I/O设备串行工作<br>2）不安全分配方式：一个进程可同时操作多个设备，从而使进程推进迅速，但有可能产生死锁</p><p>逻辑设备名到物理设备名的映射<br>1）在整个系统中只设置一张逻辑设备表LUT<br>2）为每个用户设置一张逻辑设备表LUT</p><p>SPOOLing技术（假脱机技术）：外部设备同时联机操作，又称为假脱机输入/输出操作，是操作系统中采用的一项将独占设备改造成共享设备的技术</p><p>选择题</p><p>5.程序员利用系统调用打开I/O设备时，通常使用的设备标识是（逻辑设备名）</p><p>8.为了使并发进程能有效地进行输入和输出，最好采用（缓冲池）结构的缓冲技术</p><p>9.在采用SPOOLing 技术的系统中，用户的打印结果首先被送到（磁盘固定区域）</p><p>10.缓冲技术中的缓冲池在（主存）中</p><p>13.如果I/O所花费的时间比CPU的处理时间短得多，则缓冲区（几乎无效）</p><p>18.提高单机资源利用率的关键技术时（多道程序设计技术）</p><p>19.虚拟设备是靠（SPOOLing）技术来实现的</p><p>20.SPOOLing技术的主要目的是（提高独占设备的利用率）</p><p>21.采用SPOOLing技术的计算机系统，外围计算机需要（0台）</p><p>22.SPOOLing系统由下列程序组成（预输入程序、井管理程序和缓输出程序）</p><p>23.在SPOOLing系统中，用户进程实际分配到的是（外存区，即虚拟设备）</p><p>24.SPOOLing系统中的用户程序可以随时将输出数据送到输出井中，待输出设备空闲时再有SPOOLing系统完成数据的输出操作</p><p>26.SPOOLing技术时操作系统中采用的以空间换取时间的技术</p><p>29.在采用SPOOLing技术的系统中，用户的打印数据首先被送到（磁盘固定区域）</p><p>31.在系统内存中设置磁盘缓冲区的主要目的是（减少磁盘I/O次数）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/SYSU/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/SYSU/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h3 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h3><h4 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h4><ol><li>线性表的定义和基本操作</li><li>线性表的实现<ol><li>顺序存储</li><li>链式存储</li><li>线性表的应用</li></ol></li></ol><h4 id="栈、队列和数组"><a href="#栈、队列和数组" class="headerlink" title="栈、队列和数组"></a><strong>栈、队列和数组</strong></h4><ol><li>栈和队列的基本概念</li><li>栈和队列的顺序存储结构</li><li>栈和队列的链式存储结构</li><li>栈和队列的应用</li><li>特殊矩阵的压缩存储</li></ol><h4 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h4><ol><li>树的基本概念</li><li>二叉树<ol><li>二叉树的定义及其主要特性</li><li>二叉树的顺序存储结构和链式结构</li><li>二叉树的遍历</li><li>线索二叉树的基本概念和构造</li></ol></li><li>树、森林<ol><li>树的存储结构</li><li>森林与二叉树的转换</li><li>树和森林的遍历</li></ol></li><li>树与二叉树的应用<ol><li>二叉排序树</li><li>平衡二叉树</li><li>哈夫曼树和哈夫曼编码</li></ol></li></ol><h4 id="图"><a href="#图" class="headerlink" title="图"></a>图</h4><ol><li>图的基本概念</li><li>图的存储及基本操作<ol><li>邻接矩阵法</li><li>邻接表法</li><li>邻接多重表、十字链表</li></ol></li><li>图的遍历<ol><li>深度优先搜索</li><li>广度优先搜索</li></ol></li><li>图的基本应用<ol><li>最小（代价）生成树</li><li>最短路径</li><li>拓扑排序</li><li>关键路径</li></ol></li></ol><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4><ol><li>查找的基本概念</li><li>顺序查找法</li><li>分块查找法</li><li>折半查找法</li><li>B树及其基本操作、B+树的基本概念</li><li>散列（Hash）表</li><li>字符串模式匹配</li><li>查找算法的分析及应用</li></ol><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><ol><li>排序的基本概念</li><li>插入排序<ol><li>直接插入排序</li><li>折半插入排序</li></ol></li><li>冒泡排序</li><li>简单选择排序</li><li>希尔排序</li><li>快速排序</li><li>堆排序</li><li>二路归并排序</li><li>基数排序</li><li>外部排序</li><li>各种排序算法的比较</li><li>排序算法的应用</li></ol><h3 id="第1章-绪论"><a href="#第1章-绪论" class="headerlink" title="第1章 绪论"></a>第1章 绪论</h3><h4 id="1-1-数据结构的基本概念"><a href="#1-1-数据结构的基本概念" class="headerlink" title="1.1 数据结构的基本概念"></a>1.1 数据结构的基本概念</h4><h5 id="数据和结构的定义"><a href="#数据和结构的定义" class="headerlink" title="数据和结构的定义"></a>数据和结构的定义</h5><ul><li><p><strong>数据项</strong>是构成数据元素的不可分割的最小单位</p></li><li><p><strong>数据元素</strong>是数据的基本单位，一个数据元素可由若干个数据项完成</p></li><li><p><strong>数据对象</strong>是具有相同性质的数据元素的集合，是数据的一个子集。</p></li><li><p><strong>数据类型</strong>是一个值的集合和定义在此集合上一组操作的总称。</p></li><li><p><strong>数据结构</strong>是指相互之间存在的一种或多种特定关系的数据元素</p></li><li><p><strong>原子类型</strong>：其值不可再分的数据类型</p></li><li><p><strong>结构类型</strong>：其值可以再分解为若干成分（分量）的数据类型</p></li><li><p><strong>抽象数据类型</strong>：抽象数据组织和与之相关的操作</p></li><li><p><strong>抽象数据类型（ADT）</strong>是指一个数学模型以及定义在该模型上的一组操作。抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。通常用（数据对象、数据关系、基本操作集）这样的三元组来表示。</p></li></ul><h5 id="数据结构的三要素"><a href="#数据结构的三要素" class="headerlink" title="数据结构的三要素"></a>数据结构的三要素</h5><ul><li><strong>逻辑结构</strong>是指数据元素之间的逻辑关系，即从逻辑关系上描述数据，独立于计算机，可以看作是从具体问题抽象出来的数学模型。分为线性结构和非线性结构。<ul><li><strong>线性结构</strong>：结点之间存在一对一的关系，例如线性表、栈、队列。</li><li><strong>非线性结构</strong>：结点之间存在一对多或多对多的关系。又可以细分为树形结构和图形结构。每个结点最多只有一个<ul><li>树形结构：结点之间存在一对多的关系，每个结点最多只有一个前驱，但可以有多个后继，可以有多个终端结点</li><li>图形结构：结点之间存在或多对多的关系，每个结点的前驱和后继的个数是任意的。可以没有开始结点或终端结点</li></ul></li></ul></li><li><strong>存储结构（物理结构）</strong>是指数据结构在计算机中的表示（又称映像），是逻辑结构在计算机中的实现，包括数据元素的表示和关系的表示，依赖于计算机语言，分为：<ul><li><strong>顺序存储</strong>（随机存取）：在计算机中用一组地址连续的存储单元依次存储线性表的各个数据元素。相邻数据元素的存放地址也相 。<ul><li>优点：检索速度快</li><li>缺点：增加了附加的索引表,会占用较多的存储空间</li></ul></li><li><strong>散列存储</strong>（检索、增加、删除快）：散列存储，又称hash存储，是一种力图将数据元素的存储位置与关键码之间建立确定对应关系的查找技术。其中散列所形成的存储结构叫 <strong>散列表（又叫哈希表）</strong> ，因此哈希表也是一种存储结构</li></ul></li><li><strong>数据的操作（或算法）</strong>：包括算法的定义和实现。算法的定义是针对逻辑结构的，指出算法的功能；算法的实现是针对存储结构的，指出算法的具体操作步骤。</li></ul><h5 id="真题"><a href="#真题" class="headerlink" title="真题"></a>真题</h5><p>1.可以用（抽象数据类型）定义一个完整的数据结构。</p><p>3.以下属于逻辑结构的是（有序表）<br>A 顺序表 B 哈希表 C 有序表 D 单链表</p><p>4.以下与数据的存储结构无关的术语是（栈）<br>A 循环队列 B 链表 C 哈希表 D 栈</p><p>6.在存储数据时，通常不仅要存储各数据元素的值，还要存储（数据元素之间的关系）</p><p>7.链式存储设计时，结点内的存储单元地址（一定连续），不同结点间可以（不连续）</p><h4 id="1-2-算法和算法评价"><a href="#1-2-算法和算法评价" class="headerlink" title="1.2 算法和算法评价"></a>1.2 算法和算法评价</h4><p>算法是对特定问题求解步骤的一种描述，有五个特性：有穷性、确定性、可行性、输入、输出。一个算法有零个或多个的输入，有一个或多个的输出。</p><p>时间复杂度是指该语句在算法中被重复执行的次数，不仅依赖于问题的规模n，也取决于待输入数据的性质。O常忽略低阶项和常系数。</p><p>空间复杂度定义为该算法所耗费的存储空间。算法原地工作是指算法所需辅助空间是常量，即O(1)。</p><h3 id="第2章-线性表"><a href="#第2章-线性表" class="headerlink" title="第2章 线性表"></a>第2章 线性表</h3><p>2.1 线性表的定义和基本操作<br>线性表是具有相同数据类型的n个数据元素的有限序列。除第一个元素外，每个元素有且仅有一个直接前驱；除最后一个元素外，每个元素有且仅有一个直接后继。</p><p>注意：线性表是一种逻辑结构，表示元素之间一对一的相邻关系。顺序表和链表是指存储结构。两者属于不同层面的概念，因此不要混淆。</p><p>选择题</p><p>2.以下（由100个字符组成的序列）是一个线性表。<br>A 由n个实数组成的集合 B 由100个字符组成的序列<br>C 所有整数组成的序列（无穷） D 邻接表（存储结构）</p><p>2.2 线性表的顺序表示<br>线性表的顺序存储又称为顺序表。它是用一组地址连续的存储单元，依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。</p><p>顺序表的特点是表中元素的逻辑顺序与其物理顺序相同。<br>顺序表最主要的特点是随机访问（随机存取），即通过首地址和元素序号可以在O(1)的时间内找到指定的元素。但插入和删除操作需要移动大量元素。<br>顺序表的存储密度高，每个结点只存储数据元素。</p><p>顺序表插入操作：<br>最好情况：在表尾插入，元素后移语句不执行，时间复杂度为O(1)<br>最坏情况：在表头插入，元素后移语句将执行n次，时间复杂度为O(n)<br>平均情况：平均时间复杂度为O(n)</p><p>顺序表删除操作：<br>最好情况：删除表尾元素，无需移动元素，时间复杂度为O(1)<br>最坏情况：删除表头元素，需要移动除第一个元素外的所有元素，时间复杂度为O(n)<br>平均情况：平均时间复杂度为O(n)</p><p>顺序表按值查找（顺序查找）：<br>最好情况：查找的元素就在表头，仅需比较一次，时间复杂度为O(1)<br>最坏情况：查找的元素在表尾或不存在时，需要比较n次，时间复杂度为O(n)<br>平均情况：平均时间复杂度为O(n)</p><p>选择题</p><p>4.若线性表最常用的操作是存取第i个元素及其前驱和后继元素的值，为了提高效率，应采用（顺序表）的存储方式。</p><p>5.一个线性表最常用的操作是存取任一指定序号的元素和在最后进行插入删除操作，则利用（顺序表）存储方式可以节省时间。</p><p>10.若长度为n的非空线性表采用顺序存储结构，在表的第i个位置插入一个数据元素，i的合法值应该是（1 ≤ i ≤ n+1）</p><p>2.3 线性表的链式表示<br>链式存储线性表时，不需要使用地址连续的存储单元，即它不要求逻辑上相邻的两个元素在物理位置上也相邻，对线性表的插入和删除不需要移动元素，只需要修改指针。</p><p>单链表是非随机存储的存储结构，即不能直接找到表中某个特定的结点。</p><p>头结点和头指针的区分：不管带不带头结点，头指针始终指向链表的第一个结点，而头结点是带头结点链表中的第一个结点，结点内通常不存储信息。</p><p>采用头插法建立单链表：从一个空表开始，生成新结点，并将读取到的数据存放在新结点的数据域中，然后将新结点插入到当前链表的表头，即头结点之后。<br>读入数据的顺序与生成的链表中元素的顺序是相反的。<br>每个结点插入的时间为O(1)，设单链表长为n，则总的时间复杂度为O(n)。</p><p>采用尾插法建立单链表：将新结点插入到当前链表的表尾上，为此必须增加一个尾指针r，使其始终指向当前链表的尾结点。<br>时间复杂度和头插法相同。</p><p>按序号查找结点值：在单链表中从第一个结点出发，顺指针next域逐个往下搜索，直到找到第i个结点为止，否则返回最后一个结点指针域NULL。<br>时间复杂度为O(n)。</p><p>按值查找表结点：从单链表第一个结点出发，由前往后依次比较表中各结点数据域的值，若某结点数据域的值等于给定值e，则返回该结点的指针，否则返回NULL。<br>时间复杂度为O(n)。</p><p>插入结点操作：先检查插入位置的合法性，然后找到待插入位置的前驱结点，即第i-1个结点，再在其后插入新结点。<br>主要的时间开销在于查找第i-1个元素，时间复杂度为O(n)。若是在给定的结点后面插入新结点，则时间复杂度仅为O(1)。</p><p>删除结点操作：先检查删除位置的合法性，然后找到待删除位置的前驱结点，即第i-1个结点，再将其删除。<br>时间复杂度为O(n)。</p><p>双链表结点中有两个指针prior和next，分别指向其前驱结点和后继结点。双链表中执行按值查找和按位查找的操作和单链表相同，但双链表插入、删除操作的时间复杂度仅为O(1)。</p><p>循环单链表和单链表的区别在于，表中最后一个结点的指针不是NULL，而改为指向头结点，从而整个链表形成一个环。故表中没有指针域为NULL的结点。<br>循环双链表 L中，某结点*p为尾结点时，p-&gt;next=L；当循环双链表为空表时，其头结点的prior域和next域都等于L。</p><p>静态链表是借助数组来描述线性表的链式存储结构，结点也有数据域data和指针域next，这里的指针是结点的相对地址（数组下标），又称为游标。</p><p>顺序表和链表的比较：</p><p>存取方式：顺序表可以顺序存取，也可以随机存取，链表只能从表头顺序存取元素。<br>逻辑结构与物理结构：采用顺序存储时，逻辑上相邻的元素，其对应的物理存储位置也相邻。而采用链式存储时，逻辑上相邻的元素，其物理存储位置则不一定相邻。<br>查找、插入和删除操作：对于按值查找，当顺序表在无序的情况下，两者的时间复杂度均为O(n)；而当顺序表有序时，可采用折半查找，时间复杂度为O(logn)。对于按序号查找，顺序表支持随机访问，时间复杂度仅为O(1)，而链表的平均时间复杂度为O(n)。链表插入、删除较优，只需修改相关结点的指针域即可。<br>空间分配：链式存储的结点空间只在需要的时候申请分配。<br>通常较稳定的线性表选择顺序存储，而频繁做插入、删除操作的线性表（即动态性较强）宜选择链式存储。<br>选择题</p><p>2.对于一个线性表即要求能够进行较快速地插入和删除，又要求存储结构能反映数据之间的逻辑关系，则应该用链式存储方式。</p><p>4.下列关于线性表说法正确的是（D）<br>I. 顺序存储方式只能用于存储线性结构（同样适合图和树的存储，如满二叉树的顺序存储）<br>II. 取线性表的第i个元素的时间与i的大小有关（无关，顺序存储）<br>III. 静态链表需要分配较大的连续空间，插入和删除不需要移动元素<br>IV. 在一个长度为n的有序单链表中插入一个新结点并仍保持有序的时间复杂度为O(n)<br>V. 若用单链表来表示队列，则应该选用带尾指针的循环链表<br>A I、II B I、III、IV、V C IV、V D III、IV、V</p><p>7.给定有n个元素的一维数组，建立一个有序单链表的最低时间复杂度是（O(nlogn)）</p><p>8.将长度为n的单链表链接在长度为m的单链表后面，其算法的时间复杂度为O(m)</p><p>9.单链表中，增加一个头结点的目的是为了（方便运算的实现）。</p><p>10.在一个长度为n的带头结点的单链表h上，设有尾指针r，则执行（删除单链表中最后一个元素）操作与链表的表长有关。</p><p>11.对于一个头指针为head的带头结点的单链表，判定该表为空表的条件是（head-&gt;next==NULL）；对于不带头结点的单链表，则判定空表的条件是（head == NULL）</p><p>13.某线性表中最常见的操作是在最后一个元素之后插入一个元素和删除第一个元素，则采用（仅有尾指针的单循环链表）存储方式最省时间。</p><p>18.与单链表相比，双链表的优点之一是（访问前后相邻结点更灵活）。</p><p>19.带空结点的双循环链表L为空的条件是（L-&gt;prior==L &amp;&amp; L-&gt;next == L）</p><p>20.一个链表最常用的操作是在末尾插入结点和删除结点，则选用（带头结点的双循环链表）最节省时间。</p><p>21.设对n个元素的线性表的运算只有4种：删除第一个元素；删除最后一个元素；在第一个元素之前插入新元素；在最后一个元素之后插入新元素，则最好使用（只有头结点指针没有尾结点指针的循环双链表）。</p><p>22.一个链表最常用的操作是在最后一个元素之后插入一个元素和删除第一个元素，则选用（不带头结点且有尾指针的单循环链表）最节省时间。</p><p>25.需要分配较大的空间，插入和删除不需要移动元素的线性表，其存储结构为（静态链表）。</p><h3 id="第3章-栈和队列"><a href="#第3章-栈和队列" class="headerlink" title="第3章 栈和队列"></a>第3章 栈和队列</h3><p>3.1 栈<br>栈：后进先出（LIFO），又称为后进先出的线性表</p><p>顺序栈的实现：<br>栈顶指针：S.top，初始时设置S.top=-1；栈顶元素：S.data[S.top]。<br>进栈操作：栈不满时，栈顶指针先加1，再送值到栈顶元素。S.data[++S.top]=x。<br>出栈操作：栈非空时，先取栈顶元素值，再将栈顶指针减1。x=S.data[S.top–]。<br>栈空条件：S.top==-1；栈满条件：S.top==Maxsize-1；栈长：S.top+1</p><p>注意：如果栈顶指针初始化为S.top=0，即栈顶指针指向栈顶元素的下一个位置，则入栈操作变为S.data[S.top++]=x；出栈操作变为x=S.data[–S.top]。相应的栈空、栈满条件也会发生变化。</p><p>共享栈：利用栈底位置相对不变的特性，可以让两个顺序栈共享一个一维数据空间，将两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延伸。<br>两个栈的栈顶指针都指向栈顶元素，top0=-1时0号栈为空，top1=Maxsize时1号栈为空；仅当两个栈顶指针相邻（top1-top0=1）时，判断为栈满。当0号栈进栈时top0先加1再赋值，1号栈进栈时top1先减1再赋值；出栈时刚好相反，0号栈先出栈再减1，1号栈先出栈再加1.<br>共享栈是为了更有效地利用存储空间，其存取数据的时间复杂度均为O(1)。</p><p>链栈的优点是便于多个栈共享存储空间和提高其效率，且不存在栈满上溢的情况。通常采用单链表实现，并规定所有操作都是在单链表的表头进行的。这里规定链栈没有头结点，Lhead指向栈顶元素。<br>采用链式存储，便于结点的插入和删除。对于带头结点和不带头结点的链栈，在具体的实现方面有所不同。</p><p>选择题</p><p>1.栈和队列具有相同的（逻辑结构）。</p><p>2.栈是（限制存取点的线性结构）。<br>A 顺序存储的线性结构（还有链栈，非顺序存储） B 链式存储的非线性结构<br>C 限制存取点的线性结构 D限制存取点的非线性结构（栈肯定是线性结构）</p><p>7.设链表不带头结点且所有操作均在表头进行，则下列最不适合作为链栈的是（只有表头结点指针，没有表尾指针的单向循环链表）。</p><p>11.3个不同的元素依次进栈，能得到（5）中不同的出栈序列。1/(n+1) * ((2n)!/(n!*n!)）</p><p>26.采用共享栈的好处是（节省存储空间，降低发生上溢的可能）。</p><p>27.下列关于栈的叙述中，错误的是（I、III、IV）<br>I. 采用非递归方式重写递归程序时必须使用栈（反例：斐波那契数列一个循环即可）<br>II. 函数调用时，系统要用栈保存必要的信息<br>III. 只要确定了入栈次序，即可确定出栈次序（不确定）<br>IV. 栈是一种受限的线性表，允许在其两端进行操作（一端而已，栈顶）</p><p>3.2 队列<br>队列也是一种操作受限的线性表，只允许在表的一端进行插入，而在表的另一端进行删除。（先进先出的线性表）</p><p>队列的顺序实现是指分配一块连续的存储单元存放队列中的元素，并附设两个指针front和rear分别指示队头元素和队尾元素的位置。设队头指针指向队头元素，队尾指针指向队尾元素的下一个位置（也可以让rear指向队尾元素，front指向队头元素的前一个位置）。<br>初始状态（队空条件）：Q.front==Q.rear == 0.<br>进队操作：队不满时，先送值到队尾元素，再将队尾指针加1。<br>出队操作：队不空时，先取队头元素值，再将队头指针加1.</p><p>循环队列，即把存储队列元素的表从逻辑上看成一个环。<br>初始时：Q.front==Q.rear == 0.<br>出队：队首指针进1，Q.front=(Q.front+1)%MaxSize<br>入队：队尾指针进1，Q.rear=(Q.rear+1)%MaxSize<br>队列长度：(Q.rear+MaxSize-Q.front)%MaxSize<br>出队入队时：指针都按顺时针方向进1.</p><p>为了区分队空还是队满的情况，有三种处理方式：<br>1）牺牲一个单元来区分队空和队满，队头指针在队尾指针的下一位置作为队满的标志：<br>队满条件为：(Q.rear+1)%MaxSize == Q.front<br>队空条件仍为：Q.front==Q.rear<br>队列中元素的个数：(Q.rear-Q.front+MaxSize)%MaxSize<br>2）类型中增设表示元素个数的数据成员：<br>队空条件为：Q.size== 0<br>队满条件为：Q.size == Maxsize<br>3）类型中增设tag数据成员，以区分是队满还是队空。</p><p>队列的链式表示称为链队列，是一个同时带有队头指针和队尾指针的单链表。头指针指向队头结点，尾指针指向队尾结点，即单链表的最后一个结点。<br>当Q.front==NULL &amp;&amp; Q.rear == NULL时，链式队列为空。</p><p>双端队列是指允许两端都可以进行入队和出队操作的队列，其元素的逻辑结构仍是线性结构。<br>输出受限的双端队列：允许在一端进行插入和删除，但在另一端只允许插入。<br>输入受限的双端队列：允许在一端进行插入和删除，但在另一端只允许删除。</p><p>设有一个双端队列，输入序列为1,2,3,4：<br>（1）能由输入受限的双端队列得到，但不能由输出受限的双端队列得到的输出序列是4,1,3,2<br>（2）能由输出受限的双端队列得到，但不能由输入受限的双端队列得到的输出序列是4,2,1,3<br>（3）既不能由输入受限的双端队列得到，又不能由输出受限的双端队列得到的输出序列是4,2,3,1</p><p>选择题</p><p>11.最适合用做链队的链表是（带队首指针和队尾指针的非循环单链表）。</p><p>12.最不适合用做链式队列的链表是（只带队首指针的非循环双链表）。</p><p>13.在用单链表实现队列时，队头在链表的（链头）位置。</p><p>14.用链式存储方式的队列进行删除操作时需要（头尾指针可能都要修改）</p><p>15.在一个链队列中，假设队头指针为front，队尾指针为rear，x所指向的元素需要入队，则需要执行的操作为（rear-&gt;next=x, x-&gt;next=null, rear=x）</p><p>16.假设循环单链表表示的队列长度为n，队头固定在链表表尾，若只设头指针，则进队操作的时间复杂度为（O(n)）</p><p>栈和队列的应用<br>栈的应用：括号匹配、表达式求值、递归<br>队列的应用：层次遍历、计算机系统</p><p>选择题</p><p>9.执行（广度优先搜索图）操作时，需要使用队列作为辅助存储空间。</p><p>3.4 特殊矩阵的压缩存储<br>数组是由n个相同类型的数据元素构成的有限序列。</p><p>数组的存储结构：<br>一维数组<br>多维数组：按行优先和按列优先</p><p>矩阵的压缩存储：<br>对称矩阵、上（下）三角矩阵、对角矩阵</p><p>对称矩阵：将对称矩阵A[1…n][1…n]存放在一维数组B[n(n+1)/2]中，只存放主对角线和下三角区的元素。元素下标之间的对应关系如下（数组下标从0开始）：<br>k=i(i-1)/2+j-1（当i≥j，即下三角区和主对角线元素）<br>k=j(j-1)/2+i-1（当i&lt;j，即上三角区元素）</p><p>三角矩阵：<br>将下三角矩阵A[1…n][1…n]存放在一维数组B[n(n+1)/2+1]中，存储下三角区和主对角线上的元素，以及存储对角线上方的常量一次。元素下标之间的对应关系如下（数组下标从0开始）：<br>k=i(i-1)/2+j-1（当i≥j，即下三角区和主对角线元素）<br>k=n(n+1)/2（当i&lt;j，即上三角区元素）</p><p>将上三角矩阵A[1…n][1…n]存放在一维数组B[n(n+1)/2+1]中，存储上三角区和主对角线上的元素，以及存储对角线下方的常量一次。元素下标之间的对应关系如下（数组下标从0开始）：<br>k=(i-1)(2n-i+2)/2+(j-i)（当i≤j，即上三角区和主对角线元素）<br>k=n(n+1)/2（当i&gt;j，即下三角区元素）</p><p>三对角矩阵：三对角矩阵3条对角线上的元素Ai,j在一维数组B中存放的下标为k=2i+j-3；反之，若已知三对角矩阵中某元素Ai,j在一维数组B中存放于第k个位置，则可求得i=(k+1)/3+1（向下取整），j=k-2i+3.</p><p>稀疏矩阵：将非零元素及其相应的行和列构成一个三元组（行标，列标，值）。</p><p>选择题</p><p>注意：数组下标从0开始还是从1开始，按列优先存储还是按行优先存储</p><p>9.适用于压缩存储稀疏矩阵的两种存储结构是（三元组表和十字链表）</p><h3 id="第4章-树与二叉树"><a href="#第4章-树与二叉树" class="headerlink" title="第4章 树与二叉树"></a>第4章 树与二叉树</h3><p>4.1 树的基本概念<br>树是N个结点的有限集合，N=0时，称为空树。<br>树中一个结点的子结点个数称为该结点的度，树中结点的最大度数称为树的度。<br>结点的层次从树根开始定义，根结点为第1层。<br>结点的深度是从根结点开始自顶向下逐层累加的；结点的高度时从叶结点开始自底向上逐层累加的。<br>树的高度（又称深度）是树中结点的最大层数。<br>树中两个结点之间的路径是由这两个结点之间所经过的结点序列构成的，而路径长度是路径上所经过的边的个数。</p><p>树的性质：<br>1）树中的结点数等于所有结点的度数加1.<br>2）度为m的树中第i层上至多有m^(i-1)个结点（i≥1）。<br>3）高度为h的m叉树至多有(m^h-1)/(m-1)个结点。<br>4）具有n个结点的m叉树的最小高度为logm (n(m-1)+1)向上取整。</p><p>选择题</p><p>1.树最适合用来表示（元素之间具有分支层次关系）的数据。</p><p>3.树的路径长度是从树根到每一结点的路径长度的（总和）。</p><p>4.2 二叉树的概念<br>二叉树：每个结点至多只有两棵子树（即二叉树不存在度大于2的结点），子树有左右之分，不能任意颠倒次序。</p><p>满二叉树：一棵高度为h，并且含有2^h-1个结点的二叉树称为满二叉树，即树中的每一层都含有最多的结点，除叶子结点之外的每个结点度数均为2.对于编号为i的结点，如果有双亲，其双亲为i/2（向下取整），如果有左孩子，则左孩子为2i，如果有右孩子，则右孩子为2i+1.</p><p>完全二叉树：设一个高度为h，有n个结点的二叉树，当且仅当其每一个结点都与高度为h的满二叉树中编号为1~n的结点一一对应时，称为完全二叉树。<br>1）若i≤n/2（向下取整），则结点i为分支结点，否则为叶子结点。<br>2）叶子结点只可能在层次最大的两层上出现。对于最大层次中的叶子结点，都依次排列在该层最左边的位置上。<br>3）如果有度为1的结点，只可能有一个，且该结点只有左孩子而无右孩子。<br>4）若n为奇数，则每个分支结点都有左子女和右子女；若n为偶数，则编号最大的分支结点（编号为n/2）只有左子女，没有右子女，其余分支结点左右子女都有。</p><p>二叉排序树：左子树上所有结点的关键字均小于根结点的关键字，右子树上所有结点的关键字均大于根结点的关键字。</p><p>平衡二叉树：树上任一结点的左子树和右子树的深度之差不超过1.</p><p>二叉树的性质：<br>1）非空二叉树上叶子结点等于度为2的结点数加1，即N0=N2+1<br>2）非空二叉树上第k层上至多有2^(k-1)个结点<br>3）高度为H的二叉树至多有2^H-1个结点<br>4）对完全二叉树按从上到下、从左到右的顺序依次编号1~N，则有以下关系：<br>a. 当i&gt;1时，结点i的双亲结点编号为i/2（向下取整）<br>b. 当2i≤N时，结点i的左孩子编号为2i，否则无左孩子<br>c. 当2i+1小于等于N时，结点i的右孩子编号为2i+1，否则无右孩子。<br>d. 结点i所在层次（深度）为log2 i（向下取整）+1<br>5）具有N个结点的完全二叉树的高度为log2 (N+1)（向上取整）或log2 N（向下取整）+1</p><p>二叉树的顺序存储结构就是用一组地址连续的存储单元依次自上而下、自左至右存储完全二叉树上的结点元素。<br>完全二叉树和满二叉树采用顺序存储比较合适。<br>注意：二叉树属于树，都可以用树的存储结构来存储，但是树却不都能用二叉树的存储结构来存储。</p><p>二叉树的链式存储结构：链式结构是指用一个链表来存储一棵二叉树，二叉树中每一个结点用链表的一个链结点来存储。二叉链表至少包含三个域：数据域data、左指针域lchild、右指针域rchild。<br>在含有n个结点的二叉链表中含有n+1个空链域。</p><p>4.3 二叉树的遍历和线索二叉树<br>先序遍历PreOrder：访问根结点，先序遍历左子树，先序遍历右子树<br>中序遍历InOrder：中序遍历左子树，访问根结点，中序遍历右子树<br>后序遍历PostOrder：后序遍历左子树，后序遍历右子树，访问根结点<br>时间复杂度均为O(n)，在递归遍历中，递归工作栈的栈深恰好为树的高度。</p><p>层次遍历：需要借助一个队列。先将二叉树根结点入队，然后出队，访问该结点，如果它有左子树，则将左子树根结点入队；如果它有右子树，则将右子树根结点入队。然后出队，对出队结点访问，如此反复，直到队列为空。</p><p>由二叉树的先序序列和中序序列可以唯一确定一棵二叉树；<br>由二叉树的后序序列和中序序列可以唯一确定一棵二叉树；<br>由二叉树的层序序列和中序序列可以唯一确定一棵二叉树。<br>如果只知道二叉树的先序序列和后序序列，则无法确定一棵二叉树。</p><p>线索二叉树：为了加快查找结点前驱和后继的速度。<br>在二叉树线索化时，通常规定：若无左子树，令lchild指向其前驱结点；若无右子树，令rchild指向其后继结点，还需要增加那个标志域表明当前指针域所指对象时指向左（右）子结点还是直接前驱（后继）。<br>ltag=0（lchild域指示结点的左孩子）<br>ltag=1（lchild域指示结点的前驱）<br>rtag=0（rchild域指示结点的右孩子）<br>rtag=1（rchild域指示结点的后继）</p><p>选择题</p><p>22.引入线索二叉树的目的是（加快查找结点的前驱和后继的速度）。</p><p>23.线索二叉树是一种（物理）结构。</p><p>24.n个结点的线索二叉树上含有的线索数为（n+1）</p><p>29.二叉树在线索化后，仍不能有效求解的问题是（后序线索二叉树中求后序后继）<br>A 先序线索二叉树中求先序后继<br>B 中序线索二叉树中求中序后继<br>C 中序线索二叉树中求中序前驱<br>D 后序线索二叉树中求后序后继</p><p>31.（后序线索树）的遍历仍需要栈的支持<br>A 前序线索树 B 中序线索树 C 后序线索树 D 所有线索树</p><p>34.先序序列为a,b,c,d的不同二叉树的个数是（14）(1/(n+1) * (2n!)/(n!*n!))</p><p>4.4 树、森林<br>树的存储结构：既可以采用顺序存储结构，也可以采用链式存储结构。</p><p>双亲表示法：采用一组连续空间来存储每个结点，同时在每个结点中增设一个伪指针，指示其双亲结点在数组中的位置。<br>利用了每个结点（根结点除外）只有唯一双亲的性质，可以很快得到每个结点的双亲结点，但是求结点的孩子时需要遍历整个结构。</p><p>孩子表示法：将每个结点的孩子结点都用单链表链接起来形成一个线性结构，则N个结点就有N个孩子链表（叶子结点的孩子链表为空表）。<br>寻找子女的操作非常直接，而寻找双亲的操作需要遍历N个结点中孩子链表指针域所指向的N个孩子链表。</p><p>孩子兄弟表示法：又称为二叉树表示法，即以二叉树表作为树的存储结构，使每个结点包括三部分内容：结点值、指向结点第一个孩子结点的指针和指向结点下一个兄弟结点的指针（沿此域可以找到结点的所有兄弟结点）。<br>可以方便地实现树转换为二叉树的操作，易于查找结点的孩子等，但缺点是从当前结点查找其双亲结点比较麻烦。</p><p>给定一棵树，可以找到唯一的一棵二叉树与之对应。</p><p>树转换为二叉树的规则：每个结点左指针指向它的第一个孩子结点，右指针指向它在树中的相邻兄弟结点，可表示为“左孩子右兄弟”。由于根结点没有兄弟，所以由树转换而得的二叉树没有右子树。</p><p>森林转换为二叉树的规则与树相似。</p><p>二叉树转换为森林的规则：若二叉树非空，则二叉树根及其左子树为第一棵树的二叉树形式，二叉树根的右子树又可以看做是一个由除第一棵树外的森林转换后的二叉树，应用同样的方法，直到最后产生一棵没有右子树的二叉树为止。<br>二叉树转换为树和森林是唯一的。</p><p>树的遍历：<br>先根遍历：若树非空，则先访问根结点，再按从左到右的顺序遍历根结点的每一棵子树。其访问顺序与这棵树相应二叉树的先序遍历顺序相同。<br>后根遍历：若树非空，则按从左到右的顺序遍历根结点的每一棵子树，之后再访问根结点。其访问顺序与这棵树相应二叉树的中序遍历顺序相同。<br>层次遍历：与二叉树的层次遍历思想基本相同，即按层序依次访问各结点。</p><p>森林的遍历：<br>先序遍历森林：访问森林中第一棵树的根结点；先序遍历第一棵树中根结点的子树森林；先序遍历除去第一棵树之后剩余的树构成的森林。<br>中序遍历森林：中序遍历森林中第一棵树的根结点的子树森林；访问第一棵树的根结点；中序遍历除去第一棵树之后剩余的树构成的森林。</p><p>树的应用——并查集</p><p>选择题</p><p>1.下列关于树的说法中，正确的是（II）<br>I. 对于有n个结点的二叉树，其高度为log2 n（错误，单支树，高度为n）<br>II. 完全二叉树中，若一个结点没有左孩子，则它必是叶结点<br>III. 高度为h的完全二叉树对应的森林所含的树的个数一定是h（错误，满二叉树才有该性质）<br>IV. 一棵树中的叶子数一定等于与其对应的二叉树的叶子数（错误）</p><p>3.将森林转换为对应的二叉树，若在二叉树中，结点u是结点v的父结点的父结点，则在原来的森林中，u和v可能具有的关系是（I、II）<br>I. 父子关系 II. 兄弟关系 III. u的父结点与v的父结点是兄弟关系</p><p>7.设F是一个森林，B是由F变换来的二叉树。若F中有n个非终端结点，则B中右指针域为空的结点有（n+1）个</p><p>9.将森林F转换为对应的二叉树T，F中叶结点的个数等于（T中左孩子指针为空的结点个数）</p><p>12.若森林F有15条边、25个结点，则F包含树的个数是（10）<br>在n个结点的树中有n-1条边，那么对于每棵树，其结点数比边数多1.</p><p>4.5 树与二叉树的应用<br>二叉排序树（BST，又称为二叉查找树）：左子树上所有结点关键字值均小于根结点的关键字值；右子树上所有结点关键字值均大于根结点的关键字值；左右子树本身也分别是一棵二叉排序树。<br>对二叉排序树进行中序遍历，可以得到一个递增的有序序列。</p><p>二叉排序树的查找、插入、构造、删除<br>二叉排序树查找算法的平均查找长度，主要取决于树的高度，即与二叉树的形态有关。<br>当有序表是静态查找表时，宜用顺序表作为其存储结构，而采用二分查找实现其查找操作；若有序表是动态查找表，则应选择二叉排序树作为其逻辑结构。</p><p>平衡二叉树（AVL）：左子树和右子树都是平衡二叉树，且任意结点的左右子树高度差的绝对值不超过1。<br>平衡因子的值只可能是-1,0或1（左子树的高度-右子树的高度）</p><p>平衡二叉树的插入：LL平衡旋转（右单旋转）、RR平衡旋转（左单旋转）、LR平衡旋转（先左后右双旋转）、RL平衡旋转（先右后左双旋转）</p><p>平衡二叉树的查找：平均查找长度为O(log2 n)</p><p>从树根结点到任意结点的路径长度（经过的边数）与该结点上权值的乘积称为该结点的带权路径长度。树中所有叶结点的带权路径长度之和称为该树的带权路径长度。</p><p>在含有N个带权叶子结点的二叉树中，其中带权路径长度（WPL）最小的二叉树称为哈夫曼树，也称为最优二叉树。</p><p>哈夫曼树的构造：给定N个权值分别为w1~wN的结点<br>1）将这N个结点分别作为N棵仅含一个结点的二叉树，构成森林F<br>2）构造一个新结点，并从F中选取两棵根结点权值最小的树作为新结点的左右子树，并且将新结点的权值置为左右子树上根结点的权值之和<br>3）从F中删除刚才选出的两棵树，同时将新得到的树加入F中<br>4）重复2）和3），直至F中只剩下一棵树为止<br>特点：<br>1）每个初始结点最终都成为叶结点，并且权值越小的结点到根结点的路径长度越大<br>2）构造过程中共新建了N-1个结点（双分支结点），因此哈夫曼树的结点总数为2N-1<br>3）每次构造都选择2棵树作为新结点的孩子，因此哈夫曼树中不存在度为1的结点</p><p>可变长度编码：对频率高的字符赋以短编码，而对频率较低的字符赋以较长一些的编码，从而使字符平均编码长度减短，起到压缩数据的效果。<br>如果没有一个编码是另一个编码的前缀，则称这样的编码为前缀编码。<br>由哈夫曼树构造哈弗曼编码：首先将每个出现的字符当做一个独立的结点，其权值为它出现的频度，构造出相应的哈夫曼树。显然，所有字符结点都出现在叶结点中。我们可以将字符的编码解释为从根至该字符的路径上边标记的序列，其中边标记为0表示“转向左孩子”，标记为1表示“转向右孩子”。</p><p>选择题</p><p>1.对于二叉排序树，下面的说法（C）是正确的<br>A 二叉排序树是动态树表，查找失败时插入新结点时，会引起树的重新分裂和组合（错）<br>B 对二叉排序树进行层序遍历可得到有序序列（错，中序遍历）<br>C 用逐点插入法构造二叉排序树，若先后插入的关键字有序，二叉排序树的深度最大<br>D 在二叉排序树进行查找，关键字的比较次数不超过结点数的1/2（错）</p><h3 id="第5章-图"><a href="#第5章-图" class="headerlink" title="第5章 图"></a>第5章 图</h3><p>5.1 图的基本概念<br>有向图、无向图<br>简单图：不存在重复边，不存在顶点到自身的边（数据结构中仅讨论简单图）<br>多重图的定义和简单图相反。</p><p>无向完全图：在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。含有n个顶点的无向完全图有n(n-1)/2条边。<br>有向完全图：在有向图中，如果任意两个顶点之间都存在方向相反的两条弧，则称该图为有向完全图。含有n个顶点的有向完全图有**n(n-1)**条有向边。</p><p>子图：设有两个图G=(V,E)和G’=(V’,E’)，若V’是V的子集，且E’是E的子集，则称G’是G的子图。若有满足V(G’)=V(G)的子图G’，则为G的生成子图。</p><p>连通、连通图和连通分量（无向图）：在无向图中，若从顶点v到顶点w有路径存在，则称v和w是连通的。若图G中任意两个顶点都是连通的，则称图G为连通图，否则称为非连通图。无向图中的极大连通子图称为连通分量。如果一个图有n个顶点，并且有小于n-1条边，则此图必是非连通图。</p><p>强连通图、强连通分量（有向图）：在有向图中，若从顶点v到顶点w和从顶点w到顶点v之间都有路径，则称这两个顶点是强连通的。若图中任何一对顶点都是强连通的，则称该图为强连通图。有向图中的极大强连通子图称为强连通分量。</p><p>生成树、生成森林：连通图的生成树是包含图中全部顶点的一个极小连通子图。若图中顶点数为n，则它的生成树含有n-1条边。对于生成树而言，若砍去它的一条边，则它会变成非连通图，若加上一条边则会形成一个回路。</p><p>对于无向图，顶点v的度是指依附于该顶点的边的条数，记为TD(v)。<br>在具有n个顶点e条边的无向图中，全部顶点的度之和为2e，即无向图的全部顶点的度之和等于边数的两倍。</p><p>对于有向图，顶点v的度分为入度和出度，入度记为ID(v)，出度记为OD(v)。顶点v的度等于其入度和出度之和，即TD(v)=ID(v)+OD(v)。<br>在具有n个顶点e条边的有向图中，有向图的全部顶点的入度之和与出度之和相等并且等于边数。</p><p>带权图也称为网。<br>稠密图：边数很多；稀疏图：边数很少。一般当图G满足|E|&lt;|V|*log|V|时，可以将G看成是稀疏图。</p><p>路径：顶点序列；路径长度：路径上边的数目。第一个顶点和最后一个顶点相同的路径称为回路或环。如果一个图有n个顶点，并且有大于n-1条边，则此图一定有环。</p><p>在路径序列中，顶点不重复出现的路径称为简单路径。除第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路称为简单回路。</p><p>有一个顶点的入度为0，其余顶点的入度均为1的有向图称为有向树。</p><p>选择题</p><p>2.一个有n个顶点和n条边的无向图一定是（有环的）。</p><p>3.如果从无向图的任意顶点出发进行一次深度优先搜索即可访问所有顶点，则该图一定是（连通图）。</p><p>4.下列关于图的叙述，正确的是（III）<br>I. 回路是简单路径（错误，回路是第一个顶点和最后一个顶点相同的路径，简单路径是顶点不重复出现的路径）<br>II. 存储稀疏图，用邻接矩阵比邻接表更省空间（错误，应用邻接表）<br>III. 若有向图中存在拓扑序列，则该图不存在回路（正确，存在回路的图不存在拓扑序列）</p><p>7.若无向图G=(V,E)中含有7个顶点，要保证图G在任何情况下都是连通的，则需要的边数最少是（16）（6*5/2+1）</p><p>10.一个有28条边的非连通子图至少有（9）个顶点。（25=8*7/2,8+1=9）</p><p>11.对于一个有n个顶点的图：如果是连通无向图，其边的个数至少为（n-1）；如果是连通有向图，其边的个数至少为（n）</p><p>13.在有n个顶点的有向图中，每个顶点的度最大可达（2n-2）</p><p>14.具有6个顶点的无向图，当有（11）条边时能确保是一个连通图。（5*4/2+1）</p><p>17.如果有n个顶点的图是一个环，则它有（n-1）棵生成树。</p><p>18.若一个具有n个顶点，e条边的无向图是一个森林，则该森林中必有（n-e）棵树。</p><p>5.2 图的存储及基本操作<br>邻接矩阵存储，就是用一个一维数组存储图中顶点的信息，用一个二维数组存储图中边的信息（即各顶点之间的邻接关系），存储顶点之间邻接关系的二维数组称为邻接矩阵。<br>1）无向图的邻接矩阵是对称矩阵（并且唯一），在实际存储邻接矩阵时只需存储上（或下）三角矩阵的元素即可，对规模特大的邻接矩阵可采用压缩存储。<br>2）邻接矩阵表示法的空间复杂度为O(n2)，其中n为图的顶点数|V|<br>3）对于无向图，邻接矩阵的第i行（或第i列）非零元素（或非∞元素）的个数正好是第i个顶点的度<br>4）对于有向图，邻接矩阵的第i行（或第i列）非零元素（或非∞元素）的个数正好是第i个顶点的出度（或入度）<br>5）容易确定顶点之间是否有边相连，但难以确定图中有多少条边。<br>6）稠密图适合使用邻接矩阵的存储表示。</p><p>邻接表就是对图G中的每个顶点vi建立一个单链表，第i个单链表中的结点表示依附于顶点vi的边（对于有向图则是以顶点vi为尾的弧），这个单链表就称为顶点vi的边表（对于有向图则称为出边表）。边表的头指针和顶点的数据信息采用顺序存储（称为顶点表），所以在邻接表中存在两种结点：顶点表结点和边表结点。<br>顶点表结点由顶点域（data）和指向第一条邻接边的指针（firstarc）构成，边表（邻接表）结点由邻接点域（adjvex）和指向下一条邻接边的指针域（nextarc）构成。<br>1）如果G为无向图，则所需的存储空间为O(|V|+2|E|)；如果G为有向图，则所需的存储空间为O(|V|+|E|)<br>2）对于稀疏图，采用邻接表表示将极大地节省存储空间。<br>3）容易找出顶点的所有邻边，但难以确定两个顶点之间是否存在边<br>4）图的邻接表表示并不唯一</p><p>十字链表是有向图的一种链式存储结构。<br>既容易找到vi为尾的弧，也容易找到vi为头的弧，因而容易求得顶点的出度和入度。<br>图的十字链表表示是不唯一的，但一个十字链表表示确定的一个图。</p><p>邻接多重表是无向图的另一种链式存储结构。</p><p>选择题</p><p>1.关于图的存储结构，（B）是错误的<br>A 使用邻接矩阵存储一个图时，在不考虑压缩存储的情况下，所占用的存储空间大小只与图中的顶点数有关，与边数无关<br>B 邻接表只用于有向图的存储，邻接矩阵适用于有向图和无向图<br>C 若一个有向图的邻接矩阵，对角线以下元素为0，则该图的拓扑序列必定存在<br>D 存储无向图的邻接矩阵是对称的，故只需存储邻接矩阵的下（或上）三角部分即可</p><p>2.若图的邻接矩阵中主对角线上的元素皆为0，其余元素全为1，则可以断定该图一定是（完全图）</p><p>8.一个图的邻接矩阵表示唯一，邻接表表示不唯一。</p><p>9.用邻接表法存储图所用的空间大小（与图的顶点数和边数有关）</p><p>10.若邻接表中有奇数个边表结点，则一定是（图为有向图）（无向图采用邻接表表示，有偶数个边表结点）</p><p>13.假设有n个顶点e条边的有向图用邻接表表示，则删除与某个顶点v相关的所有边的时间复杂度为（O(n+e)）</p><p>14.求有向图结点的度，必须遍历整个邻接表</p><p>15.邻接多重表是（无向图）的存储结构</p><p>16.十字链表是（有向图）的存储结构</p><p>5.3 图的遍历<br>广度优先搜索（BFS）：不是一个递归的算法，必须借助一个辅助队列，以记忆正在访问的顶点的下一层顶点。<br>类似的思想还应用于Dijkstra单源最短路径算法和Prim最小生成树算法。<br>空间复杂度为O(|V|)；采用邻接表存储方式时，时间复杂度为O(|V|+|E|)；采用邻接矩阵存储方式时，时间复杂度为O(|V|^2)。</p><p>广度优先生成树：一给定图的邻接矩阵存储表示是唯一的，故其广度优先生成树也是唯一的，但由于邻接表存储表示不唯一，故其广度优先生成树也是不唯一的。</p><p>深度优先搜索（DFS）：对于同样一个图，基于邻接矩阵的遍历所得到的DFS序列和BFS序列是唯一的，基于邻接表的遍历所得到的DFS序列和BFS序列是不唯一的。<br>空间复杂度为O(|V|)；采用邻接表存储方式时，时间复杂度为O(|V|+|E|)；采用邻接矩阵存储方式时，时间复杂度为O(|V|^2)。</p><p>选择题</p><p>2.对于一个非连通无向图G，采用深度优先遍历访问所有顶点，调用DFS的次数正好等于（连通分量数）</p><p>7.用邻接表存储的图的深度优先遍历算法类似于树的（先序遍历），而其广度优先遍历算法类似于树的（按层次遍历）</p><p>12.判断有向图是否存在回路，除了可以利用拓扑排序外，还可以利用（深度优先遍历算法）</p><p>13.使用DFS算法递归地遍历一个无环有向图，并在退出递归时输出相应顶点，这样得到的顶点序列是（逆拓扑有序）</p><p>15.图的广度优先生成树的树高比深度优先生成树的树高（小或相等）</p><p>5.4 图的应用<br>最小生成树（MST）：Prim算法、Kruskal算法<br>1）最小生成树不是唯一的。当图G中的各边权值互不相等时，G的最小生成树是唯一的；若无向连通图G的边比顶点树少1，即G本身就是一棵树时，Ｇ的最小生成树就是它本身。<br>2）最小生成树的边的权值之和总是唯一的。<br>3）最小生成树的边数为顶点数减１<br>Prim算法的时间复杂度为O(|V|^2)，不依赖于|E|，因此它适用于求解边稠密的的图的最小生成树。<br>Kruskal算法适用于边稀疏而顶点较多的图。</p><p>最短路径分为两类：一是单源最短路径：即求图中某一顶点到其他各顶点的最短路径，可通过Dijkstra算法求解；二是求每一对顶点间的最短路径，可通过Floyd-Warshall算法来求解。<br>Dijkstra算法：单源最短路径时间复杂度为O(|V|^2)。如果边上带有负权值，Dijkstra算法并不适用。<br>Floyd算法的时间复杂度为O(|V|^3)。Floyd算法允许图中带负权值的边，但不允许有包含带负权值的边组成的回路。Floyd算法同样也适用于带权无向图。</p><p>有向无环图（DAG）<br>AOV网：如果用DAG图表示一个工程，其顶点表示活动，用有向边&lt;Vi,Vj&gt;表示活动Vi必须先于活动Vj进行的这样一种关系，则将这种有向图称为顶点表示活动的网络，记为AOV网。<br>拓扑排序：由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序：<br>1）每个顶点出现且只出现一次。<br>2）若顶点A在序列中排在顶点B的前面，则在图中不存在从顶点B到顶点A的路径。<br>每个DAG图都有一个或多个拓扑序列。<br>对一个DAG图进行拓扑排序的算法：<br>1）从DAG图中选择一个没有前驱的顶点并输出<br>2）从图中删除该顶点和所有以它为起点的有向边<br>3）重复1和2直到当前的DAG图为空或当前图中不存在无前驱的顶点为止。而后一种情况说明有向图中必然存在环<br>时间复杂度为O(|V|+|E|)</p><p>AOE网：在带权有向图中，以顶点表示事件，有向边表示活动，边上的权值表示完成该活动的开销，则称这种有向图为用边表示活动的网络，简称为AOE网。<br>1）只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始<br>2）只有在进入某一顶点的各有向边所代表的活动都已经结束时，该顶点所代表的事件才能发生。<br>在AOE网中，仅有一个入度为0的顶点，称为开始顶点（源点），它表示整个工程的开始，仅有一个出度为0的顶点，称为结束顶点（汇点），它表示整个工程的结束。<br>从源点到汇点的所有路径中，具有最大路径长度的路径称为关键路径。关键路径上的活动称为关键活动。<br>完成整个工程的最短时间就是关键路径的长度，也就是关键路径上各活动花费开销的总和。</p><p>事件vk的最早发生时间ve(k)：指从开始顶点V到Vk的最长路径长度。事件的最早发生时间决定了所有从Vk开始的活动能够开工的最早时间。（从前往后计算）<br>事件vk的最迟发生时间vl(k)：指在不推迟整个工程完成的前提下，即保证它所指向的事件vi在ve(i)时刻能够发生时，该事件最迟必须发生的事件。（从后往前计算）<br>活动ai的最早开始时间e(i)：指该活动的起点所表示的事件最早发生时间<br>活动ai的最迟开始时间l(i)：指该活动的终点所表示的事件最迟发生时间与该活动所需时间之差。<br>一个活动ai的最迟开始时间l(i)和其最早开始时间e(i)的差额d(i)=l(i)-e(i)：指该活动完成的时间余量，是在不增加完成整个工程所需的总时间的情况下，活动ai可以拖延的时间。如果为0，说明该活动必须要如期完成。</p><p>求关键路径的算法步骤如下：<br>1）求AOE网中所有事件的最早发生时间ve()<br>2）求AOE网中所有事件的最迟发生时间vl()<br>3）求AOE网中所有活动的最早开始时间e()<br>4）求AOE网中所有活动的最迟开始时间l()<br>5）求AOE网中所有活动的差额d()，找出所有d()=0的活动构成关键路径</p><p>注意：<br>1）关键路径上的所有活动都是关键活动，因此可通过加快关键活动来缩短整个工程的工期，但不能任意缩短关键活动，因为一旦缩短到一定程度，该关键活动可能变成非关键活动。<br>2）网中的关键路径并不唯一。只提高一条关键路径上的的关键活动速度并不能缩短整个工程的工期，只有加快那些包括在所有关键路径上的关键活动才能达到缩短工期的目的。</p><p>选择题</p><p>2.任何一个无向连通图的最小生成树（有一棵或多棵）</p><p>3.用Prim算法和Kruskal算法构造图的最小生成树，所得到的最小生成树（可能相同，可能不同）</p><p>4.只要无向连通图中没有权值相同的边，则最小生成树唯一</p><p>6.最短路径一定是简单路径</p><p>10.下面哪一方法可以判断出一个有向图是否有环（回路）（I、II、III）<br>I. 深度优先 II.拓扑排序 III. 求最短路径 IV. 求关键路径</p><p>13.若一个有向图的顶点不能排在一个拓扑序列中，则可判定该有向图（含有顶点数目大于1的强连通分量）</p><p>14.以下关于拓扑排序的说法中错误的是（III）<br>I. 如果某有向图存在环路，则该有向图一定不存在拓扑排序<br>II. 在拓扑排序算法中，为暂存入度为零的顶点可以使用栈，也可以使用队列<br>III. 若有向图的拓扑有序序列唯一，则图中每个顶点的入度和出度最多为1</p><p>18.若一个有向图具有有序的拓扑排序序列，那么它的邻接矩阵必定为（三角矩阵）</p><h3 id="第6章-查找"><a href="#第6章-查找" class="headerlink" title="第6章 查找"></a>第6章 查找</h3><p>6.1 查找的基本概念<br>查找：<br>1）查询某个特定的数据元素是否在查找表中<br>2）检索满足条件的某个特定的数据元素的各种属性<br>3）在查找表中插入一个数据元素<br>4）从查找表中删除某个数据元素<br>静态查找表：顺序查找、折半查找、散列查找<br>动态查找表：二叉排序树的查找、散列查找、二叉平衡树、B树<br>平均查找长度：一次查找的长度是指需要比较的关键字次数，而平均查找长度是所有查找过程中进行关键字的比较次数的平均值。平均查找长度是衡量查找算法效率的最主要的指标。</p><p>6.2 顺序查找和折半查找<br>一般线性表的顺序查找：查找成功时的平均查找长度为(n+1)/2，查找不成功时的平均查找长度为n+1；缺点是当n较大时，平均查找长度较大，效率低，优点是对数据元素的存储没有要求，顺序存储或链式存储皆可。<br>有序表的顺序查找：查找成功时的平均查找长度为(n+1)/2，查找不成功时的平均查找长度为n/2+n/(n+1)。</p><p>折半查找：又称为二分查找，仅适用于有序的顺序表，仅适合于线性表的顺序存储结构，不适合链式存储结构，且要求元素按关键字有序排列。<br>若有序序列有n个元素，则对应的判定树有n个圆形的非叶结点和n+1各方形的叶结点。<br>查找成功的平均查找长度为1/n*(11+22+…+h*2^(h-1))。</p><p>分块查找，又称为索引顺序查找，吸取了顺序查找和折半查找各自的优点，既有动态结构，又适于快速查找。<br>基本思想：将查找表分为若干个子块，块内的元素可以无序，但块之间是有序的，即第一个块中的最大关键字小于第二个块中的所有记录的关键字，以此类推。再建立一个索引表，索引表中的每个元素含有各块的最大关键字和各块总第一个元素的地址，索引表按关键字有序排列。<br>分块查找的平均查找长度为索引查找和块内查找的平均长度之和，设将长度为n的查找表均匀分为b块，每块有s个记录，若在块内和索引表中均采用顺序查找，则平均查找长度为(b+1)/2+(s+1)/2=(s^2+2s+n)/(2s)，此时若S=根号n，则平均查找长度取最小值。若对索引表采用折半查找，则平均查找长度为log2 (b+1)+(s+1)/2</p><p>选择题</p><p>1.顺序查找适合于存储结构为（顺序存储结构或链式存储结构）的线性表。</p><p>5.二分查找：表必须有序，且表只能以顺序方式存储</p><p>7.折半查找过程所对应的判定树是一棵（平衡二叉树）</p><p>9.折半查找和二叉排序树的时间性能（有时不相同）</p><p>12.对表长为n的有序表进行折半查找，其判定树的高度为（log2 (n+1)向上取整）</p><p>6.3 B树和B+树<br>B树，又称为多路平衡二叉树，B树中所有结点的孩子结点数的最大值称为B树的阶，通常用m表示。<br>1）树中每个结点至多有m棵子树（即至多含有m-1个关键字）<br>2）若根结点不是终端结点，则至少有两棵子树<br>3）除根结点外的所有非叶结点至少有m/2（向上取整）棵子树（即至少含有m/2向上取整-1个关键字）<br>4）结点中关键字个数n满足m/2（向上取整）-1≤n≤m-1<br>B树是所有结点的平衡因子均等于0的多路查找树。<br>B树中的大部分操作所需的磁盘存取次数于B树的高度成正比。应该明确B树的高度不包括最后的不带任何信息的叶结点所处的那一层。高度logm (n+1)≤h≤logm/2 ((n+1)/2)+1其中m/2向上取整</p><p>B树的查找：即爱找到目标结点后，先将结点中的信息读入内存，然后再采用顺序查找法或折半查找法查找等于K的关键字<br>1）在B树中找结点（在磁盘上进行）<br>2）在结点内找关键字（在内存中进行）</p><p>B树的插入：<br>1）定位<br>2）插入：由于结点中的关键字个数n满足m/2（向上取整）-1≤n≤m-1，若插入后超过m-1，则必须对结点进行分裂</p><p>B树的删除：要使得删除后的结点中的关键字个数≥m/2（向上取整）-1，涉及到合并问题</p><p>m阶的B+树与m阶的B树的主要差异在于：<br>1）在B+树中，具有n个关键字的结点只含有n棵子树，即每个关键字对应一棵子树；而在B树中，具有n个关键字的结点含有n+1棵子树<br>2）在B+树中，每个结点（非根内部结点）关键字个数n的范围是m/2（向上取整）≤n≤m（根结点1≤n≤m），在B树中，每个结点（非根内部结点）关键字个数n的范围是m/2（向上取整）-1≤n≤m-1（根结点1≤n≤m-1）<br>3）在B+树中，叶结点包含信息，所有非叶结点仅起到索引作用，非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。<br>4）在B+树中，叶结点包含了全部关键字，即在非叶结点中出现的关键字也会出现在叶结点中；而在B树中，叶结点包含的关键字和其他结点包含的关键字是不重复的。</p><p>选择题</p><p>7.具有n个关键字的m阶B树，应有（n+1）个叶结点</p><p>14.B树不支持顺序查找，B+树支持顺序查找</p><p>16.下列应用中，适合使用B+树的是（B）<br>A 编译器中的词法分析 B 关系数据库系统中的索引 C 网络中的路由表快速查找 D 操作系统的磁盘空间块管理</p><p>6.4 散列（Hash）表<br>散列函数：一个把查找表中的关键字映射称该关键字对应的地址的函数，记为Hash(key)=Addr<br>散列表：是根据关键字而直接进行访问的数据结构，即散列表建立了关键字和存储地址之间的一种直接映射关系。<br>理想情况下，对散列表进行查找的时间复杂度为O(1)，即与表中元素个数无关。</p><p>散列函数的构造方法：<br>1.直接定址法：H(key)=a*key+b<br>2.除留余数法：H(key)=key%p（p是一个不大于m但最接近或等于m的质数）<br>3.数字分析法<br>4.平均取中法<br>5.折叠法</p><p>处理冲突的方法：<br>1.开放定址法：Hi=(H(key)+di)%m（m表示散列表表长，di为增量序列）<br>1）线性探测法：di=0,1,2…m-1<br>2）平方探测法（二次探测法）<br>3）再散列法：Hi=(H(key)+i*Hash2(key))%m<br>4）伪随机序列法<br>2.拉链法（链接法，chaining）</p><p>散列表的查找效率取决于三个因素：散列函数、处理冲突的方法和装填因子<br>装填因子：一般记为a，定义为一个表的装满程度，即a=表中记录数n/散列表长度m<br>散列表的平均查找长度依赖于散列表的装填因子a，而不直接依赖于n或m</p><p>选择题</p><p>1.只能在顺序存储结构上进行的查找方法是（B折半查找）<br>A 顺序查找法 B 折半查找 C 树型查找法 D 散列查找法</p><p>4.在开址法中散列到同一个地址而引起的“堆积”问题是由于（同义词之间或非同义词之间发生冲突）引起的。</p><p>5.下列关于散列冲突处理方法的说法中，正确的有（I、III）<br>I. 采用再散列法处理冲突时不易产生聚集<br>II. 采用线性探测法处理冲突时，所有同义词在散列表中一定相邻（错误）<br>III. 采用链地址法处理冲突时，若限定在链首插入，则插入任一个元素的时间是相同的<br>IV. 采用链地址法处理冲突容易引起聚集现象（错误）</p><p>8.对包含n个元素的散列表进行查找，平均查找长度（不直接依赖于n）</p><p>9.采用开放定址法解决冲突的散列查找中，发生聚集的原因主要是（解决冲突的方法选择不当）</p><p>6.5 字符串模式匹配<br>串的模式匹配，是求第一个字符串（模式串）在第二个字符串（主串）中的位置。<br>简单模式匹配算法的最坏时间复杂度为O(n*m)，n、m分别为主串和模式串的长度。</p><p>KMP算法可以在**O(n+m)**的时间数量级上完成串的模式匹配操作。<br>手工求解next数组的方法：<br>1）next[1]=0，next[2]=1（next[0]不使用）<br>2）后面求解每一位的next[j]值时，根据j的前一位进行比较，令k=next[j-1]<br>3）将S[j-1]与S[k]进行比较：<br>a. 如果相等，则该next[j]=k+1<br>b. 如果不等，令k=next[k]，若k不等于0，跳到3；若k等于0，next[j]=1</p><h3 id="第7章-排序"><a href="#第7章-排序" class="headerlink" title="第7章 排序"></a>第7章 排序</h3><p>7.1 排序的基本概念<br>内部排序是指在排序期间元素全部存放在内存中的排序；外部排序是指在排序期间元素无法全部同时存放在内存中，必须在排序的过程中根据要求不断地在内、外存之间移动的排序。</p><p>7.2 插入排序<br>基本思想：每次将一个待排序的记录，按其关键字大小插入到前面已经排好序的子序列中，直到全部记录插入完成。</p><p>直接插入排序：空间复杂度O(1)，时间复杂度O(n^2)，稳定，适用于顺序存储和链式存储的线性表。</p><p>注意：大部分排序算法都仅适用于顺序存储的线性表。</p><p>折半插入排序：时间复杂度O(n^2)，稳定</p><p>希尔排序：空间复杂度O(1)，时间复杂度O(n^1.3)，不稳定</p><p>选择题</p><p>2.在待排序的元素序列基本有序的前提下，效率最高的排序方法是（A）<br>A 直接插入排序 B 简单选择排序 C 快速排序 D 归并排序</p><p>3.对同一待排序序列分别进行折半插入和直接插入排序，两者之间可能的不同之处是（元素之间的比较次数）</p><p>4.对有n个元素的顺序表采用直接插入排序算法进行排序，在最坏情况下所需的比较次数是（n(n-1)/2），在最好情况下所需的比较次数是（n-1）</p><p>7.下列算法中，（C直接插入排序）算法可能出现下列情况：在最后一趟开始之前，所有元素都不在最终位置上<br>A 堆排序 B 冒泡排序 C 直接插入排序 D快速排序</p><p>15.有些排序算法在每趟排序过程中，都会有一个元素被放置到其最终位置上，下列算法不会出现这种情况的是（A希尔排序）<br>A 希尔排序 B 堆排序 C 冒泡排序 D 快速排序</p><p>16&amp;17.冒泡排序、直接插入排序、归并排序是稳定的；<br>快速排序、堆排序、简单选择排序、希尔排序是不稳定的</p><p>18.希尔排序的组内排序采用的是（直接插入排序）</p><p>7.3 交换排序<br>冒泡排序：空间复杂度O(1)，时间复杂度O(n^2)，稳定，每一趟排序都会将一个元素放置到其最终的位置</p><p>快速排序：空间复杂度最坏是O(n)，平均是O(log2 n)，时间复杂度O(nlog2 n)，不稳定，每一趟排序都会将一个元素（基准元素）放置到其最终的位置，是所有内部排序算法中平均性能最优的排序算法</p><p>选择题</p><p>4.为实现快速排序算法，待排序序列宜采用的存储方式是（顺序存储）</p><p>7.快速排序算法在（要排序的数据已基本有序）的情况下最不利于发挥其长处。</p><p>15.采用递归方式对顺序表进行快速排序，下列关于递归次数的叙述中，正确的是（递归次数与每次划分后得到的分区的处理顺序无关）</p><p>16.对n个关键字进行快速排序，最大递归深度为（n），最小递归深度为（nlog2 n）</p><p>7.4 选择排序<br>简单选择排序：空间复杂度O(1)，元素间比较的次数与序列的初始状态无关，始终是n(n-1)/2次，所以时间复杂度始终是O(n^2)，不稳定，每一趟排序都会将一个元素放置到其最终的位置</p><p>堆排序：空间复杂度O(1)，建堆时间O(n)，每次调整的时间复杂度为O(h)，时间复杂度O(nlog2 n)，不稳定</p><p>选择题</p><p>2.简单选择排序算法的比较次数和移动次数分别为（O(n^2)，O(n)）</p><p>4.如果只想得到1000个元素组成的序列中第10个最小元素之前的部分排序的序列，用（堆排序）最快。</p><p>8.向具有n个结点的堆中插入一个新元素的时间复杂度为（O(log2 n)），删除一个元素的时间复杂度为（O(log2 n)）</p><p>9.构建n个记录的初始堆，其时间复杂度为（O(n)），对n个记录进行堆排序，最坏情况下其时间复杂度为（O(nlog2 n)）</p><p>13.下列四种排序方法中，排序过程中的比较次数与序列初始状态无关的是（选择排序法）</p><p>7.5 归并排序和基数排序<br>归并排序：空间复杂度O(n)，时间复杂度O(nlog2 n)，稳定</p><p>基数排序：不是基于比较进行排序的，而是采用多关键字排序思想（即基于关键字各位的大小进行排序的），借助“分配”和“收集”两种操作对单逻辑关键字进行排序。分为最高位优先排序和最低位优先排序。<br>空间复杂度O®，时间复杂度O(d(n+r))，与序列的初始状态无关，稳定*</p><p>7.6 堆排序</p><p><strong>堆排序</strong>（英语：Heapsort）是指利用<a href="https://baike.baidu.com/item/%E5%A0%86">堆</a>这种数据结构所设计的一种<a href="https://baike.baidu.com/item/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95">排序算法</a>。堆是一个近似<a href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91">完全二叉树</a>的结构，并同时满足<strong>堆积的性质</strong>：即子结点的键值或索引总是小于（或者大于）它的父节点</p><p>选择题</p><p>1.以下排序方法中，（C归并排序）在一趟排序后不一定能选出一个元素放在其最终位置上<br>A 简单选择排序 B 冒泡排序 C 归并排序 D 堆排序</p><p>2.（基数排序）不需要进行关键字的比较</p><p>3.平均情况下空间复杂度为O(n)的是（归并排序），最坏情况下空间复杂度为O(n)的是（归并排序、快速排序）</p><p>6.对10TB的数据文件进行排序，应使用的方法是（归并排序）</p><p>8.将两个各有N个元素的有序表合并成一个有序表，最少的比较次数是（N），最多的比较次数是（2N-1）</p><p>11.如果将中国人按照生日（不考虑年份，只考虑月、日）来排序，那么使用下列排序算法中最快的是（基数排序）</p><p>7.6 各种内部排序算法的比较及应用</p><p>选择题</p><p>6.排序趟数与序列的原始状态无关的排序方法是（直接插入排序、简单选择排序、基数排序）</p><p>7.每一趟排序结束都至少能够确定一个元素最终位置的方法是（简单选择排序、快速排序、堆排序）</p><p>11.若将顺序存储更换为链式存储，则算法的时间效率会降低的是（希尔排序、堆排序）</p><p>7.7 外部排序<br>1）外部排序指待排序文件较大，内存一次放不下，需存放在外部介质的文件的排序<br>2）为减少平衡归并中外存读写次数所采取的方法：增大归并路数和减少归并段个数<br>3）利用败者树增大归并路数<br>4）利用置换-选择排序增大归并段长度来减少归并段个数<br>5）由长度不等的归并段，进行多路平衡归并，需要构造最佳归并树</p><p>选择题</p><p>3.置换-选择排序的作用是（用于生成外排序的初始归并段）</p><p>4.最佳归并树在外排序的作用是（设计m路归并排序的优化方案）</p><p>6.在昨m路平衡归并排序的过程中，为实现输入/内部归并/输出的并行处理，需要设置（2m）个输入缓冲区和（2）个输出缓冲区</p>]]></content>
      
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理</title>
      <link href="/SYSU/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
      <url>/SYSU/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="知识框架"><a href="#知识框架" class="headerlink" title="知识框架"></a>知识框架</h2><a id="more"></a> <h2 id="知识梳理"><a href="#知识梳理" class="headerlink" title="知识梳理"></a>知识梳理</h2><h3 id="第1章-计算机系统概述"><a href="#第1章-计算机系统概述" class="headerlink" title="第1章 计算机系统概述"></a>第1章 计算机系统概述</h3><p>1.1 计算机发展历程<br>1）第一代计算机（1946-1957年）——电子管时代：逻辑元件采用电子管，使用机器语言进行编程<br>2）第二代计算机（1958-1964年）——晶体管时代：逻辑元件采用晶体管，软件开始使用高级语言，如Fortran<br>3）第三代计算机（1965-1971年）——中小规模集成电路时代：逻辑元件采用中小规模集成电路，开始有了分时操作系统<br>4）第四代计算机（1972-现在）——超大规模集成电路时代：逻辑元件采用大规模集成电路和超大规模集成电路，并产生了微处理器</p><p>摩尔定律<br>32位、64位指的是机器字长，是指计算机进行一次整数运算所能处理的二进制数据的位数。</p><p>电子计算机可分为电子模拟计算机和电子数字计算机。数字计算机又可按用途分为专用计算机和通用计算机。通用计算机又分为巨型机、大型机、中型机、小型机、微型机和单片机6类。</p><p>计算机按指令和数据流还可分为：<br>1）单指令流和单数据流系统（SISD），也即冯诺依曼体系结构<br>2）单指令流和多数据流系统（SIMD），包括阵列处理器和向量处理器系统<br>3）多指令流和单数据流系统（MISD），这种计算机实际上不存在<br>4）多指令流和多数据流系统（MIMD），包括多处理器和多计算机系统</p><p>选择题</p><p>2.微型计算机的发展以（微处理器）技术为标志</p><p>4.只有当程序执行时才能将源程序翻译成机器语言，并且一次只能解释一行语句，边翻译边执行的是（解释）程序，把汇编语言源程序转变为机器语言程序的过程是（汇编）</p><p>5.到目前为止，计算机中所有的信息仍以二进制方式表示的理由是（由物理器件的性能决定）</p><p>1.2 计算机系统层次结构<br>硬件系统和软件系统共同构成了一个完整的计算机系统。对于某一个功能来说，其既可以用软件实现，也可以用硬件实现，则称为软硬件在逻辑上是等效的。</p><p>早期的冯诺依曼机的特点：<br>1）计算机硬件系统由运算器、存储器、控制器、输入设备、输出设备5大部件组成<br>2）指令和数据以同等地位存于存储器内，并可按地址寻访<br>3）指令和数据均用二进制代码表示<br>4）指令由操作码和地址码组成，操作码用来表示操作的性质，地址码用来表示操作数在存储器中的位置<br>5）指令在存储器内按顺序存放<br>6）早期的冯诺依曼机以运算器为中心，输入/输出设备通过运算器与存储器传送数据</p><p>现代计算机已经发展为以存储器为中心，使I/O操作尽可能地绕过CPU，直接在I/O设备和存储器之间完成，以提高系统的整体运行效率。</p><p>输入设备：键盘、鼠标、扫描仪、摄像机等等<br>输出设备：显示器、打印机<br>存储器：主存储器和辅助存储器<br>主存储器的工作方式是按存储单元的地址进行存取的，称为按地址存取方式。（相联存储器是按内容访问的）<br>地址寄存器MAR用于寻址，其位数对应着存储单元的个数，MAR的长度与PC的长度相等。<br>数据寄存器MDR和存储字长相等。<br>MAR和MDR的位数分别为（地址码长度、存储字长）<br>注意：MAR和MDR虽然是存储器的一部分，但在现代CPU中却是存在于CPU中的，另外后文提到的高速缓存Cache也是存在于CPU中。<br>运算器：算术逻辑单元ALU、通用寄存器（累加器ACC、乘商寄存器MQ、操作数寄存器X、变址寄存器IX、基址寄存器BR）、程序状态寄存器PSW<br>控制器：程序计数器PC、指令寄存器IR、控制单元CU</p><p>系统软件、应用软件<br>注意：数据库管理系统DBMS和数据库系统DBS是有区别的，DBMS是系统软件，而DBS一般由数据库、数据库管理系统、数据库管理员DBA和应用系统构成</p><p>机器语言是计算机唯一可以直接识别和执行的语言；<br>汇编语言的程序必须经过一个称为汇编程序的系统软件的翻译，将其转换为计算机的机器语言后，才能在计算机的硬件系统上执行；<br>高级语言需要经过编译程序编译成汇编语言程序，然后经过汇编操作得到机器语言程序，或者直接由高级语言程序翻译成机器语言程序。</p><p>注意：(PC)指程序计数器PC中存放的内容，括号不能省略，即(PC)+1-&gt;PC不能写成PC+1-&gt;PC</p><p>选择题</p><p>1.完整的计算机系统应包括（配套的硬件系统和软件系统）</p><p>2.冯诺依曼机的基本工作方式是（控制流驱动方式）</p><p>4.冯诺依曼计算机中指令和数据均以二进制形式存放在存储器中，CPU区分它们的依据是（指令周期的不同阶段）</p><p>9.MAR和MDR的位数分别为（地址码长度、存储字长）</p><p>12.一个8位的计算机系统以16位来表示地址，则该计算机系统有（2^16=65536）个地址空间</p><p>16.将高级语言源程序转换为机器级目标代码文件的程序是（编译程序）</p><p>20.相联存储器（既可以按地址寻址又可以按内容寻址）</p><p>1.3 计算机的性能指标<br>机器字长是指计算机进行一次整数运算（即定点整数运算）所能处理的二进制数据的位数，一般等于内部寄存器的大小，字长越长，数的表示范围越大，计算精度就越高。</p><p>数据通路带宽是指数据总线一次所能并行传送信息的位数。</p><p>吞吐量：系统吞吐量主要取决于主存的存取周期<br>响应时间：通常包括CPU时间（运行一个程序所花费的时间）与等待时间<br>CPU时钟周期：即主频的倒数，它是CPU中最小的时间单位<br>主频（CPU时钟频率）：主频的倒数是CPU时钟周期，对于同一个型号的计算机，其主频越高，完成指令的一个执行步骤所用的时间越短，执行指令的速度越快。<br>CPI：执行一条指令所需的时钟周期数<br>CPU执行时间，指运行一个程序所花费的时间</p><p>CPU执行时间=CPU时钟周期数/主频=（指令条数*CPI）/主频<br>CPU的性能（CPU执行时间）取决于三个要素：主频，每条指令执行所用的时钟周期数（CPI）、指令条数</p><p>MIPS：每秒执行多少百万条指令。MIPS=指令条数/（执行时间*10^6）=主频/CPI<br>MFLOPS：每秒执行多少百万次浮点计算<br>GFLOPS：每秒执行多少十亿次浮点计算<br>TFLOPS：每秒执行多少万亿次浮点计算</p><p>选择题</p><p>4.存储字长是指（存放在一个存储单元中的二进制代码位数）</p><p>6.下列关于机器字长、指令字长和存储字长的说法中，正确的是（三者在数值上可能不等、存储字长是存放在一二存储单元中的二进制代码位数，存储字长是MDR的位数）</p><p>7.32位微机是指该计算机所用CPU（B能同时处理32位的二进制数）<br>A 具有32位寄存器 B 能同时处理32位的二进制数 C 具有32个寄存器 D 能处理32个字符</p><p>8.用于科学计算的计算机中，标志系统性能的最有用的参数是（C MFLOPS）（科学计算：评估浮点运算的性能）<br>A 主时钟频率 B 主存容量 C MFLOPS D MIPS</p><p>9.若一台计算机的机器字长为4字节，则表明该机器（在CPU中能够作为一个整体处理32位的二进制代码）</p><p>10.在CPU的寄存器中，（B指令寄存器）对用户是完全透明的<br>A 程序计数器 B 指令寄存器 C 状态寄存器 D 通用寄存器</p><p>11.计算机操作的最小单位时间是（A 时钟周期）<br>A 时钟周期 B 指令周期 C CPU周期（又称机器周期，由多个时钟周期组成） D 中断周期</p><p>12.CPU的CPI与下列哪个因素无关（A 时钟频率）<br>A 时钟频率 B 系统结构 C 指令集 D 计算机组织</p><p>15.下列关于“兼容”的叙述，正确的是（指计算机软件或硬件的通用性，通常在同一系列不同型号的计算机间通用）</p><p>1.5 常见问题和易混淆知识点<br>在逻辑功能上，软件和硬件是等效的。在计算机系统中，许多功能既可以由硬件直接实现，也可以在硬件的配合下由软件实现。</p><p>翻译程序是指把高级语言源程序翻译成机器语言程序（目标代码）的软件，可以分为两种：一种是编译程序，将高级语言源程序一次全部翻译成目标程序，只要源程序不变，就无须重新编译，目标程序与体系结构相关，但仍不是计算机硬件能够直接执行的程序；另一种是解释程序，翻译一句执行一句，并且不会生成目标程序。<br>汇编程序把汇编语言源程序翻译成机器语言程序。</p><p>在计算机领域中，站在某一类用户的角度，如果感觉不到某个事物或属性的存在，即“看”不到某个事物或属性，则称为“对该用户而言，某个事物或属性是透明的”。在CPU中，IR、MAR和MDR对各类程序员都是透明的。</p><p>机器字长：计算机能直接处理的二进制数据的位数，机器字长一般等于内部寄存器的大小，它决定了计算机的运算精度。<br>指令字长：一个指令字中包含二进制代码的位数。<br>存储字长：一个存储单元存储二进制代码的长度。</p><h3 id="第2章-数据的表示和运算"><a href="#第2章-数据的表示和运算" class="headerlink" title="第2章 数据的表示和运算"></a>第2章 数据的表示和运算</h3><p>2.1 数制与编码<br>二进制转换为八进制和十六进制：以小数点为界，其整数部分，从小数点开始往左数，将一串二进制数分为3位（八进制）一组或4位（十六进制）一组，在数的最左边根据需要加“0”补齐；对于小数部分，从小数点开始往右数，将一串二进制数分为3位（八进制）一组或4位（十六进制）一组，在数的最右边根据需要加“0”补齐。<br>八进制或十六进制转换为二进制：略。<br>任意进制转换为十进制：略<br>十进制转换为任意进制：基数乘除法。对于整数部分用除基取余法；对于小数部分用乘基取整法。</p><p>注意：并不是每一个十进制小数都可以准确地用二进制表示，但任意一个二进制小数都可以用十进制小数表示。</p><p>二进制编码的十进制数（BCD码）：<br>8421码：设其各位的数值为b3、b2、b1、b0，则权值从高到低依次为8/4/2/1，则它表示的十进制数为D=8b3+4b2+2b1+1b0。如果两个8421码相加之和小于等于(1001)，即(9)，则不需要修正；如果相加之和大于等于(1010)，即(10)，则要加6修正。<br>余3码：在8421码的基础上加上(0011)形成的，即每个数都多余“3”<br>2421码：权值由高到低分别为2/4/2/1，特点是大于等于5的4位二进制数中最高位为1，小于5的最高位为0。如5为1011而不是0101。</p><p>小端模式：先存储低位字节、后存储高位字节的顺序（即从低位字节向高位字节顺序）存放字符串的内容<br>大端模式：先存储高位字节、后存储低位字节的顺序（即从高位字节向低位字节顺序）存放字符串的内容</p><p>奇偶校验码：在原编码上加一个校验位，它的码距等于2，可以检测出一位错误（或奇数位错误），但不能确定出错的位置，也不能够检测出偶数位错误，增加的冗余位称为奇偶校验位。<br>奇校验码：整个校验码（有效信息位和校验位）中“1”的个数为奇数<br>偶校验码：整个校验码（有效信息位和校验位）中“1”的个数为偶数</p><p>海明（汉明）校验码：不但可以发现错位，还能指出错位的位置，为自动纠错提供了依据。<br>L-1=D+C且D≥C，即编码最小码距L越大，则其检测错误的位数D越大，纠正错误的位数C也越大，且纠错能力恒小于或等于检错能力。<br>信息位n和校验位k应满足n+k≤2^k-1<br>求海明码的步骤（略）</p><p>循环冗余校验码（CRC）：在K为信息码后再拼接R位的校验码，整个编码的长度为N位</p><p>选择题</p><p>16.能发现两位错误并能纠正1位错的编码是（海明码）</p><p>17.在CRC中，接收端检测出某一位数据错误后，纠正的方法是（D）<br>A 请求重发 B 删除数据 C 通过余数值自行纠正 D 以上均可</p><p>18.在大量数据传送过程中，常用且有效的检测法是（CRC）</p><p>2.2 定点数的表示与运算<br>原码表示法：用机器数的最高位表示该数的符号，其余的各位表示数的绝对值<br>纯小数的原码定义：若字长为n+1，则原码小数的表示范围为-(1-2^-n)≤x≤1-2 ^-n<br>[x] = x，1&gt;x≥0<br>[x] = 1-x = 1+|x|，0≥x&gt;-1<br>纯整数的原码定义：若字长为n+1，则原码小数的表示范围为-(2^n-1)≤x≤2 ^n-1<br>[x] = 0,x，2^n&gt;x≥0<br>[x] = 2^n-x = 2 ^n+|x|，0≥x&gt;-2 ^n<br>注意：真值零的原码表示有正零和负零两种形式：[+0]=00000, [-0]=10000</p><p>补码表示法：<br>纯小数的补码定义：若字长为n+1，则原码小数的表示范围为-1≤x≤1-2 ^-n<br>[x] = x，1&gt;x≥0<br>[x] = 2+x = 2-|x|，0≥x&gt;-1<br>纯整数的补码定义：若字长为n+1，则原码小数的表示范围为-2^n≤x≤2 ^n-1<br>[x] = 0,x，2^n&gt;x≥0<br>[x] = 2^(n+1)+x = 2 ^(n+1)-|x|，0≥x≥-2 ^n<br>注意：真值零的补码表示是唯一的：[+0]=[-0]=0.0000</p><p>由原码求补码、由补码求原码：<br>对于正数，补码与原码的表示相同。<br>对于负数，原码符号位不变，数值部分按位取反，末位加1.</p><p>反码表示法：<br>纯小数的原码定义：若字长为n+1，则原码小数的表示范围为-(1-2^-n)≤x≤1-2 ^-n<br>[x] = x，1&gt;x≥0<br>[x] = 2-2^-n +x，0≥x&gt;-1<br>纯整数的原码定义：若字长为n+1，则原码小数的表示范围为-(2^n-1)≤x≤2 ^n-1<br>[x] = 0,x，2^n&gt;x≥0<br>[x] = 2^(n+1)-1+x，0≥x&gt;-2 ^n<br>注意：真值零的原码表示有正零和负零两种形式：[+0]=0.0000, [-0]=1.1111</p><p>移码表示法：移码常用来表示浮点数的阶码，它只能表示整数。<br>[x] = 2^n+x（其中2 ^n&gt;x≥-2 ^n，机器字长为n+1）<br>注意：<br>1）移码中零的表示唯一，[+0]=2^n+0=[-0]=2 ^n-0=100…0（n个0）<br>2）一个真值的移码和补码仅差一个符号位，补码的符号位取反即得移码（1表示正，0表示负，这与其他机器数的符号位取值正好相反）<br>3）移码全0时，对应真值的最小值-2^n；移码全1时，对应真值的最大值2 ^n -1<br>4）移码大真值就大，移码小真值就小</p><p>不同机器数算术移位后的空位填补规则</p><p>码制    添加代码<br>正数    原码、补码、反码    0<br>负数    原码    0<br>负数    补码    左移添0，右移添1<br>负数    反码    1<br>逻辑移位：将操作数当做无符号数看待，逻辑左移时，高位移丢，低位添0；逻辑右移时，低位移丢，高位添0.<br>注意：逻辑移位不管左移还是右移，都是添0.</p><p>溢出是指运算结果超过了数的表示范围，称大于机器所能表示的最大正数为上溢，小于机器所能表示的最小负数为下溢。<br>仅当两个符号相同的数相加，或两个符号相异的数相减才可能产生溢出。</p><p>补码定点数加减运算溢出判断的方法有3种：<br>1）采用一位符号位：只要参加运算的两个数符号相同，结果又与原操作数符号不同，则表示结果溢出。<br>2）采用双符号位：运算结果的两个符号位相同，表示未溢出；运算结果的两个符号位不同，表示溢出，此时最高位符号位代表真正的符号。<br>00，表示结果为正数，无溢出；<br>01，表示结果正溢出；<br>10，表示结果负溢出；<br>11，表示结果为负数，无溢出。<br>3）采用一位符号位根据数据位的进位情况判断溢出：如果符号位的进位与最高数位的进位相同，说明没有溢出，否则表示发生溢出。</p><p>选择题</p><p>6.对真值0表示形式唯一的机器数是（补码和移码）</p><p>9.如果X为负数，由[X]补求[-X]补是将（[X]补连同符号位一起变反，末位加1）</p><p>10.8位原码能表示的不同数据有（255）<br>要去掉0,0的原码表示有两种，若将题中原码改为反码，也是255，但若改为补码或移码，则有256</p><p>47.原码乘法是（先取操作数绝对值相乘，符号位单独处理）</p><p>48.x、y为定点整数，其格式为1位符号位，n位数值位，若采用补码一位乘法实现乘法运算，则最多需要（n+1）次加法运算</p><p>49.在原码一位乘法中，（符号位不参加运算）</p><p>50.原码乘法时，符号位单独处理乘积的方式是（两个操作数符号相“异或”）</p><p>51.实现N位（不包括符号位）补码一位乘时，乘积为（2N+1）位</p><p>52.在原码不恢复余数除法（又称原码加减交替法）的算法中，（仅当最后一步不够减时，才恢复一次余数）</p><p>53.下列关于补码除法正确的是（补码不恢复余数除法中，异号相除时，够减商0，不够减商1）</p><p>54.在计算机中，通常用来表示主存地址的是（无符号数）</p><p>2.3 浮点数的表示与运算<br>IEEE754标准中，规格化的短浮点数的真值为(-1)^S1.M2 ^(E-127)<br>规格化长浮点数的真值为(-1)^S1.M2 ^(E-1023)<br>其中，s=0表示正数，s=1表示负数；短浮点数E的取值为1~254（8位表示），M为23位，共32位；长浮点数E的取值为1 ~2046（11位表示），M为52位，共64位。</p><p>浮点数的加减运算：<br>1）对阶<br>2）尾数求和<br>3）规格化<br>4）舍入<br>5）溢出判断</p><p>选择题</p><p>6.长度相同但格式不同的两种浮点数，假设前者阶码长、尾数短，后者阶码短、尾数长，则它们可表示的数的范围和精度为（前者可表示的数的范围大但精度低）</p><p>7.长度相同但格式不同的两种浮点数，假设前者基数大，后者基数小，则它们可表示的数的范围和精度为（前者可表示的数的范围大但精度低）</p><p>19.在浮点数编码表示中，（基数）在机器数中不出现，是隐含的</p><p>21.采用规格化的浮点数最主要是为了（增加数据的表示精度）</p><p>2.4 算术逻辑单元ALU<br>运算器由算术逻辑单元ALU、累加器、状态寄存器和通用寄存器等组成。运算器的操作和操作种类由控制器决定，运算器处理的数据来自存储器，处理后的结果数据通常送回存储器，或暂存在运算器中。</p><p>一位全加器：<br>和表达式：Si=Ai⊕Bi⊕Ci-1（Ai、Bi、Ci-1有奇数个1，则Si=1，否则Si=0）<br>进位表达式：Ci=AiBi+(Ai⊕Bi)Ci-1</p><p>串行加法器：只有一个全加器<br>并行加法器：由多个全加器组成，提高并行加法器速度的关键是尽量加快进位产生和传递的速度。<br>进位表达式：Ci=Gi+PiCi-1，Gi是进位产生函数，Gi=AiBi；Pi是进位传递函数，Pi=Ai⊕Bi<br>并行加法器的进位通常分为串行进位和并行进位<br>分组并行进位方式：<br>单级先行进位方式又称为组内并行、组间串行进位方式；多组先行进位方式又称为组内并行、组间并行进位方式。</p><p>选择题</p><p>3.在串行进位的并行加法器中，影响加法器运算速度的关键因素是（进位传递延迟）</p><p>6.组成一个运算器需要多个部件，但下面（D地址寄存器）不是组成运算器的部件<br>A 状态寄存器 B 数据总线 C ALU D 地址寄存器（属于存储器）</p><h3 id="第3章-存储系统"><a href="#第3章-存储系统" class="headerlink" title="第3章 存储系统"></a>第3章 存储系统</h3><p>3.1 存储器的层次结构<br>按在计算机中的作用（层次）分类：主存储器、辅助存储器、高速缓冲存储器Cache<br>按存储介质分类：磁表面存储器（磁盘、磁带）、磁芯存储器半导体存储器（MOS型存储器、双极型存储器）、光存储器（光盘）<br>按存取方式分类：随机存储器（静态RAM、动态RAM）、只读存储器（ROM）、串行访问存储器（顺序存取存储器（磁带）、直接存取存储器（磁盘））<br>按信息的可保存性分类：易失性存储器（RAM）、非易失性存储器（ROM、磁表面存储器、光存储器）</p><p>存储容量=存储字数*字长，存储字数表示存储器的地址空间大小，字长表示一次存取操作的数据量</p><p>存储速度：数据传输率=数据的宽度/存储周期<br>存取时间Ta：指从启动一次存储器操作到完成该操作所经历的时间，分为读出时间和写入时间<br>存取周期Tm：指存储器进行一次完整的读写操作所需的全部时间，即连续两次独立地访问存储器操作（读或写操作）之间所需的最小时间间隔<br>主存带宽Bm：又称数据传输率，表示每秒从主存进出信息的最大数量<br>存取时间不等于存储周期，通常存储周期大于存取时间。</p><p>选择题</p><p>2.磁盘属于（直接存取存储器（DAM））类型的存储器</p><p>5.相联存储器是按（内容指定方式和地址指定方式相结合）进行寻址的存储器</p><p>3.2 存储器的层次化结构<br>“Cache-主存”：解决CPU和主存速度不匹配的问题<br>“主存-辅存”：解决存储系统的容量问题</p><p>Cache、主存能与CPU直接交换信息，辅存则要通过主存与CPU交换信息；主存与CPU、Cache、辅存都嗯呢该交换信息</p><p>注意：主存和Cache之间的数据调动是由硬件自动完成的，对所有程序员均是透明的；而主存和辅存之间的数据调动是由硬件和操作系统共同完成的，对应用程序员是透明的。<br>Cache中的内容只是主存中内容的一部分，主存中的内容只是辅存中内容的一部分</p><p>选择题</p><p>4.存储器从速度最快到最慢的排列顺序是（寄存器-Cache-主存-辅存）</p><p>3.3 半导体随机存储器<br>1）存储矩阵<br>2）译码驱动<br>3）读写电路<br>4）读写控制线<br>5）片选线：确定哪个存储芯片被选中<br>6）地址线：单向输入<br>7）数据线：双向的，数据线数和地址线数共同反映存储芯片容量的大小。如地址线10根，数据线8根，则芯片容量=2^10*8=8K位</p><p>静态随机存储器SRAM：用双稳态触发器（六管MOS）来记忆信息，属于易失性半导体存储器，一般用来组成高速缓冲存储器<br>动态随机存储器DRAM：利用存储元电路中栅极电容上的电荷来存储信息，一般用来组成大容量主存系统。刷新方式有三种：集中刷新、分散刷新、异步刷新</p><p>SRAM    DRAM<br>存储信息    触发器    电容<br>破坏性读出    非    是<br>需要刷新    不要    需要<br>送行列地址    同时送    分两次送<br>运行速度    快    慢<br>集成度    低    高<br>发热量（功耗）    大    小<br>存储成本    高    低<br>主要用途    高速缓存    主机内存<br>掩膜式只读存储器MROM：写入以后任何人都无法改变其内容<br>一次可编程只读存储器PROM：允许用户用专门设备写入程序，写入后内容就无法改变<br>可擦除可编程只读存储器EPROM：允许用户写入信息，而且可以对其内容进行多次改写<br>闪速存储器Flash Memory：在不加电时仍可长期保存信息且能进行快速擦除重写<br>固态硬盘SSD：用固态电子存储芯片阵列而制成的硬盘，由控制单元和存储单元（Flash芯片）组成</p><p>选择题</p><p>3.若RAM中每个存储单元为16位，则下面所述正确的是（数据线是16位）</p><p>4.DRAM的刷新是以（行）为单位的</p><p>14.U盘属于（C只读存储器）类型的存储器<br>A 高速缓存 B 主存 C 只读存储器 D 随机存取存储器</p><p>3.4 主存储器与CPU的连接<br>1）主存储器通过数据总线、地址总线和控制总线与CPU连接<br>2）数据总线的位数与工作频率的乘积正比于数据传输率<br>3）地址总线的位数决定了可寻址的最大内存空间<br>4）控制总线（读/写）指出总线周期的类型和本次输入/输出操作完成的时刻</p><p>主存容量的扩展：位扩展法、字扩展法、字位同时扩展法</p><p>CPU要实现对存储单元的访问，首先要选择存储芯片，即进行片选，然后再为选中的芯片依地址码选择相应的存储单元，以进行数据的存取，即进行字选。<br>片选信号的产生分为线选法和译码片选法。</p><p>3.5 双口RAM和多模块存储器<br>双端口RAM：指同一个存储器有左、右两个独立的端口，分别具有两组相互独立的地址线、数据线和读写控制线，允许两个独立的控制器同时异步地访问存储单元。<br>1）两个端口不同时对同一地址单元存取数据（正常）<br>2）两个端口同时对同一地址单元读出数据（正常）<br>3）两个端口同时对同一地址单元写入数据（可能会写入错误）<br>4）两个端口同时对同一地址单元，一个写入数据，另一个读出数据（出现读出错误）</p><p>多模块存储器：<br>单体多字存储器：存储器中只有一个存储体，每个存储单元存储m个字，总线宽度也为m个字。一次并行读出m个字，地址必须顺序排列并处于同一存储单元<br>多体并行存储器：由多体模块组成，每个模块都有相同的容量和存取速度，各模块都有独立的读写控制电路、地址寄存器和数据寄存器，既能并行工作，又能交叉工作<br>多体并行存储器由分为高位交叉编址（顺序方式）和低位交叉编址（交叉方式）<br>高位交叉编址：高位地址表示体号，低位地址为体内地址<br>低位交叉编址：低位地址为体号，高位地址为体内地址<br>流水线方式，存储器交叉模块数应大于等于m=T/r（T为存取周期，r为总线传送周期），连续读取m个字所需时间为t1=T+(m-1)r，而顺序方式连续读取m个字所需时间为t2=mT</p><p>3.6 高速缓冲存储器<br>高速缓冲技术就是利用程序访问的局部性原理。<br>当CPU发出读请求时，如果访存地址在Cache中命中，就将此地址转换成Cache地址，直接对Cache进行读操作，与主存无关；如果Cache不命中，则仍需访问主存，并把此字所在的块一次从主存调入Cache内。若此时Cache已满，则需根据某种替换算法，用这个块替换掉Cache中原来的某块信息。<br>注意：CPU与Cache之间的数据交换以字位单位，而Cache与主存之间的数据交换以Cache块为单位</p><p>Cache命中率H=Nc/(Nc+Nm)<br>平均访问时间Ta=Htc+(1-H)tm</p><p>直接映射：j = i mod 2^c（j是Cache的块号，又称行号，i是主存的块号，2 ^c是Cache的总块数）<br>地址结构为：</p><p>主存字块标记    Cache字块地址    字块内地址<br>全相联映射：<br>地址结构为：</p><p>主存字块标记    字块内地址<br>组相联映射：将Cache空间分成大小相同的组，主存的一个数据块可以装入到一组内的任何一个位置，即组间采取直接映射，而组内采取全相联映射。<br>j = i mod Q（j是Cache的组号，i是主存的块号，Q是Cache的组数，Q=1变为全相联映射，Q=Cache块数变为直接映射）<br>地址结构为：</p><p>主存字块标记    组地址    字块内地址<br>置换算法：<br>1）随机算法RAND：没有依据程序访问的局部性原理<br>2）先进先出算法FIFO：没有依据程序访问的局部性原理<br>3）近期最少使用算法LRU<br>4）最不经常使用算法LFU</p><p>Cache写策略<br>对于Cache写命中：<br>1）全写法（写直通法write-through）：必须把数据同时写入Cache和主存<br>2）写回法（write-back）：只修改Cache的内容，而不立即写入主存，只有当此块被换出时才写回主存<br>对于Cache写不命中：<br>1）写分配法（write-allocate）：加载主存中的块到Cache中，然后更新这个Cache块<br>2）非写分配法（not-write-allocate）：只写入主存，不进行调块<br>非写分配法通常与全写法合用，写分配法通常和写回法合用。</p><p>3.7 虚拟存储器<br>主机和联机工作的辅存共同构成了虚拟存储器，对于应用程序而言，虚拟存储器是透明的。</p><p>页式虚拟存储器：以页为基本单位，虚拟空间和主存空间都被划分成同样大小的页，主存的页称为实页，虚存的页称为虚页。把虚拟地址分为两个字段：虚页号和页内地址。<br>优点是页面的长度固定，页表简单，调入方便。缺点是由于程序不可能正好是页面的整数倍，最后一页的零头将无法利用而造成浪费，并且页不是逻辑上独立的实体，所以处理、保护和共享都不及段式虚拟存储器方便。</p><p>段式虚拟存储器：段是按程序的逻辑结构划分的，各个段的长度因程序而异。把虚拟地址分为两部分：段号和段内地址。<br>优点是段的分界与程序的自然分界相对应，因而具有逻辑独立性，使它易于编译、管理、修改和保护，也便于多道程序的共享；缺点是因为段长度可变，分配空间不便，容易在段间留下碎片，不好利用，造成浪费。</p><p>段页式虚拟存储器：把程序按逻辑结构分段，每段再划分为固定大小的页，主存空间也划分为大小相等的页，程序对主存的调入、调出仍以页为基本传送单位。每个程序对应一个段表，每段对应一个页表，段的长度必须是页长的整数倍，段的起点必须是某一页的起点。虚地址分为段号、段内页号、页内地址三部分。<br>优点是兼具页式和段式虚拟存储器的优点，可以按段实现共享和保护。缺点是在地址变换过程中需要两次查表，系统开销比较大。</p><p>快表TLB依据程序执行的局部性原理，快表只是慢表Page的一个副本，而且只存放了慢表中很少的一部分。<br>查找时，快表和慢表同时进行，快表由于根据内容指定地址，一般使用相联存储器。<br>注意：TLB是Page的一个很小的副本，所以若TLB命中则Page一定命中。<br>在同时具有虚拟页式存储器（有TLB）和Cache的系统中，访问顺序为TLB-&gt;页表-&gt;Cache-&gt;主存</p><p>虚拟存储器和Cache的不同之处：<br>1）Cache主要解决系统速度，而虚拟存储器是为了解决主存容量<br>2）Cache全由硬件实现，是硬件存储器，对所有程序员透明；而虚拟存储器由OS和硬件共同实现，是逻辑上的存储器，对系统程序员不透明，但对应用程序员透明。<br>3）虚拟存储器系统不命中时对系统性能影响更大。<br>4）Cache不命中时主存能和CPU直接通信，同时将数据调入Cache中；而虚拟存储器系统不命中时，只能先由硬盘调入内存中，而不能直接和CPU通信。</p><p>选择题</p><p>2.虚拟存储管理系统的基础是程序访问的局部性原理，此理论的基本含义是（在程序的执行过程中，程序对主存的访问是不均匀的）</p><p>6.虚存（对应用程序员透明，对系统程序员不透明）</p><p>7.在虚拟存储器中，当程序正在执行时，由（操作系统）完成地址映射。</p><p>8.采用虚拟存储器的主要目的是（扩大主存储器的存储空间）</p><h3 id="第4章"><a href="#第4章" class="headerlink" title="第4章"></a>第4章</h3><p>4.1 指令格式<br>指令的长度是指一条指令中所包含的二进制代码的位数。指令字长取决于操作码的长度、操作数地址码的长度和操作数地址的个数。指令长度与机器字长没有固定的关系。</p><p>零地址指令：<br>1）不需要操作数的指令：空操作指令、停机指令、关中断指令<br>2）零地址的运算类指令仅用在堆栈计算机中<br>一地址指令：<br>1）只有目的操作数的单操作数指令，按A1地址读取操作数，进行OP操作后，结果存回原地址，即OP(A1)-&gt;A，如加1，减1，求反、求补等<br>2）隐含约定目的地址的双操作数指令，按指令地址A1可读取源操作数，指令可隐含约定另一个操作数由ACC（累加器）提供，运算结果也存放在ACC中，即(ACC)OP(A1)-&gt;ACC<br>二地址指令：给出目的操作数和源操作数的地址，其中目的操作数地址还用于保存本次的运算结果，即(A1)OP(A2)-&gt;A1<br>三地址指令：(A1)OP(A2)-&gt;A3<br>四地址指令：(A1)OP(A2)-&gt;A3，A4=下一条将要执行指令的地址</p><p>选择题</p><p>9.能够完成两个数的算术运算的单地址指令，地址码指明一个操作数，另一个操作数来自于（隐含寻址）方式</p><p>12.在指令格式中，采用扩展操作码设计方案的目的是（保持指令字长度不变而增加指令的数量）</p><p>指令寻址方式<br>隐含寻址：在指令中隐含着操作数的地址，累加器ACC对单地址指令格式来说是隐含地址<br>优点：有利于缩短指令字长<br>缺点：需增加存储操作数或隐含地址的硬件</p><p>立即（数）寻址：指出的是操作数本身，又称为立即数<br>优点：指令在执行阶段不访问主存，指令执行时间最短<br>缺点：A的位数限制了立即数的范围</p><p>直接寻址：指令字中的形式地址A就是操作数的真实地址EA，即EA=A<br>优点：简单，指令在执行阶段仅访问一次主存，不需要专门计算操作数的地址<br>缺点：A的位数决定了该指令操作数的寻址范围，操作数的地址不易修改</p><p>间接寻址：指令的地址字段给出的形式地址不是操作数的真正地址，而是操作数有效地址所在的存储单元的地址，也就是操作数地址的地址，即EA=(A)<br>优点：可扩大寻址范围，便于编制程序（用间接寻址可以方便地完成子程序返回）<br>缺点：指令在执行阶段要多次访存（一般问到扩大寻址范围通常都是寄存器间接寻址）</p><p>寄存器寻址：在指令字中直接给出操作数所在的寄存器编号，即EA=Ri，其操作数在由Ri所指的寄存器内<br>优点：指令在执行阶段不访问主存，只访问寄存器，执行速度快，支持向量/矩阵运算<br>缺点：寄存器价格昂贵，寄存器个数有限</p><p>寄存器间接寻址：在寄存器Ri中给出的不是一个操作数，而是操作数所在主存单元的地址，即EA=(Ri)<br>优点：与一般间接寻址相比速度更快<br>缺点：需要访问主存</p><p>相对寻址：把程序计数器PC的内容加上指令格式中的形式地址A而形成操作数的有效地址，即EA=(PC)+A<br>优点：操作数的地址不是固定的，随着PC的变化而变化，并且与指令地址之间总是相差一个固定值，因此便于程序浮动，广泛应用于转移指令</p><p>基址寻址：将CPU中基址寄存器（BR）的内容加上指令格式中的形式地址A，而形成操作数的有效地址，即EA=(BR)+A<br>优点：可扩大寻址范围，用户不必考虑自己的程序位于主存的哪一空间区域，故有利于多道程序设计，以及用于编制浮动程序</p><p>变址寻址：有效地址EA等于指令字中的形式地址A与变址寄存器IX的内容相加之和，即EA=(IX)+A<br>优点：可扩大寻址范围，用于处理数组问题</p><p>堆栈寻址：硬堆栈、软堆栈</p><p>寻址方式    有效地址    访存次数<br>隐含寻址    程序指定    0<br>立即寻址    A即是操作数    0<br>直接寻址    EA=A    1<br>一次间接寻址    EA=(A)    2<br>寄存器寻址    EA=Ri    0<br>寄存器间接一次寻址    EA=(Ri)    1<br>相对寻址    EA=(PC)+A    1<br>基址寻址    EA=(BR)+A    1<br>变址寻址    EA=(IX)+A    1<br>选择题</p><p>2.指令系统中采用不同寻址方式的目的是（可缩短指令字长，扩大寻址空间，提高编程的灵活性）</p><p>3.直接寻址的无条件转移指令的功能是将指令中的地址码送入（程序计数器PC）</p><p>4.为了缩短指令中某个地址段的位数，有效的方法是采取（寄存器寻址）</p><p>5.简化地址结构的基本方法是尽量采用（隐含地址）</p><p>6.在指令寻址的各种方式中，获取操作数最快的方式是（立即寻址）</p><p>9.（变址寻址）便于处理数组问题</p><p>11.相对寻址方式总，指令所提供的相对地址实质上是一种（以下条指令在内存中首地址为基准位置的偏移量）</p><p>12.下列寻址方式中，最适合按下标顺序访问一维数组元素的是（变址寻址）</p><p>19.对按字寻址的机器，程序计数器和指令寄存器的位数各取决于（存储器的字数、指令字长）</p><p>4.3 CISC和RISC的基本概念<br>类别    CISC    RISC<br>指令系统    复杂，庞大    简单，精简<br>指令数目    一般大于200条    一般小于100条<br>指令字长    不固定    固定<br>可访存指令    不加限制    只有Load/Store指令<br>各种指令执行时间    相差较大    绝大多数在一个周期内完成<br>各种指令使用频度    相差很大    都比较常用<br>通用寄存器数量    较少    多<br>目标代码    难以用优化编译生成高效的目标代码程序    采用优化的编译程序，生成代码较为高效<br>控制方式    绝大多数为微程序控制    绝大多数为组合逻辑控制<br>指令流水线    可以通过一定方式实现    必须实现</p><h3 id="第5章-中央处理器"><a href="#第5章-中央处理器" class="headerlink" title="第5章 中央处理器"></a>第5章 中央处理器</h3><p>5.1 CPU的功能和基本结构<br>具体功能：指令控制、操作控制、时间控制、数据加工、中断处理</p><p>运算器：主要由算术逻辑单元、暂存寄存器、累加寄存器、通用寄存器组、程序状态字寄存器、移位器、计数器等组成<br>控制器：主要由程序计数器、指令寄存器、指令译码器、存储器地址寄存器、存储器数据寄存器、时序系统和微操作信号发生器等组成</p><p>注意：通用寄存器组、程序状态字寄存器对用户是可见的，存储器地址寄存器、存储器数据寄存器、指令寄存器对用户是透明的，不可见的。</p><p>选择题</p><p>1.汇编语言程序员可见的是（程序计数器PC）</p><p>3.通用寄存器是（可编程指定多种功能的寄存器）</p><p>4.CPU中保存当前正在执行指令的寄存器是（指令寄存器）</p><p>5.CPU中跟踪后继指令地址的寄存器是（程序计数器）</p><p>6.条件转移指令执行时所依据的条件来自（标志寄存器）</p><p>7.所谓n位的CPU，这里的n是指（数据总线线数）（CPU一次能处理的数据的位数）</p><p>11.在一条无条件跳转指令的指令周期内，PC的值被修改（2）次</p><p>12.程序计数器的位数取决于（存储器的容量）</p><p>13.指令寄存器的位数取决于（指令字长）</p><p>14.CPU中通用寄存器的位数取决于（机器字长）</p><p>15.CPU中的通用寄存器（可以存放数据和地址）</p><p>19.指令译码是对（指令的操作码字段）进行译码</p><p>20.CPU中不包括（地址译码器）（地址译码器在主存中）</p><p>22.间址周期结束时，CPU内寄存器MDR中的内容为（操作数地址）</p><p>5.2 指令执行过程<br>CPU从主存中取出并执行一条指令所需的全部时间称为指令周期，也就是CPU完成一条指令的时间。<br>一个完整的指令周期应包括取指、间址、执行和中断四个周期。<br>注意：中断周期中进栈操作是将SP减1，和传统意义上的进栈操作相反，因为计算机的堆栈中都是向低地址增加，所以进栈操作是减1，不是加1.</p><p>取指周期是根据PC中的内容从主存中取出指令代码并存放在指令寄存器IR中，取指令的同时，PC加1<br>间址周期是取操作数有效地址<br>执行周期是根据IR中的指令字的操作码和操作数通过ALU操作产生执行结果<br>中断周期是处理中断请求，假设程序断点存入堆栈中，并用SP表示栈顶地址，而且进栈操作是先修改栈顶指针，后存入数据。</p><p>单指令周期：对所有指令都选用相同的时间来完成，指令之间串行执行，指令周期取决于执行时间最长的指令的执行时间。<br>多指令周期：指令之间串行执行，不再要求所有指令占用相同的执行时间<br>流水线方案：指令之间并行执行，尽量让多条指令同时执行，但各自处在不同的执行步骤中</p><p>选择题</p><p>1.冯诺依曼计算机中指令和数据均以二进制形式存放在存储器中，CPU区分它们的依据是（指令周期的不同阶段）</p><p>3.计算机工作的最小时间周期是（时钟周期）</p><p>4.采用DMA方式传递数据时，每传送一个数据就要占用（存取周期）</p><p>6.指令（总是根据程序计数器）从主存中读出</p><p>9.取指操作是自动进行的，也就是说控制器不需要得到相应的指令</p><p>11.由于CPU内部操作的速度较快，而CP访问一次存储器的时间较长，因此机器周期通常由（存取周期）来确定</p><p>13.执行各条指令的机器周期数可变，各机器周期的长度可变</p><p>14.以下关于间址周期的描述中正确的是（C）<br>A 所有指令的间址操作都是相同的<br>B 凡是存储器间接寻址的指令，它们的操作都是相同的<br>C 对于存储器间接寻址和寄存器间接寻址，它们的操作是不同的<br>D 都不对</p><p>15.CPU响应中断的时间是（一条指令执行结束）</p><p>16.以下叙述中，错误的是（B）<br>A 取指操作是控制器固有的功能，不需要再操作码控制下完成<br>B 所有指令的取指操作是相同的（错误）<br>C 在指令长度相同的情况下，所有指令的取指操作是相同的（正确）<br>D 中断周期是在指令执行完成后出现的</p><p>17.（控制器）可区分存储单元中存放的是指令还是数据</p><p>18.指令字长等于存储字长的前提下，取指周期等于机器周期；指令字长和机器字长的长度没有任何关系</p><p>5.3 数据通路的功能和基本结构<br>数据在功能部件之间传送的路径称为数据通路，其功能是实现CPU内部的运算器和寄存器以及寄存器之间的数据交换。</p><p>基本结构：<br>1）CPU内部单总线方式：所有寄存器的输入端和输出端都连接到一条公共的通路上<br>2）CPU内部三总线方式：所有寄存器的输入端和输出端都连接到多条公共的通路上<br>3）专用数据通路方式：根据指令执行过程中的数据和地址的流动方向安排连接线路，避免使用共享的总线</p><p>选择题</p><p>2.在单总线的CPU中（ALU只能有一个输入端可与总线相连，另一输入端需通过暂存器与总线相连）</p><p>3.采用CPU内部总线的数据通路与不采用CPU内部总线的数据相比（前者性能较低、前者的数据冲突问题较严重，后者的硬件量大、实现难度高）</p><p>4.CPU的读/写控制信号的作用是（决定数据总线上的数据流方向，控制存储器操作的读/写类型，控制流入、流出存储器信息的方向）</p><p>5.4 控制器的功能和工作原理<br>1）运算器部件通过数据总线与内存储器、输入设备和输出设备传送数据<br>2）输入设备和输出设备通过接口电路与总线相连接<br>3）内存储器、输入设备和输出设备从地址总线接收地址信息，从控制总线得到控制信号，通过数据总线与其他部件传送数据<br>4）控制器部件从数据总线接收指令信息，从运算器部件接收指令转移地址，送出指令地址到地址总线，还要向系统中的部件提供它们运行所需要的控制信号</p><p>控制器的主要功能有：<br>1）从主存中取出一条指令，并指出下一条指令在主存中的位置<br>2）对指令进行译码或测试，产生相应的操作控制信号，以便启动规定的动作<br>3）指挥并控制CPU、主存、输入和输出设备之间的数据流动方向</p><p>硬布线控制器由复杂的组合逻辑门电路和一些触发器构成，因此又称为组合逻辑控制器。<br>通常以存取周期作为基准时间，即内存中读取一个指令字的最短时间作为机器周期。在存储字长等于指令字长的前提下，取指周期也可看做机器周期。</p><p>微程序控制器采用存储逻辑实现，也就是把微操作信号代码化，使每条机器指令转化成为一段微程序并存入一个专门的存储器（控制存储器）中，微操作控制信号由微指令产生。</p><p>微程序设计思想是将每一条机器指令编写成一个微程序，每一个微程序包含若干条微指令，每一条微指令对应一个或几个微操作命令。<br>微命令是微操作的控制信号，微操作是微命令的执行过程。<br>注意：在组合逻辑控制器中也存在微命令与微操作这两个概念，它们并非只是微程序控制器的专有概念。<br>微指令是若干微命令的集合，存放微指令的控制存储器的单元地址称为微地址。<br>微周期通常指从控制存储器中读取一条微指令并执行相应的微操作所需的时间。<br>主存储器用于存放程序和数据，在CPU外部，用RAM实现；控制存储器CM用于存放微程序，在CPU内部，用ROM实现。<br>注意：若指令系统中具有n种机器指令，则控制存储器中的微程序数至少是n+1个（1为公共的取指微程序）</p><p>微指令的编码方式又称为微指令的控制方式，指如何对微指令的控制字段进行编码，以形成控制信号。目标是在保证速度的情况下，尽量缩短微指令字长。<br>1）直接编码（直接控制）方式<br>2）字段直接编码方式：将微指令的微命令字段分成若干个小字段，把互斥性微命令组合在同一字段中，把相容性微命令组合在不同的字段中<br>3）字段间接编码方式，又称隐式编码</p><p>微指令的地址形成方式：<br>1）直接由微指令的下地址字段指出（又称为断定方式）：由微指令的下地址字段直接指出后继微指令的地址<br>2）根据机器指令的操作码形成：当机器指令取至指令寄存器后，微地址的地址由操作码经微地址形成部件形成</p><p>微指令的格式：<br>1）水平型微指令：指令字中的一位对应一个控制信号，有输出时为1，否则为0。一条水平型微指令定义并执行几种并行的基本操作。优点是微程序短，执行速度快；缺点是微指令长，编写微程序较麻烦。<br>2）垂直型微指令：类似机器指令操作码的方式，设置微操作码字段，由微操作码规定微指令的功能。一条垂直型微指令只能定义并执行一种基本操作。优点是微指令短、简单、规整，便于编写微程序；缺点是微程序长，执行速度慢，工作效率低。<br>3）混合型微指令</p><p>类别    微程序控制器    硬布线控制器<br>工作原理    微操作控制信号以微程序的形式存放在控制存储器中，执行指令时读出即可    微操作控制信号由组合逻辑电路根据当前的指令码、状态和时序，即时产生<br>执行速度    慢    快<br>规整性    较规整    烦琐、不规整<br>应用场合    CISC CPU    RISC CPU<br>易扩充性    易扩充修改    困难<br>选择题</p><p>1.相对于微程序控制器，硬布线控制器的特点是（指令执行速度快，指令功能的修改和扩展难）</p><p>2.取指令操作（是控制器固有的功能，不需要在操作码控制下进行）</p><p>3.在组合逻辑控制器中，微操作控制信号的形成主要与（指令译码信号和时钟）信号有关</p><p>4.在微程序控制器中，形成微程序入口地址的是（C机器指令的操作码字段）<br>A 机器指令的地址码字段 B 微指令的微地址码字段<br>C 机器指令的操作码字段 D 微指令的微操作码字段</p><p>6.微程序控制器的速度比硬布线控制器慢，主要是因为（增加了从控制存储器读取微指令的时间）</p><p>7.微程序控制存储器属于（CPU）的一部分</p><p>9.硬布线控制器与微程序控制器相比（微程序控制器的时序系统比较简单）</p><p>10.在微程序控制器中，控制部件向执行部件发出的某个控制信号称为（微命令）</p><p>11.在微程序控制器中，机器指令与微指令的关系是（每一条机器指令由若干微指令组成的微程序来解释执行）</p><p>12.微指令格式分为水平型和垂直型，水平型微指令的位数（较多），用它编写的微程序（较短）</p><p>16.某带中断的计算机指令系统共有101中操作，采用微程序控制方式时，控制存储器中相应最少有（102）个微程序。（增加的1个位公共的取指微程序；另一个为对应中断周期的微程序）</p><p>17.兼容性微指令是指那些可以同时产生、共同完成某一些微操作的微命令。</p><p>18.每一条机器指令由一段微程序来解释执行；水平型微指令能充分利用数据通路的并行结构。</p><p>20.通常情况下，一个微程序的周期对应一个（指令周期）</p><p>5.5 指令流水线<br>一条指令的执行过程：<br>取指：根据PC内容访问主存储器，取出一条指令送到IR中<br>分析：对指令操作码进行译码，按照给定的寻址方式和地址字段中的内容形成操作数的有效地址EA，并从有效地址EA中取出操作数<br>执行：根据操作码字段，完成指令规定的功能，即把运算结果写到通用寄存器或主存中</p><p>1）顺序执行方式：前一条指令执行完后，才启动下一条指令，T=3nt<br>2）一次重叠执行方式：第k条指令的执行阶段和第k+1条指令的取指阶段同时进行，T=(1+2n)t<br>3）二次重叠执行方式：把取第k+1条指令提前到分析第k条指令的期间完成，而将分析第k+1条指令与执行第k条指令同时进行，T=(2+n)t</p><p>按使用级别分：部件功能级流水线、处理机级流水线、处理机间级流水线<br>按完成功能分：单功能流水线、多功能流水线<br>按连接方式分：动态流水线、静态流水线<br>按有无反馈信号分：线性流水线、非线性流水线</p><p>影响流水线的因素<br>1）结构相关：由于多条指令在同一时刻争用同一资源而形成的冲突<br>解决办法：<br>a. 前一指令访存时，使后一条相关指令（以及其后续指令）暂停一个时钟周期<br>b. 单独设置数据存储器和指令存储器，使两项操作各自在不同的存储器中进行，这属于资源重复配置</p><p>2）数据相关：必须等前一条指令执行完才能执行后一条指令的情况<br>a. 把遇到数据相关的指令及其后续指令都暂停一至几个时钟周期，可分为硬件阻塞（stall）和软件插入“NOP”指令两种方法<br>b. 设置相关专用通路，即不等前一条指令把计算结果返回寄存器组，下一条指令也不再读寄存器组，而是直接把前一条指令的ALU的计算结果作为自己的输入数据开始计算过程，使本来需要暂停的操作可以继续执行，称为数据旁路技术<br>c. 通过编译器对数据相关的指令编译优化的方法，调整指令顺序来解决数据相关</p><p>3）控制相关：遇到转移指令和其他改变PC值得指令而造成断流<br>a. 对转移指令进行分支预测，分为简单（静态）预测和动态预测，静态预测总是预测条件不满足，即继续执行后续指令；动态预测根据程序执行的历史情况，进行动态预测调整。<br>b. 预取转移成功和不成功两个控制流方向上的目标指令<br>c. 加快和提前形成条件码<br>d. 提高转移方向的猜准率</p><p>两条连续的指令读取相同的寄存器时，就会产生RAR（读后读）相关，这种相关不会影响流水线；<br>当某条指令要读取上一条指令所写入的寄存器时，就会产生RAW（写后读）相关，这种称数据相关或真相关，影响流水线。按序流动的流水线只可能出现RAW相关。<br>当某条指令的上条指令要读/写该指令的输出寄存器时，就会产生WAR（读后写）和WAW（写后写）相关。在非按序流动的流水线中，既可能发生RAW，也可能发生WAR和WAW相关。<br>对流水线影响最严重的指令相关是数据相关。</p><p>流水线的性能指标<br>1）流水线的吞吐率：TP=n/Tk，n是任务数，Tk是处理完成n个任务所用的时间；一条k段线性流水线能够在k+n-1个时钟周期内完成n个任务，此时TP=n/((k+n-1)*t)，t为时钟周期；当n趋于无穷时，得到最大吞吐率TPmax=1/t<br>2）流水线的加速比：完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间之比<br>S=T0/Tk=(knt)/((k+n-1)*t)=(kn)/(k+n-1)，当n趋于无穷时，得到最大加速比Smax=k<br>3）流水线的效率：E=n个任务占用k时空区有效面积/n个任务所用的时间与k个流水段所围成的时空区总面积=T0/(kTk)</p><p>超标量流水线技术：每个时钟周期内可并发多条独立指令，即以并行操作方式将两条或多条指令编译并执行，为此需配置多个功能部件<br>超流水线技术：在一个时钟周期内再分段，在一个时钟周期内一个功能部件使用多次<br>超长指令字：将多条能并行操作的指令组合成一条具有多个操作码字段的超长指令字，为此需要采用多个处理部件</p><p>选择题</p><p>4.下列关于超标量流水线不正确的是（D）<br>A 在一个时钟周期内一条流水线可执行一条以上的指令<br>B 一条指令分为多段指令由不同电路单元完成<br>C 超标量通过内置多条流水线来同时执行多个处理器，其实质是以空间换时间<br>D 超标量流水线式指运算操作并行（错误）</p><p>5.下列关于超标量流水线特性的叙述中，正确的是（II、III）<br>I. 能缩短流水线功能段的处理时间（不影响）<br>II. 能在一个时钟周期内同时发射多条指令（正确）<br>III. 能结合动态调度技术提高指令执行并行性（正确）</p><p>7.一个m段流水线稳定时的CPU的吞吐能力，与m个并行部件的CPU的吞吐能力相比（具有同等水平的吞吐能力）</p><h3 id="第6章-总线"><a href="#第6章-总线" class="headerlink" title="第6章 总线"></a>第6章 总线</h3><p>6.1 总线概述<br>总线是一组能为多个部件分时共享的公共信息传送线路。分时和共享是总线的两个特点。<br>分时是指同一时刻只允许由一个部件向总线发送信息；共享是指总线上可以挂接多个部件，各个部件之间互相交换的信息都可以通过这组线路分时共享。在某一时刻只允许由一个部件向总线发送信息，但多个部件可以同时从总线上接收相同的信息。</p><p>主设备：是指获得总线控制权的设备<br>从设备：是指被主设备访问的设备，只能响应从主设备发来的各种总线命令</p><p>总线特性：机械特性、电气特性、功能特性、时间特性</p><p>猝发传输方式：在一个总线周期内传输存储地址连续的多个数据字的总线传输方式叫猝发传送</p><p>总线的分类：<br>1）片内总线：CPU芯片内部寄存器与寄存器之间、寄存器与ALU之间的公共连接线<br>2）系统总线：计算机系统内各功能部件（CPU、主存、I/O接口）之间相互连接的总线<br>a. 数据总线：用来传输各功能部件之间的数据信息，双向传输，其位数与机器字长、存储字长有关<br>b. 地址总线：用来指出数据总线上的源数据或目的数据所在的主存单元或I/O接口的地址，单向传输，其位数与主存地址空间有关<br>c. 控制总线：传输控制信息，包括CPU送出的控制命令和主存（或外设）返回CPU的反馈信号<br>3）通信总线：用于计算机系统之间或计算机系统与其他系统（如远程通信设备、测试设备）之间信息传送的总线，也称为外部总线</p><p>系统总线的结构：<br>1）单总线结构：CPU、主存、I/O设备（通过I/O接口）都挂在一组总线上<br>2）双总线结构：主存总线、I/O总线<br>3）三总线结构：主存总线、I/O总线、DMA总线</p><p>总线的性能指标：<br>1）传输周期，简称总线周期<br>2）时钟周期<br>3）工作频率：总线周期的倒数，总线工作频率=时钟频率/N（N表示N个时钟周期）<br>4）时钟频率<br>5）总线宽度，又称总线位宽，是总线上同时能够传输的数据位数，通常是指数据总线的根数<br>6）总线带宽，总线的数据传输率，即单位时间内总线上可传输数据的位数，总线带宽=总线工作频率 * (总线宽度/8)</p><p>总线带宽=总线宽度 * 总线频率</p><p>选择题</p><p>1.在系统总线的数据线上，不可能传输的是（C握手（应答）信号）<br>A 指令 B 操作数 C 握手（应答）信号 D 中断类型号</p><p>5.一次总线事务中，主设备只需给出一个首地址，从设备就能从首地址开始的若干连续单元读出或写入多个数据，这种总线事务方式成为（突发传输）</p><p>6.挂接在总线上的多个部件（只能分时向总线发送数据，但可同时从总线接收数据）</p><p>7.在总线上，同一时刻（只能有一个主设备控制总线传输操作）</p><p>9.系统总线是用来连接（CPU、主存和外设部件）</p><p>10.计算机使用总线结构便于增减外设，同时（C减少了信息传输线的条数）<br>A 减少了信息传输量 B 提高了信息的传输速度<br>C 减少了信息传输线的条数 D 提高了信息传输的并行性</p><p>11.间址寻址第一次访问内存所得到信息经系统总线的（数据总线）传送到CPU</p><p>12.系统总线中地址线的功能是（用于指定主存和I/O设备接口电路的地址）</p><p>13.单周期处理器中所有指令的指令周期为一个时钟周期，下列关于单周期处理器的叙述中，错误的是（A）<br>A 可以采用单总线结构数据通路（错误）<br>B 处理器时钟频率较低<br>C 在指令 执行过程中控制信号不变<br>D 每条指令的CPI为1</p><p>15.不同信号在同一条信号线上分时传输的方式称为（总线复用方式）</p><p>16.主存通过（总线的类型）来识别信息是地址还是数据</p><p>22.下列关于总线定时的叙述中，错误的是（C）<br>A 异步通信方式中，全互锁协议最慢<br>B 异步通信方式中，非互锁协议的可靠性最差<br>C 同步通信方式总，同步时钟信号可由各设备提供（错误，采用统一的时钟信号）<br>D 半同步通信方式中，握手信号的采样由同步时钟控制</p><p>23.下列关于总线设计的叙述中，错误的是（A）<br>A 并行总线传输比串行总线传输速度快（错误，不一定）<br>B 采用信号线复用技术可减少信号线数量<br>C 采用突发传输方式可提高总线数据传输率<br>D 采用分离事务通信方式可提高总线利用率</p><p>24.下列关于多总线结构的叙述中，错误的是（D）<br>A 靠近CPU的总线速度较快<br>B 存储器总线可支持突发传送方式<br>C 总线之间须通过桥接器相连<br>D PC I-Express*16 采用并行传输方式（错误，采用串行数据包传输数据）</p><p>6.2 总线仲裁<br>为解决多个主设备同时竞争总线控制权的问题，应当采用总线仲裁部件，以某种方式选择一个主设备优先获得总线控制权。</p><p>集中仲裁方式：将所有的总线请求集中起来，利用一个特定的裁决算法进行裁决<br>1）链式查询方式：离总线控制器越近的部件，其优先级越高。优点：链式查询方式优先级固定，结构简单，扩充容易；缺点：对故障敏感，优先级不能改变<br>2）计数器定时查询方式：优点：设备使用总线的优先级相等，优先次序可以改变，对故障不敏感；缺点：增加了控制线数，相对复杂<br>3）独立请求方式：优点：响应速度快，对优先次序的控制相当灵活；缺点：控制线数量多，逻辑更复杂</p><p>链式查询    计数器定时查询    独立请求<br>控制线数    3    log2 n向上取整 + 2    2n+1<br>优点    优先级固定；结构简单；扩充容易    优先级灵活    响应速度快；优先级灵活<br>缺点    对电路故障敏感；优先级不灵活    控制线多；控制复杂    控制线多；控制复杂<br>分布仲裁方式：不需要中央仲裁器，每个潜在的主模块都有自己的仲裁号和仲裁器。如果仲裁总线上的号优先级高，则它的总线请求不予响应，并撤销它的仲裁号，最后获胜者的仲裁号保留在仲裁总线上。</p><p>选择题</p><p>1.在技术器定时查询方式下，若每次计数从上一次计数的终止点开始，则（每个设备使用总线的机会相等）</p><p>4.在计数器定时查询方式下，（总线设备的优先级可变）</p><p>6.在某计算机系统中，各个主设备得到总线使用权的机会基本相等，则该系统采用的总线判优控制方式可能是（计数器定时查询方式、独立请求方式）</p><p>6.3 总线操作和定时<br>一个总线周期可分为4个阶段：<br>1）申请分配阶段：由需要使用总线的主模块（或主设备）提出申请，经总线仲裁机构决定将下一传输周期的总线使用权授予某一申请者。<br>2）寻址阶段：主模块通过总线发出本次要访问的从模块（或从设备）的地址及有关命令，启动参与本次传输的从模块。<br>3）传输阶段：主模块和从模块进行数据交换，可单向或双向进行数据传送<br>4）结束阶段：主模块的有关信息均从系统总线上撤除，让出总线使用权</p><p>同步定时方式：系统采用一个统一的时钟信号来协调发送和接收双方的传递定时关系。适用于总线长度较短及总线所接部件的存取时间比较接近的系统。<br>优点：传送速度快，具有较高的传输速率；总线控制逻辑简单<br>缺点：主从设备属于强制性同步；不能及时进行数据通信的有效性检验，可靠性较差</p><p>异步定时方式：没有统一的时钟，也没有固定的时间间隔，完全依靠传送双方相互制约的“握手”信号来实现定时控制。<br>优点：总线周期长度可变，能保证两个工作速度相差很大的部件或设备之间可靠地进行信息交换，自动适应时间的配合<br>缺点：比同步控制方式稍复杂一些，速度比同步定时方式慢<br>1）不互锁方式：主设备自动撤销“请求”信号，从设备自动撤销“回答”信号，双方不存在互锁关系<br>2）半互锁方式：主设备发出“请求”信号后，必须待接到从设备的“回答”信号后，才撤销“请求”信号，有互锁关系；而从设备在接到“请求”信号后，发出“回答”信号，但不必等待获知主设备的“请求”信号已经撤销，而是隔一段时间后自动撤销“回答”信号，不存在互锁关系。<br>3）全互锁关系：主设备发出“请求”信号后，必须待从设备“回答”后，才撤销“请求”信号；从设备发出“回答”信号，必须待获知主设备“请求”信号已撤销后，再撤销其“回答”信号。双方存在互锁关系。</p><p>选择题</p><p>5.（各部件的存取时间比较接近）是同步传输的特点</p><p>6.在异步总线中，传送操作（由CPU控制）</p><p>7.总线的异步通信方式是（不采用时钟信号，只采用“握手”信号）</p><p>8.在各种异步通信方式中，（不互锁）的速度最快</p><p>6.4 总线标准<br>ISA总线：最早出现的微型计算机的系统总线标准，应用在IBM的AT机上<br>EISA总线：为配合32位CPU而设计的总线扩展标准，EISA对ISA完全兼容<br>VESA总线：32位标准的计算机局部总线，是针对多媒体PC要求高速传送活动图像的大量数据应运而生的<br>PCI总线：高性能的32位或64位总线，专为高度集成的外围部件、扩充插板和处理器/存储器系统而设计的互联机制。目前常用的PCI适配器有显卡、声卡、网卡等。PCI总线支持即插即用，与处理器时钟频率无关，属于局部总线，可以通过桥连接实现多层PCI总线<br>PCI-Express（PCI-E）是最新的总线和接口标准，将全面取代现行的PCI和AGP，最终实现总线标准的统一<br>AGP：是一种视频接口标准，专用于连接主存和图形存储器，属于局部总线。AGP技术为传输视频和三维图形数据提供了切实可行的解决方案。<br>RS-232C总线是由美国电子工业协会（EIA）推荐的一种串行通信总线标准，是应用于串行二进制交换的数据终端设备（DTE）和数据通信设备（DCE）之间的标准接口<br>USB总线：连接外部设备的I/O总线标准，属于设备总线，具有即插即用、热插拔等优点，有很强的连接能力<br>PCMCIA：广泛应用于笔记本电脑中的一种接口标准，是一个小型的用于扩展功能的插槽，可即插即用<br>IDE总线：ATA，是一种IDE接口磁盘驱动器接口类型，硬盘和光驱通过IDE接口与主板连接<br>SCSI：用于计算机和智能设备之间（硬盘、软驱、光驱、打印机等）系统级接口的独立处理器标准<br>SATA：基于行业标准的串行硬件驱动器接口，硬盘接口规范</p><p>选择题</p><p>2.下列关于USB总线特性的描述中，错误的是（D）<br>A 可实现外设的即插即用和热拔插<br>B 可通过级联方式连接多台外设<br>C 是一种通信总线，连接不同外设<br>D 同时可传输2位数据，数据传输率高（USB总线是串行总线，不能同时传输）</p><p>3.下列总线标准中是串行总线的是（B）<br>A PCI（并行总线） B USB（串行总线） C EISA（并行） D ISA（并行）</p><p>4.用于设备和设备控制器（I/O接口）之间互连的接口标准是（USB）</p><p>5.在现代微机主板上，采用局部总线技术的作用是（节省系统的总带宽）</p><p>6.下列不属于计算机局部总线的是（D）<br>A VESA B PCI C AGP D ISA（系统总线）</p><h3 id="第7章-输入-输出系统"><a href="#第7章-输入-输出系统" class="headerlink" title="第7章 输入/输出系统"></a>第7章 输入/输出系统</h3><p>7.1 I/O系统基本概念<br>I/O控制方式主要有一下4种：<br>1）程序查询方式：由CPU通过程序不断查询I/O设备是否已做好准备，从而控制I/O设备与主机交换信息<br>2）程序中断方式：只在I/O设备准备就绪并向CPU发出中断请求时才予以响应<br>3）DMA方式：主存和I/O设备之间有一条直接数据通路，当主存和I/O设备交换信息时，无需调用中断服务程序<br>4）通道方式：在系统中设有通道控制部件，每个通道都挂接若干外设，主机在执行I/O命令时，只需启动有关通道，通道将执行通道程序，从而完成I/O操作。</p><p>选择题</p><p>1.在微型机系统中，I/O设备通过（设备控制器）与主板的系统总线相连接</p><p>2.下列关于I/O指令的说法，错误的是（D）<br>A I/O指令是CPU系统指令的一部分<br>B I/O指令是机器指令的一类<br>C I/O指令反映CPU和I/O设备交换信息的特点<br>D I/O指令的格式和通用指令格式相同（错误）</p><p>3.下列关于通道程序的叙述中，正确的是（A）<br>A 通道程序存放在主存中<br>B 通道程序存放在通道中<br>C 通道程序是由CPU执行的（错误，由通道执行）<br>D 通道程序可以在任何环境下执行I/O操作（错误）</p><p>7.2 外部设备<br>显示存储器VRAM：<br>VRAM容量 = 分辨率 * 灰度级位数<br>VRAM带宽 = 分辨率 * 灰度级位数 * 帧频</p><p>一块磁盘含有若干个记录面，每个记录面划分为若干条磁道，而每条磁道又划分为若干个扇区，扇区（也称为块）是磁盘读写的最小单位，也就是说磁盘按块读取。<br>磁头数：即记录面数，磁头用于读取/写入盘片上记录面的信息，一个记录面对应一个磁头<br>柱面数：表示硬盘每一面盘片上有多少条磁道<br>扇区数：表示每一条磁道上有多少个扇区</p><p>平均存取时间由寻道时间（磁头移动到目的磁道）、旋转延迟时间（磁头定位到所在扇区）和传输时间（传输数据所花费的时间）三部分构成</p><p>硬盘属于机械式部件，其读写操作是串行的，不可能在同一时刻既读又写，也不可能在同一时刻读两组数据或写两组数据。</p><p>RAID0没有容错能力，RAID1-RAID5的几种方案中，无论何时有磁盘损坏，都可以随时拔出受损的磁盘再插入好的磁盘，而数据不会损坏。<br>RAID0：无冗余和无校验的磁盘阵列<br>RAID1：镜像磁盘阵列<br>RAID2：采用纠错的海明码的磁盘阵列<br>RAID3：位交叉奇偶校验的磁盘阵列<br>RAID4：块交叉奇偶校验的磁盘阵列<br>RAID5：无独立校验的奇偶校验磁盘阵列<br>RAID通过同时使用多个磁盘，提高了传输率；通过在多个磁盘上并行存取来大幅提高存储系统的数据吞吐量；通过镜像功能，可以提高安全可靠性；通过数据校验，可以提供容错能力。</p><p>选择题</p><p>3.一台字符显示器的VRAM中存放的是（显示字符的ASCII码）</p><p>9.下列选项中，用于提高RAID可靠性的措施有（I、III）<br>I. 磁盘镜像 II. 条带化 III. 奇偶校验 IV. 增加Cache机制</p><p>7.3 I/O接口<br>I/O接口的功能：<br>1）实现主机和外设的通信联络控制<br>2）进行地址译码和设备选择<br>3）实现数据缓冲<br>4）信号格式的转换<br>5）传送控制命令和状态信息</p><p>内部接口：内部接口与系统总线相连，实质上是与内存、CPU相连，数据的传输方式只能是并行传输<br>外部接口：外部接口通过接口电缆与外设相连，外部接口的数据传输可能是串行方式，因此I/O接口需具有串/并转换功能。<br>注意：端口是指接口电路中可以进行读/写的寄存器，若干个端口加上相应的控制逻辑才可以组成接口。</p><p>I/O端口是指接口电路中可以被CPU直接访问的寄存器，主要有数据端口、状态端口和控制端口，若干个端口加上相应的控制逻辑电路组成接口。CPU能对数据端口执行读写操作，对状态端口只能执行读操作，对控制端口只能执行写操作。<br>I/O端口的编址方式：<br>1）统一编址，又称存储器映射方式，是指把I/O端口当做存储器的单元进行地址分配，这种方式CPU不需要设置专门的I/O指令，用统一的访存指令就可以访问I/O端口<br>2）独立编址，又称I/O映射方式，是指I/O端口地址与存储器地址无关，独立编址CPU需要设置专门的输入/输出指令访问端口</p><p>选择题</p><p>1.下列选项中，在I/O总线的数据线上传输的信息包括（I、II、III）<br>I. I/O接口中的命令字 II. I/O接口中的状态字 III. 中断类型号</p><p>2.在统一编址的方式下，区分存储单元和I/O设备是靠（不同的地址码）</p><p>5.I/O的编址方式采用统一编址方式时，进行输入/输出的操作的指令是（访存指令）</p><p>6.在具有专门I/O指令的计算机中，I/O设备才可以单独编址</p><p>8.磁盘驱动器向盘片磁道记录数据时采用（串行）方式写入</p><p>9.程序员进行系统调用访问设备用的是（逻辑地址）</p><p>11.I/O指令实现的数据传送数据通常发生在（通用寄存器和I/O端口之间）</p><p>7.4 I/O方式<br>程序查询方式：CPU一旦启动I/O，必须停止现行程序的运行，并在现行程序中插入一段程序，有“踏步”现象，CPU与I/O串行工作<br>1）CPU执行初始化程序，并预置传送参数<br>2）向I/O接口发出命令字，启动I/O设备<br>3）从外设接口读取其状态信息<br>4）CPU不断查询I/O设备状态，直到外设准备就绪<br>5）传送一次数据<br>6）修改地址和计数器参数<br>7）判断传送是否结束，若没结束转第3步，直到计数器为0</p><p>程序中断方式：CPU与I/O并行工作<br>程序中断是指在计算机执行现行程序的过程中，出现某些急需处理的异常情况或特殊请求，CPU暂时中止现行程序，而转去对这些异常情况或特殊请求进行处理，在处理完毕后CPU又自动返回到现行程序的断点处，继续执行原程序。</p><p>程序中断方式工作流程：<br>1）中断请求：中断源向CPU发出中断信号<br>外中断：来自处理器和内存以外的部件引起的中断<br>内中断：在处理器和内存内部产生的中断<br>硬件中断属于外中断；软件中断属于内中断。<br>非屏蔽中断是一种硬件中断，属于外中断；可屏蔽中断也是一种硬件中断，属于外中断。</p><p>2）中断判优：判断多个中断源的优先级，可由硬件实现或软件实现<br>硬件中断属于最高级，其次是软件中断，非屏蔽中断优于可屏蔽中断，DMA请求优于I/O设备传送的中断请求，高速设备优于低速设备，输入设备优于输出设备，实时设备优于普通设备。</p><p>3）CPU响应中断的条件<br>有中断源提出中断请求<br>CPU允许中断及开中断<br>一条指令执行完毕且没有更紧迫的任务</p><p>4）中断隐指令：完成关中断、保存断点、引出中断服务程序，由硬件直接实现，不允许、也不可能为用户使用的特殊指令。</p><p>5）中断向量：查询中断服务程序的入口地址<br>注意：中断向量是中断服务程序的入口地址，中断向量地址地址是指中断服务程序的入口地址的地址。</p><p>6）中断处理：执行中断服务程序最后恢复现场，中断返回<br>中断服务程序的最后一条指令通常是一条中断返回指令，使其返回到原程序的断点处，以便继续执行原程序。</p><p>多重中断：当CPU处理中断时，又有更高优先级的中断请求<br>条件：<br>1）在中断服务程序中提前设置开中断指令<br>2）优先级高的中断源有权中断优先级低的中断源</p><p>DMA方式：完全由硬件进行成组信息传送的控制方式，主存和DMA接口之间有一条直接数据通路，I/O与主机并行工作，程序和传送并行工作</p><p>组成：<br>主存地址计数器：存放要交换数据的主存地址<br>传送长度计数器：用来记录传送数据的长度<br>数据缓冲寄存器：用于暂存每次传送的数据<br>DMA请求触发器：I/O设备准备好数据后使DMA请求触发器置位<br>控制/状态逻辑：由控制和时序电路及状态标志组成<br>中断机构：数据块传送完毕后触发中断机构，提出中断请求</p><p>传送方式：<br>停止CPU访存：当需要传送数据时，停止CPU对主存的访问<br>交替访存：将CPU周期分为DMA访存和CPU访存两个部分<br>周期挪用（周期窃取）：I/O设备需要访存时，挪用一个或几个存取周期</p><p>传送过程：<br>预处理：完成寄存器置初始值之类的准备工作，I/O设备向DMA控制器发送DMA请求，再由DMA控制器向CPU发送总线请求<br>数据传送：占用总线传输数据，数据传送完全由DMA（硬件）控制<br>后处理：CPU执行中断服务程序做结束DMA处理</p><p>DMA方式和中断方式的区别：<br>1）中断方式是程序的切换，需要保护和恢复现场；而DMA方式除了预处理和后处理，其他时候不占用CPU的任何资源<br>2）对中断请求的响应只能发生在每条指令执行完毕时（即指令的执行周期之后）；而对DMA请求的响应可以发生在每个机器周期结束时（在取指、间址、执行周期之后均可），只要CPU不占用总线就可以被响应<br>3）中断传送过程需要CPU的干预；而DMA传送过程不需要CPU的干预，故数据传输速率非常高，适合于高速外设的成组数据传送<br>4）DMA请求的优先级高于中断请求<br>5）中断方式具有对异常事件的处理能力，而DMA方式仅限于传送数据块的I/O操作<br>6）从数据传送来看，中断方式靠程序传送，DMA方式靠硬件传送</p><p>选择题</p><p>10.浮点数运算下溢不产生中断</p><p>11.“自陷”是人为预先设定的一种特定处理事件</p><p>12.DMA方式的中断请求是为了报告CPU数据的传输结束，而程序中断方式的中断请求完全是为了传送数据。</p><p>14.能产生DMA请求的总线部件是（具有DMA接口的设备）</p><p>15.中断响应由高到低的优先次序宜用（访管-&gt;程序性-&gt;重新启动）</p><p>19.主存故障引起的中断是（机器校验中断）（属于内中断）</p><p>20.在配有通道的计算机系统中，用户程序需要输入/输出时，引起的中断是（访管中断）</p><p>24.在中断周期中，由（中断隐指令）将允许中断触发器置0</p><p>26.设置中断屏蔽标志可以改变（多个中断服务程序执行完的次序）</p><p>29.中断方式的特点是（CPU与外设并行工作，传送与主程序串行工作），DMA方式的特点是（CPU与外设并行工作，传送与主程序并行工作）</p><p>30.在DMA传送方式中，由（外部设备）发出DMA请求，在传送期间总线控制权由（DMA控制器）掌握</p><p>31.程序中断方式和DMA方式中都有中断请求，但目的不同</p><p>33.CPU响应DMA请求的条件是当前（机器周期）执行完</p><p>38.中断发生时，程序计数器内容的保护和更新是由（硬件自动（中断隐指令））完成的</p><p>40.在DMA方式下，数据从内存传送到外设经过的路径是（内存-&gt;数据总线-&gt;DMAC-&gt;外设）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/SYSU/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/SYSU/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="知识框架"><a href="#知识框架" class="headerlink" title="知识框架"></a>知识框架</h2><a id="more"></a> <h2 id="知识梳理"><a href="#知识梳理" class="headerlink" title="知识梳理"></a>知识梳理</h2><h3 id="第1章-计算机网络体系结构"><a href="#第1章-计算机网络体系结构" class="headerlink" title="第1章 计算机网络体系结构"></a>第1章 计算机网络体系结构</h3><p>1.1 计算机网络概述<br>计算机网络是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善的软件实现资源共享和信息传递的系统。<br>资源共享观点：计算机网络是以能够相互共享资源的方式互联起来的自治计算机系统的集合。1）目的：资源共享；2）组成单元：分布在不同地理位置的多台独立的自治计算机；3）网络中的计算机必须遵循的统一规则——网络协议</p><p>计算机网络的组成：<br>1）从组成部分上看：硬件、软件、协议，协议是核心<br>2）从工作方式上看：边缘部分（主机）和核心部分（网络、路由器）<br>3）从功能组成上看：通信子网和资源子网</p><p>计算机网络的功能：<br>1）数据通信<br>2）资源共享<br>3）分布式处理<br>4）提高可靠性<br>5）负载均衡</p><p>计算机网络的分类：<br>1）按分布范围分类：广域网、城域网、局域网、个人局域网<br>2）按传输技术分类：广播式网络、点对点网络<br>3）按拓扑结构分类：星形网络、总线形网络、环形网络、网状形网络<br>4）按使用者分类：公用网、专用网<br>5）按交换技术分类：电路交换网络、报文交换网络、分组交换网络<br>6）按传输介质分类：有线网络、无线网络</p><p>计算机网络的性能指标：<br>1）带宽：网络的通信线路所能传送数据的能力，单位赫兹Hz<br>2）时延：发送时延（传输时延）、传播时延、处理时延、排队时延<br>发送时延（传输时延）=分组长度/信道宽度<br>传播时延=信道长度/电磁波在信道上的传播速率<br>总时延=发送时延+传播时延+处理时延+排队时延<br>3）时延带宽积：在发送的第一个比特即将到达终点时，发送端已经发出的比特数，时延带宽积=传播时延*信道带宽<br>4）往返时延RTT：从发送端发送数据开始，到发送端收到来自接收端的确认<br>5）吞吐量<br>6）速率：数据率或比特率，单位是比特每秒b/s</p><p>选择题</p><p>2.计算机网络最基本的功能是（数据通信）</p><p>6.计算机网络的资源主要是指（计算机硬件、软件和数据）</p><p>12.局域网与广域网的互联是通过（路由器）实现的</p><p>14.广域网的拓扑结构通常采用（网状形）</p><p>15.在n个结点的星形拓扑结构中，有（n-1）条物理链路</p><p>18.世界上最早的计算机网络是（ARPAnet）</p><p>1.2 计算机网络体系结构与参考模型<br>计算机网络的各层及其协议的集合称为网络的体系结构，它是计算机网络中的层次、各层的协议以及层间借接口的集合。</p><p>服务数据单元SDU、协议控制信息PCI、协议数据单元PDU</p><p>1）第n层的实体不仅要使用第n-1层的服务，实现自身定义的功能，还要向第n+1层提供本层的服务，该服务是第n层及其下面各层提供的服务总和。<br>2）最底层只提供服务，是整个层次结构的基础；中间各层既是下一层的服务使用者，又是上一层的服务提供者；最高层面向用户提供服务。<br>3）上一层只能通过相邻层间的接口使用下一层的服务，而不能调用其他层的服务；下一层所提供服务的实现细节对上一层透明。<br>4）两个主机通信时，对等层在逻辑上有一条直接信道，表现为不经过下层就把信息传送到对方。</p><p>协议是控制两个（或多个）对等实体进行通信的集合，也就是水平的。不对等实体之间没有协议。协议由语法、语义和同步三部分组成。<br>接口是同一结点内相邻两层间交换信息的连接点，不能跨层定义接口。同一结点相邻两层的实体通过服务访问点SAP进行交互。<br>服务是指下层为紧相邻的上层提供的功能调用，也就是垂直的。<br>本层的服务只能看见服务而无法看见下面的协议。</p><p>面向连接服务：连接建立、数据传输和连接释放<br>无连接服务：尽最大努力交付<br>可靠服务：保证数据正确、可靠地传送到目的地<br>不可靠服务：不能保证数据正确、可靠地传送到目的地，尽力而为的服务<br>有应答服务：接收方在收到数据后向发送方给出相应地应答，由传输系统内部自动实现<br>无应答服务：接收方接到数据后不自动给出应答</p><p>开放系统互联参考模型，简称OSI参考模型：物理层、数据链路层、网络层、运输层、会话层、表示层、应用层。低三层统称为通信子网，高三层统称为资源子网，运输层承上启下。<br>1）物理层：传输单位是比特，任务是透明地传输比特流，定义数据终端设备DTE和数据通信设备DCE的物理和逻辑连接方法<br>物理层接口标准：EIA-232C、EIA/TIA RS-449、CCITT的X.21<br>双绞线、光缆、无线信道并不在物理层协议之内而在物理层协议下面。<br>2）数据链路层：传输单位是帧，任务是将网络层传下来的IP数据报组装成帧。功能：成帧、差错控制、流量控制、传输管理等<br>数据链路层协议：SDLC、HDLC、PPP、STP和帧中继<br>3）网络层：传输单位是数据报，任务是把网络层的协议数据单元（分组）从源端传到目的端，为分组交换网上的不同主机提供通信服务。功能：路由选择、流量控制、拥塞控制、差错控制和国际互联等<br>网络层协议：IP、IPX、ICMP、IGMP、ARP、RARP、OSPF<br>4）传输层：传输单位是报文段（TCP）或用户数据报（UDP），任务是负责主机中两个进程之间的通信。功能是为端到端连接提供可靠地传输服务；流量控制、差错控制、服务质量、数据传输管理等<br>数据链路层提供的是点到点的通信，传输层提供端到端的通信<br>传输层协议：TCP、UDP<br>5）会话层：不同主机上各进程之间的会话，负责管理主机间的会话进程<br>6）表示层：处理在两个通信系统中交换信息的表示方式<br>7）应用层：是用户与网络的界面，使用的协议最多，FTP、SMTP、HTTP等</p><p>TCP/IP模型：网络接口层、网际层、传输层、应用层<br>1）网络接口层：类似于OSI的物理层和数据链路层，从主机或结点接收IP分组，并把它们发送到指定的物理网络上<br>2）网际层（主机-主机）：将分组发送到任何网络，并为之独立地选择合适的路由，但不保证各个分组有序到达，有序交付由高层负责<br>3）传输层（应用-应用，或进程-进程）：传输控制协议TCP、用户数据报协议UDP<br>4）应用层（用户-用户）：Telnet、FTP、DNS、SMTP、HTTP</p><p>选择题</p><p>1.（定义功能执行的方法）不是对网络模型进行分层的目标</p><p>3.协议是指在（不同结点对等实体）之间进行通信的规则或约定</p><p>15.数据的格式转换及压缩属于OSI参考模型中（表示层）的功能</p><p>23.TCP/IP参考模型的网络层提供的是（无连接不可靠的数据报服务）</p><h3 id="第2章-物理层"><a href="#第2章-物理层" class="headerlink" title="第2章 物理层"></a>第2章 物理层</h3><p>2.1 通信基础<br>信道<br>单工：只有一个方向的通信，而没有反方向的交互，仅需要一条信道<br>半双工：通信双方都可以发送、接收信息，但不能同事发送接收，需要两条信道<br>全双工：通信双方可以同时发送、接收信息，需要两条信道</p><p>码元传输速率：表示单位时间内数字通信系统所传输的码元个数（也可称为脉冲个数或信号变化的次数），单位是波特Baud，1波特表示数字通信系统每秒传输一个码元<br>信息传输速率：表示单位时间内数字通信系统传输的二进制码元个数（即比特数），单位是比特/秒（b/s）<br>若一个码元携带n比特的信息量，则M波特的码元传输速率所对应的信息传输速率为M*n bit/s。<br>带宽是指信号具有的频带宽度，单位是赫兹Hz，表示在单位时间内从网络中的某一点到另一点所能通过的“最高数据率”，此时单位是bit/s。</p><p>奈奎斯特定理，又称奈氏准则，指出在理想低通（没有噪声、带宽有限）的信道中，极限码元传输率为2W波特，其中W是理想低通信道的带宽，单位为Hz。若用V表示每个码元离散电平的数目（码元的离散电平数目是指有多少种不同的码元，比如有16种不同的码元，则需要4位二进制位，因此数据传输率是码元传输率的4倍），则极限数据率为：<br>理想低通信道下的极限数据传输率=2Wlog2 V（单位b/s）</p><p>香农定理：给出了带宽受限且有高斯白噪声干扰的信道的极限数据传输速率<br>信道的极限数据传输速率=Wlog2 (1+S/N)（单位b/s）<br>其中W为信道的带宽，S为信道所传输信号的平均功率，N为信道内部的高斯噪声功率。S/N为信噪比，信噪比=10log10 (S/N)（单位dB），即当S/N=1000时，信噪比为30dB</p><p>调制：把数据变换为模拟信号的过程<br>编码：把数据变换为数字信号的过程<br>数字数据编码为数字信号：<br>1）非归零码：没有检错功能，难以保持同步<br>2）曼彻斯特编码：将一个码元分成两个相等的间隔，前一个间隔为高电平后一个间隔为低电平表示码元1，码元0则正好相反。可用于同步，以太网使用这种编码方式<br>3）差分曼彻斯特编码：若码元为1，则前半个码元的电平与上一个码元的后半个码元的电平相同，若为0，则相反。可以实现自同步，且抗干扰性较好。<br>4）4B/5B编码</p><p>数字数据调制为模拟信号：幅移键控（振幅）、频移键控（频率）、相移键控（相位）、正交振幅调制（幅移键控、相移键控相结合）<br>模拟数据编码为数字信号：常用于对音频信号进行编码的脉冲调制<br>1.抽样 2.量化 3.编码<br>采样频率必须大于等于最大频率的两倍，才能保证采样后的数字信号完整保留原始模拟信号的信息<br>模拟数据调制为模拟信号：频分复用技术等</p><p>电路交换：两结点之间建立一条专用（双方独占）的物理通信路径，传输期间一直独占。连接建立、数据传输、连接释放<br>报文交换：无需建立专门连接，报文携带有目标地址等信息，采用存储转发的传输方式<br>分组交换：采用存储转发方式，把报文分割成小的数据块，加上必要的控制信息进行传输<br>1）无连接的数据报：不需要建立连接，网络尽最大努力交付，不保证可靠性，分组之间可能存在不同路径，各个分组分别转发<br>2）面向连接的虚电路：在发送方和接收方建立一条逻辑上相连的虚电路，分组沿着虚电路传输，虚电路建立、数据传输、虚电路释放</p><p>数据报    虚电路<br>连接的建立    不要    必须有<br>目的地址    每个分组都有完整的目的地址    仅在建立连接阶段使用，之后每个分组使用长度较短的虚电路号<br>路由选择    每个分组独立地进行路由选择和转发    属于同一条虚电路的分组按照同一路由转发<br>分组顺序    不保证分组的有序到达    保证分组的有序到达<br>可靠性    不保证可靠通信，可靠性由用户主机来保证    可靠性由网络保证<br>对网络故障的适应性    出故障的结点丢失分组，其他分组可正常传输    所有经过故障结点的虚电路均不能正常工作<br>差错处理和流量控制    由用户主机进行流量控制，不保证数据报的可靠性    可由分组交换网负责，也可由用户主机负责<br>选择题</p><p>25.数据经过网络的传输延迟长而且是不固定的，不能用于语音数据传输的是（报文交换）</p><p>26.以太网采用的是（分组交换技术）</p><p>27.为了使数据在网络中传输时延最小，首选的交换方式是（电路交换）</p><p>30.为了使数据在网络中的传输时延最小，首选的交换方式时（电路交换），为保证数据无差错地传送，不应选用的交换方式是（电路交换），分组交换对报文交换的主要改进是（传输单位更小且有固定的最大长度），这种改进产生的直接结果是（减少传输时延），在出错率很高的传输系统中，选用（数据报方式）更合适。</p><p>32.同一报文中的分组可以由不同的传输路径通过通信子网的方法是（数据报）</p><p>2.2 传输介质<br>无线：无线电波、微波、红外线和激光<br>有线：双绞线、同轴电缆、光纤</p><p>物理层接口的特性：机械特性、电气特性、功能特性、规程特性</p><p>选择题</p><p>3.利用一根同轴电缆互连主机构成以太网，则主机间的通信方式是（半双工）</p><p>4.同轴电缆比双绞线的传输速度更快，得益于（同轴电缆具有更高的屏蔽性，同时具有更好的抗噪声性）</p><p>5.不受电磁干扰和噪声影响的传输介质是（光纤）</p><p>6.多模光纤传输光信号的原理是（光的全反射特性）</p><p>11.在物理层接口特性中，用于描述完成每种功能的事件发生顺序的是（过程特性）</p><p>2.3 物理层设备<br>中继器：又称为转发器，主要功能是将信号整形并放大再转发出去，以消除信号的失真和衰减问题，使信号的波形和强度达到所需要的要求，来扩大网络传输的距离。其原理是信号再生（而不是简单地将衰减信号放大）。两端的网络部分是网段，而不是子网。若出现故障，对相邻两个网段的工作将产生影响。<br>具有5-4-3规则：互相串联的中继器的个数不能超过4个，而且用4个中继器串联的5段通信介质中只有3个段可以挂接计算机，其余两个段只能用作扩展通信范围的链路段。<br>集线器：实质上是一个多端口的中继器，只起到信号放大和转发作用，其目的是扩大网络的传输范围，而不具备信号的定向传送能力。主要用于使用双绞线组件共享网络。由集线器组成的网络是共享式网络，每个端口连接的网络部分是同一个网络的不同网段，只能在半双工下工作。对信号进行放大后发到其他所有端口</p><p>选择题</p><p>7.一般来说，集线器连接的网络在拓扑结构上属于（星形）</p><p>8.用集线器连接的工作站集合（同属一个冲突域，也同属一个广播域）</p><h3 id="第3章-数据链路层"><a href="#第3章-数据链路层" class="headerlink" title="第3章 数据链路层"></a>第3章 数据链路层</h3><p>3.1 数据链路层的功能<br>功能：为网络层提供服务、链路管理、帧定界、帧同步与透明传输、流量控制和差错控制</p><p>3.2 组帧<br>字符计数法：在帧头部使用一个计数字段来标明帧内字符数<br>字符填充的首尾定界符法：使用特定字符定界帧的开始和结束，在数据中的特殊字符前面用转义字符填充<br>比特填充的首尾填充法：数据区每遇到连续5个1就填充0<br>违规编码法：信号传输过程中采用违规的编码来表示帧的起始和终止</p><p>3.3 差错控制<br>检错编码：奇偶校验码、循环冗余码<br>纠错编码：海明码</p><p>3.4 流量控制与可靠传输机制<br>可靠传输：数据链路层通常使用确认和超时重传两种机制来保证可靠传输<br>流量控制：<br>1）停止等待协议：发送方每发送一帧都要等待接收方的应答信号才能发送下一帧<br>发送窗口大小=1，接收窗口大小=1<br>2）后退N帧协议：发送方一次可发送N帧，按序接收，重传从最后一个确认开始<br>发送窗口大小&gt;1，接收窗口大小=1<br>当接收窗口大小为1时，可保证帧的有序接收。<br>若采用n个比特对帧编号，则其发送窗口的尺寸WT应满足：1≤WT≤2^n-1<br>3）选择重传协议：发送方一次可发送N帧，可以不按序接收，重传没有确认的帧<br>发送窗口大小&gt;1，接收窗口大小&gt;1<br>若采用n个比特对帧编号，需满足条件：接收窗口WR+发送窗口WT≤2^n；接收窗口WR≤2 ^(n-1)。当接收窗口为最大值时，WTmax=WRmax=2 ^(n-1)</p><p>信道的效率，也称为信道利用率，是对发送方而言的，是指发送方在一个发送周期的时间内，有效地发送数据所需要的时间占整个发送周期的比率。<br>例如，发送方从开始发送数据，到收到第一个确认帧为止，称为一个发送周期，设为T，发送方在这个周期内共发送L比特的数据，发送方的数据传输率为C，则发送方用于发送有效数据的时间为L/C，在这种情况下，信道的利用率为(L/C)/T<br>信道吞吐率=信道利用率*发送方的发送速率</p><p>选择题</p><p>11.对于窗口大小为n的滑动窗口，最多可以有（n-1）帧已发送但没有确认</p><p>3.5 介质访问控制<br>介质访问控制的任务是为使用介质的每个结点隔离来自同一信道上其他结点所传颂的信号，以协调活动结点的传输。</p><p>信道划分介质访问控制：<br>频分多路复用FDM：将多路基带信号调制到不同频率载波上再进行叠加形成一个复合信号<br>时分多路复用TDM：将物理信道按时间分为若干时间片，轮流给不同信号使用<br>波分多路复用WDM：在一根光纤中传输多种不同波长（频率）的光信号<br>码分多路复用CDM：靠不同的编码来区分各种原始信号，既共享信道的频率，又共享时间，例如码分多址CDMA技术</p><p>随机访问介质访问控制：<br>1）ALOHA协议<br>纯ALOHA：不检测直接发送，若无确认则等待重发<br>时隙ALOHA：将时间划分为若干等长时隙，按时发送<br>2）CSMA协议<br>1-坚持：闲则发送，忙则继续监听<br>非坚持：闲则发送，忙则等待一个随机时间再听<br>p-坚持：闲则以概率p发送，1-p等待下一个时隙，忙则等待一个随机时间再听</p><p>信道状态    1-坚持    非坚持    p-坚持<br>空闲    立即发送数据    立即发送数据    以概率p发送数据，以概率1-p推迟到下一个时隙<br>忙    继续坚持监听信道    放弃监听，等待一个随机的时间后再监听    放弃监听，等待一个随机的时间后再监听<br>3）载波侦听多路访问/碰撞检测CSMA/CD协议：不可能同时进行发送和接收，所以不可能进行全双工通信，只能进行半双工通信，适用于总线型网络或半双工网络<br>流程：先听后发，边听边发，冲突停发，随机重发<br>碰撞解决：采用二进制指数退避算法来解决碰撞问题</p><p>争用期：以太网端到端往返时间<br>最小帧长=总线传播时延 * 数据传输速率 * 2<br>以太网规定最短帧长为64B，凡长度小于64B的都是由于冲突而异常终止的无效帧。</p><p>问题：<br>a. 接收信号的强度往往会远小于发送信号的强度，且在无线介质上信号强度动态变化范围很广，因此若要实现碰撞检测，那么在硬件上需要的花费就会过大<br>b. 在无线通道中，并非所有的站点都能够听见对方，即“隐蔽站”问题</p><p>4）载波侦听多路访问/碰撞避免CSMA/CA协议：<br>避免碰撞：预约信道、ACK帧、RTS/CTS帧<br>解决碰撞：采用二进制指数退避算法来解决碰撞问题</p><p>CSMA/CD与CSMA/CA主要有如下区别：<br>1）CSMA/CD可以检测冲突，但无法避免；CSMA/CA发送包的同时不能检测到信道上有无冲突，本结点处没有冲突并不意味着在接收结点处就没有冲突，只能尽量避免<br>2）传输介质不同。CSMA/CD用于总线式以太网，而CSMA/CA则用于无线局域网802.11a/b/g/n<br>3）检测方式不同。CSMA/CD通过电缆中电压的变化来检测；而CSMA/CA采用能量检测、载波检测和能量载波混合检测三种检测信道空闲的方式<br>4）在本结点处有（无）冲突，并不一定意味着在接收结点处就有（无）冲突<br>总结：CSMA/CA协议的基本思想是在发送数据时先广播告知其他结点，让其他结点在某段时间内不要发送数据，以免出现碰撞。CSMA/CD协议的基本思想是发送前侦听，边发送边侦听，一旦出现碰撞马上停止发送。</p><p>轮询访问介质访问控制：令牌传递协议，只有得到令牌的机器才能发送数据，其他必须等待，非常适合负载很高的广播信道</p><p>选择题</p><p>2.时分多路复用TDM所利用的传输介质的性质是（介质的位速率大于单个信号的位速率）</p><p>3.从表面上看，FDM比TDM能更好地利用信道的传输能力，但现在计算机网络更多地使用TDM而不是FDM，其原因是（TDM可用于数字传输而FDM不行）</p><p>4.（统计时分多路复用）具有动态分配时隙的功能</p><p>12.以太网总，当数据传输率提高时，帧的发送时间就会相应的缩短，这样可能会影响到冲突的检测。为了能有效地检测冲突，可以使用的解决方案是（减少电缆介质的长度或增加最短帧长）</p><p>21.根据CSMA/CD协议的工作原理，需要提高最短帧长度的是（冲突域的最大距离不变，网络传输速率提高）</p><p>23.令牌环网络的拓扑结构为环状，只有获得了令牌的主机才能发送数据，因此（不存在冲突）</p><p>3.6 局域网<br>局域网是在一个较小的地理范围内将各种计算机、外部设备和数据库系统等通过双绞线、同轴电缆等连接介质互相连接起来，组成资源和信息共享的计算机互联网络。<br>1）拓扑结构：星形结构、环形结构、总线形结构、星形和总线形结合的复合型结构<br>2）传输介质：双绞线、同轴电缆、光纤<br>3）介质访问控制方式：CSMA/CD、令牌总线、令牌环，前两种用于总线形局域网，令牌环用于环形局域网<br>以太网：逻辑拓扑是总线形结构，物理拓扑是星形或拓展星形结构<br>令牌环：逻辑拓扑是环形结构，物理拓扑是星形结构<br>FDDI（光纤分布数字接口）：逻辑拓扑是环形结构，物理拓扑是环形结构</p><p>IEEE 802.3标准是一种基带总线型的局域网标准，描述物理层和数据链路层的MAC子层的实现方法。<br>通常将802.3局域网简称为以太网：无连接、不对发送的数据帧编号、也不要求接收方发送确认，即以太网尽最大努力交付数据，提供不可靠服务，对于差错的纠正则由高层完成</p><p>参数    10BASE5    10BASE2    10BASE-T    10BASE-FL<br>传输媒体    基带同轴电缆（粗缆）    基带同轴电缆（细缆）    非屏蔽双绞线    光纤对（850nm）<br>编码    曼彻斯特编码    曼彻斯特编码    曼彻斯特编码    曼彻斯特编码<br>拓扑结构    总线型    总线型    星形<br>最大段长    500m    185m    100m    2000m<br>最多结点数目    100    30    2    2<br>无线局域网：有固定基础设施无线局域网、无固定基础设施的无线局域网自组织网络</p><p>选择题</p><p>6.网卡实现的主要功能在（物理层和数据链路层）</p><p>3.7 广域网<br>广域网    局域网<br>覆盖范围    很广，通常跨区域    较小，通常在一个区域内<br>连接方式    结点之间都是点到点连接，但为了提高网络的可靠性，一个结点交换机往往与多个结点交换机相连    普遍采用多点接入技术<br>OSI层次    三层：物理层、数据链路层、网络层    两层：物理层、数据链路层<br>联系与相似点    1.广域网与局域网都是互联网的重要组成构件，从互联网的角度上看，二者平等 2.连接在一个广域网或一个局域网上的主机在该网内进行通信时，只需要使用其网络的物理地址即可<br>着重点    强调资源共享    强调数据传输<br>PPP协议：面向字节，采用字节填充方式，只支持全双工链路，提供差错检测但不提供纠错功能，只保证无差错接收<br>高级数据链路控制HDLC协议：面向比特，采用0比特插入法，帧类分为信息帧、监督帧和无编号帧，使用了编号和确认机制，能够提供可靠传输</p><p>3.8 数据链路层设备<br>网桥：把两个或多个以太网通过网桥连接起来变成一个网段，工作在链路层的MAC子层<br>1）透明网桥：按照自学习算法填写转发表，按转发表转发<br>2）源路由网桥：先发送发现帧，按返回结果转发（选择最佳路由）</p><p>局域网交换机：实际就是一个多端口网桥，工作在数据链路层<br>1）直通式：帧在接收后只检查目的地址，几乎能马上就被传出去<br>2）存储转发：先将接收到的帧缓存到高速缓存器，检查数据正确性<br>相同点：按MAC地址转发，都能隔离冲突域，不能隔离广播域</p><p>选择题</p><p>10.通过交换机连接的一组工作站（组成一个广播域，但不是一个冲突域）</p><p>11.一个16端口的集线器的冲突域和广播域的个数分别是（1,1）</p><p>12.一个16个端口的以太网交换机，冲突域和广播域的个数分别是（16,1）</p><h3 id="第4章-网络层"><a href="#第4章-网络层" class="headerlink" title="第4章 网络层"></a>第4章 网络层</h3><p>4.1 网络层的功能<br>异构网络互联<br>物理层中继系统：中继器、集线器Hub<br>数据链路层中继系统：网桥或交换机<br>网络层中继系统：路由器<br>网络层以上的中继系统：网关</p><p>路由与转发<br>路由器主要完成两个功能：一是路由选择（确定哪一条路径），另一个是分组转发（当一个分组到达时所采取的动作）<br>路由选择：指按照复杂的分布式算法，根据从各相邻路由器所得到的关于整个网络拓扑的变化情况，动态地改变所选择的路由。<br>分组转发：指路由器根据转发表将用户的IP数据报从合适的端口转发出去</p><p>拥塞控制<br>流量控制和拥塞控制的区别：流量控制往往是指在发送端和接收端之间的点对点通信量的控制。流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。而拥塞控制必须确保通信子网能够传送待传送的数据，是一个全局性的问题，涉及网络中所有的主机、路由器以及导致网络传输能力下降的所有因素。<br>方法：开环控制（静态，不考虑当前网络的状态）、闭环控制（动态，基于反馈环路）</p><p>选择题</p><p>2.路由器连接的异构网络指的是（数据链路层和物理层均不同）</p><p>4.在路由器进行互联的多个局域网的结构中，要求每个局域网（物理层、数据链路层、网络层协议可以不同，而网络层以上的高层协议必须相同）</p><p>4.2 路由算法<br>静态路由算法：由网络管理员手工配置路由信息<br>动态路由算法：通过路由器间彼此交换的信息来构造路由器，分为距离-向量和链路状态算法</p><p>距离-向量路由算法：每个结点仅与它的直接邻居交谈，它为它的邻居提供了自己到网络中所有其他结点的最低费用估计。RIP算法</p><p>链路状态路由算法：每个结点通过广播的方式与所有其他结点交谈，但它仅告诉它们与它直接相连的链路的费用。OSPF算法</p><p>链路状态算法比距离-路由算法有更好的规模可伸展性，距离-路由算法有可能遇到路由环路等问题。</p><p>层次路由：将互联网分成许多较小的自治系统，系统有权决定自己内部采用什么路由协议<br>1）内部网关协议：自治系统内部使用的网关协议，如RIP、OSPF<br>2）外部网关协议：自治系统之间使用的网关协议，如BGP</p><p>4.3 IPv4<br>首部：固定部分占20B，其中首部长度、总长度和片便宜的基本单位分别为4B、1B、8B</p><p>标志位中有3个比特，但只有MF位和DF位有意义，只有当DF=0时，该IP数据报才可以被分片，当MF=1时，表示相应的原始数据报还有后续的片，当MF=0时，表示该数据报是相应原始数据报的最后一个片。</p><p>IP地址：{&lt;网络号&gt;, &lt;主机号&gt;}，网络号标志主机（或路由器）所连接到的网络，主机号标志该主机（或路由器）。一个IP地址在整个因特网范围内是唯一的。<br>主机号全为0表示本网络本身；主机号全为1表示本网络的广播地址，又称直接广播地址。<br>32位全为0表示本网络上的本主机；32位全为1表示整个TCP/IP网络的广播地址，又称受限广播地址。</p><p>网络类别    最大可用网络数    第一个可用的网络号    最后一个可用的网络号    每个网络中的最大主机数<br>A    2^7-2    1    126    2^24-2<br>B    2^14-1    128.1    191.255    2^16-2<br>C    2^21-1    192.0.1    223.255.255    2^8-2<br>网络地址转换NAT：实现专用网络地址和公用网络地址之间的相互转换<br>子网划分：采用子网掩码对物理子网再一次进行子网划分，{&lt;网络号&gt;, &lt;子网号&gt;, &lt;主机号&gt;}<br>子网掩码：1对应于IP地址中的网络号及子网号，而0对应于主机号，计算机只需将IP地址和其对应的子网掩码逐位相与，就可得出相应子网的网络地址。<br>无分类域间路由选择CIDR：在变长子网掩码的基础上提出的一种消除传统A、B、C类网络划分，{&lt;网络前缀&gt;, &lt;主机号&gt;}<br>路由聚合：将网络前缀都相同的连续的IP地址组成“CIDR地址块”<br>目的：使得一个地址块可以表示很多地址，减少路由表表项和路由器间的信息交换<br>方法：把一串IP地址都写为二进制表示，取最长的公共前缀作为网络号<br>地址解析协议ARP：工作在网络层，对于特定的IP地址，查询其对应的物理地址<br>动态主机配置协议DHCP：是应用层协议，基于UDP，给网络中的主机动态的分配IP地址<br>网际控制报文协议ICMP：是IP层协议，用来给主机或路由器报告差错和异常情况<br>ICMP差错报告报文用于目标主机或到目标主机路径上的路由器向源主机报告差错和异常情况。1）源点不可达 2）源点抑制 3）时间超过 4）参数问题 5）改变路由（重定向）<br>ICMP查询报文：回送请求和回答报文、时间戳请求和回答报文、掩码地址请求和回答报文、路由器询问和通告报文<br>Ping使用了ICMP回送请求和回答报文，工作在应用层；<br>traceroute（Tracert）使用了ICMP时间超过报文，工作在网络层。</p><p>4.4 IPv6<br>IPv6：首部40B，地址长度16B，主要用于解决IPv4的地址耗尽问题<br>IPv6只有在包的源结点才能分片，首部长度必须是8B的整数倍，没有提供校验和字段</p><p>IPv4向IPv5过渡：<br>1）双协议栈：指在完全过渡到IPv6之前，使一部分主机（或路由器）装有那个协议栈，一个IPv4和一个IPv6<br>2）隧道技术：将整个IPv6数据报封装到IPv4数据报的数据部分</p><p>4.5 路由协议<br>内部网关协议IGP：在一个自治系统内部使用的路由选择协议<br>1）路由信息协议RIP：基于距离-向量路由选择协议，是应用层协议，使用UDP，与相邻路由器交换整个路由表，允许一条路径最多只能包含15个路由器（即最多允许15跳），因此距离等于16时，表示网络不可达；会出现慢收敛现象，俗称“坏消息传的慢”，不一定是时间最短的，但一定是具有最少路由器的路径<br>2）开放最短路径优先OSPF协议：基于链路状态路由算法，是网络层协议，使用IP，与所有路由器交换相邻结点链路状态</p><p>外部网关协议EGP：<br>BGP协议：基于路径向量路由选择协议，是应用层协议，使用TCP，寻找的并非最佳路由</p><p>协议    RIP    OSPF    BGP<br>类型    内部    内部    外部<br>路由算法    距离-向量    链路状态    路径-向量<br>传递协议    UDP    IP    TCP<br>路径选择    跳数最少    代价最低    较好，非最佳<br>交换结点    和本结点相邻的路由器    网络中的所有路由器    和本结点相邻的路由器<br>交换内容    当前本路由器知道的全部信息，即自己的路由表    与本路由器相邻的所有路由器的链路状态    首次：整个路由表；非首次：有变化的部分<br>4.6 组播<br>IP组播：在发送者和每一接收者之间实现点对多点网络连接，仅应用于UDP协议，使用D类地址，范围为224.0.0.0~239.255.255.255，只有23位可用作组播</p><p>选择题</p><p>2.在设计组播路由时，为了避免路由环路，（构造组播转发树）</p><p>4.7 移动IP<br>移动IP：移动结点以固定的网络IP地址，实现跨越不同网段的漫游功能<br>组成：移动结点、本地代理（归属代理）、外部代理</p><p>4.8 网络层设备<br>路由器：可以用来连接异构网络，完成路由转发，能隔离冲突域和广播域，依照IP地址转发，属于网络层设备，实现了网络模型的下三层，即物理层、数据链路层、网络层<br>组成：<br>1）控制部分（路由选择）：路由选择处理机，根据路由协议构造、更新与维护路由表<br>2）分组转发部分：交换结构、一组输入端口和一组输出端口</p><p>路由器和网桥的区别是：网桥与高层协议无关，而路由器是面向协议的</p><p>路由表：目的网络IP地址、子网掩码、下一条IP地址、接口</p><p>选择题</p><p>2.要控制网络上的广播风暴，可以采用的方法是（用路由器将网络分段）</p><p>8.路由器中计算路由信息的是（路由选择处理机）</p><h3 id="第5章-传输层"><a href="#第5章-传输层" class="headerlink" title="第5章 传输层"></a>第5章 传输层</h3><p>5.1 传输层提供的服务<br>传输层为运行在不同主机上的进程之间提供了逻辑通信，而网络层提供了主机之间的逻辑通信。<br>功能：<br>1）提供应用进程之间的逻辑通信（即端到端的通信），与网络层的区别是，网络层提供的是主机之间的逻辑通信<br>2）复用和分用<br>3）对收到的报文进行差错检测（首部和数据部分），而网络层只检查IP数据报的首部，不检查数据部分是否出错<br>4）面向连接的TCP和无连接的UDP</p><p>服务端使用的端口号：0<del>1023<br>客户端使用的端口号：49152</del>65535</p><p>套接字=（主机IP地址，端口号），唯一地标识了网络中的一个主机和其上的一个应用（进程）</p><p>TCP：全双工的可靠逻辑信道，面向连接，适用于文件传输协议FTP、超文本传输协议HTTP、远程登录TELNET<br>UDP：不可靠的逻辑信道，无连接，应用于小文件传送协议TFTP、DNS、SNMP和实时协议RTP</p><p>选择题</p><p>4.关于传输层的面向连接服务的特性石（保证可靠和顺序的交付）</p><p>7.以下哪一项能够唯一确定一个在互联网上通信的进程（IP地址及端口号）</p><p>13.如果用户程序使用UDP协议进行数据传输，那么（应用层）协议必须承担可靠性方面的全部工作</p><p>5.2 UDP协议<br>只在IP的数据报服务之上增加了两个最基本的服务：复用和分用以及差错检测<br>所有维护传输可靠性的工作需要用户在应用层来完成。</p><p>特点：无连接、首部开销小、最大努力交付、应用层要保证可靠性<br>首部：8B，分别为源端口号，目的端口号、长度、校验和<br>检验：采用首部、伪首部、数据进行二进制反码运算求和再取反</p><p>5.3 TCP协议<br>特点：有连接、点对点（一对一）、提供可靠交付、全双工通信、面向字节流<br>首部：20B，源端口、目的端口、序号、确认号等控制信息<br>连接管理：三次握手建立、四次握手释放<br>可靠传输机制<br>1）序号：用来保证数据能有序提交给应用层<br>2）确认：确认号为期待收到的下一个报文段第一个字节的序号<br>3）重传：<br>超时：计时器到期还没收到确认则重传对应报文<br>冗余确认：当收到失序报文时向发送端发送冗余ACK</p><p>流量控制：在确认报文中设置接收窗口rwnd的值来限制发送速率</p><p>拥塞控制：根据自己估算的网络拥塞程序设置cwnd的值来限制发送速率<br>慢开始：当cwnd&lt;ssthresh时，每收到一个报文段的确认cwnd加1<br>拥塞避免：当cwnd&gt;ssthresh时，每经过一个往返延时cwnd加1<br>快重传：当收到连续的三个重复的ACK，直接重传对方期待的报文<br>快恢复：当收到连续的三个冗余ACK，令ssthresh=cwnd=cwnd/2</p><p>拥塞处理：ssthresh置为原cwnd的一半，cwnd置1</p><h3 id="第6章-应用层"><a href="#第6章-应用层" class="headerlink" title="第6章 应用层"></a>第6章 应用层</h3><p>6.1 网络应用模型<br>C/S模型：区分处理请求的服务器和发出请求的客户机<br>P2P模型：每台机器既是服务器又是客户机</p><p>6.2 DNS系统<br>作用：把主机名转换为IP地址<br>协议与端口：运行在UDP之上，使用53号端口</p><p>服务器分类<br>根域名服务器：知道所有顶级域名服务器的IP地址<br>顶级域名服务器：负责管理在其服务器注册的所有二级域名<br>授权域名服务器：能够将其管辖的主机名转换为该主机的IP地址<br>本地域名服务器：本地网络提供商负责的域名服务器</p><p>查询方式<br>递归查询：由查询的服务器发起下一次的查询<br>递归与迭代结合：除第一次查询外，其余均由本地域名服务器向外查询</p><p>6.3 文件传输协议FTP<br>作用：允许用户在因特网上存取文件<br>协议与端口：运行在TCP之上，控制连接为21号端口，数据连接为20号端口<br>控制连接、数据连接</p><p>6.4 电子邮件<br>SMTP（推）<br>作用：向邮件服务器主动发送电子邮件<br>协议与端口：运行在TCP之上，使用25号端口</p><p>POP3（拉）<br>作用：向邮件服务器要求接收电子邮件<br>协议与端口：运行在TCP之上，使用110号端口</p><p>6.5 万维网<br>统一资源定位符：负责标识万维网上各种文档</p><p>超文本传输协议<br>作用：在万维网上能够可靠地交换文件<br>协议与端口：运行在TCP之上，使用80号端口</p><p>超文本标记语言：文档结构标记语言，使用约定的标记对页面上的各种信息进行描述</p>]]></content>
      
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>英语写作</title>
      <link href="/SYSU/%E8%8B%B1%E8%AF%AD%E5%86%99%E4%BD%9C/"/>
      <url>/SYSU/%E8%8B%B1%E8%AF%AD%E5%86%99%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h2><h3 id="长短句原则"><a href="#长短句原则" class="headerlink" title="长短句原则"></a>长短句原则</h3><p>开头段：用一长一短，先长后短</p><p>主体段：先用一个短句解释主要意思，然后在阐述几个要点的时候采用先短后长的句群形式</p><p>结尾段：一长一短，总结升华</p><h3 id="主题句原则"><a href="#主题句原则" class="headerlink" title="主题句原则"></a>主题句原则</h3><p>表明主体和观点的中心句放在文章开头或者结尾</p><h3 id="一二三原则"><a href="#一二三原则" class="headerlink" title="一二三原则"></a>一二三原则</h3><p>使用代表顺序的关键性标签，理清文章结构，推荐表达：</p><ul><li><strong>to begin with, then, furthermore, finally</strong></li><li><strong>to start with, next, in addition, finally</strong></li><li><strong>first and foremost, besides, last but not least</strong></li><li><strong>most important of all, moreover, finally</strong></li></ul><p>两方面时的表达：</p><ul><li><strong>on the one hand, on the other hand</strong></li><li><strong>for one thing, for another thing</strong></li></ul><h3 id="短语优先原则"><a href="#短语优先原则" class="headerlink" title="短语优先原则"></a>短语优先原则</h3><p>使用短语可以增加文章亮点，也可以凑字数</p><h3 id="使用关联词"><a href="#使用关联词" class="headerlink" title="使用关联词"></a>使用关联词</h3><p>使用关联词使句子间的联系更加紧密，过渡更加自然</p><h4 id="并列递进"><a href="#并列递进" class="headerlink" title="并列递进"></a>并列递进</h4><ul><li><strong>besides</strong>：此外；而且；再说；以及</li><li><strong>furthermore</strong>：此外；而且；再者</li><li><strong>moreover</strong>：此外；而且</li><li><strong>not only but also</strong>：不仅， 也</li><li><strong>What is more</strong>：此外</li><li><strong>in addition</strong>：此外</li></ul><h4 id="转折"><a href="#转折" class="headerlink" title="转折"></a>转折</h4><ul><li><p><strong>in spite of</strong>：尽管；不顾；虽然，后跟名词。例如：In spite of our best efforts, we weren’t able to locate the name of the author of these photographs.</p></li><li><p><strong>despite</strong>：不管；尽管；任凭，后面可跟名词、动词ing或句子</p></li><li><p><strong>despite that</strong>：尽管如此，后跟句子</p></li><li><p><strong>however</strong>：然而；不过</p></li><li><p><strong>nevertheless</strong>：然而，与后面的句子通过逗号隔开。例如：Save your breath not to ask me of this question again. Nevertheless, you still won’t let it go.</p></li><li><p><strong>notwithstanding</strong>：尽管</p></li><li><p><strong>yet</strong>：然而；但是</p></li></ul><h4 id="因果"><a href="#因果" class="headerlink" title="因果"></a>因果</h4><ul><li><strong>therefore</strong>：因此，常用逗号与从句隔开</li><li><strong>as a result</strong>：因此；结果是；作为结果</li><li><strong>so that</strong>：因此；以便</li><li><strong>for this reason</strong>：为此；由于这个原因</li><li><strong>consequently</strong>：因此</li><li><strong>due to</strong>：由于</li><li><strong>thanks to</strong>：由于；幸亏；多亏</li><li><strong>because of</strong>：因为</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><strong>in conclusion</strong>：总之；总而言之，单独用，用逗号与主句隔开</li><li><strong>to sum up</strong>：概括地说。例如：If I had to sum up in one phrase what makes a good manager, I’d say that it’s that ability to make decisions.</li><li><strong>in summary</strong>：总之；总结</li><li><strong>in brief</strong>：简言之；简而言之</li></ul><h2 id="文章布局"><a href="#文章布局" class="headerlink" title="文章布局"></a>文章布局</h2><h3 id="首段"><a href="#首段" class="headerlink" title="首段"></a>首段</h3><h4 id="引出话题"><a href="#引出话题" class="headerlink" title="引出话题"></a>引出话题</h4><ol><li><p>With the development of science and technology, more and more people believe / (come to realize) that…</p><p>随着科技的发展,越来越多的人认为…</p></li><li><p>When it comes to …., some people believe that…. Others argue/claim that the opposite/reverse is true. There is probably some truth in both arguments/statements, but I tend to the former/latter.</p><p>对立法——先引出其他人的不同看法，然后提出自己的看法或者偏向于某一看法，适用于有争议性的主题</p></li><li><p>Recently the rise in the problem/phenomenon of … has aroused public/popular/wide/worldwide concern.</p><p>现象法——引出要剖析的现象或者问题，然后评论</p></li><li><p>It goes without saying that we cannot be young forever. </p><p>适用于自编名言</p></li><li><p>As aproverb says，“Where there is a will，there is a way. “</p><p>适用于谚语</p></li><li><p>From the graph（table，chart）listed above，it can be seen that</p><p>适用于图表类</p></li><li><p>According to a recent survey, about 78.9% of the college students want to further their study after their graduation.  </p><p>适用于调查类</p></li></ol><h4 id="表示变化"><a href="#表示变化" class="headerlink" title="表示变化"></a>表示变化</h4><ol><li>Great changes have taken place in our life．</li><li>Some changes have taken place in the past five years．</li></ol><h3 id="主体"><a href="#主体" class="headerlink" title="主体"></a>主体</h3><p>表明自己观点，使用关联词组织论证</p><p>3种递进关系词</p><ol><li>first and foremost, besides, last but not least</li><li>to begin with, then, furthermore, finally</li><li>to start with, next, in addition, finally</li><li>most important of all, moreover, finally</li></ol><p>出现两点情况，使用：</p><ol><li>on the one hand, on the other hand</li><li>for one thing, for another thing</li></ol><h4 id="图表分析"><a href="#图表分析" class="headerlink" title="图表分析"></a>图表分析</h4><ol><li><p>As is shown in the graph…  </p><p>如图所示…</p></li><li><p>As can be seen from the table, …  </p><p>从表格中可以看出… </p></li><li><p>The graph shows that…  </p><p>图表显示… </p></li><li><p>From the chart, we know that…  </p><p>从这张表中,我们可知…</p></li><li><p>All these data clearly prove the fact that… </p><p>所有这些数据明显证明这一事实,即… </p></li><li><p>The increase of …. in the city has reached to 20%. </p><p>这个城市的….增长已达到20%.</p></li><li><p>In 1985, the number remained the same. </p><p>1985年,这个数字保持不变.</p></li><li><p>There was a gradual decline in 1989.</p><p>1989年,出现了逐渐下降的情况.</p></li><li><p>According to statistics proved by …, it can be seen that …</p></li></ol><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><ol><li>…is often cited as an example.</li><li>A good case in point is …</li></ol><h4 id="观点"><a href="#观点" class="headerlink" title="观点"></a>观点</h4><ol><li><p>People’s views on… vary from person to person. Some hold that… . However, others believe that….</p><p>人们对……的观点因人而异。有些人认为…..然而其他人却认为……</p></li><li><p>Different people hold different attitudes toward (failure). Some hold that… . However, others believe that….</p><p>对(失败)人们的态度各不相同。</p></li><li><p>Attitudes towards (drugs) vary from person to person. Some hold that… . However, others believe that….</p><p>人们对待吸毒的态度因人而异。</p></li><li><p>There is a grain of truth in these statements, but they ignore a more important fact.</p></li><li><p>Contrary to what is widely accepted, I maintain that </p></li></ol><h4 id="引出原因"><a href="#引出原因" class="headerlink" title="引出原因"></a>引出原因</h4><ol><li>A number of factors might contribute to （lead to）（account for）the phenomenon（problem）.</li><li>The reasons for this are as follows．</li><li>The reason for this is not far to seek.</li></ol><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ol><li><p>There is no doubt that it has its negative effects as well as positive effects.</p><p>毫无疑问，它有负面影响和积极影响。</p></li><li><p>It is of great benefit to us</p></li></ol><h4 id="表示重要"><a href="#表示重要" class="headerlink" title="表示重要"></a>表示重要</h4><ol><li>It plays an important role in our life．</li><li>It is important（necessary，difficult，convenient， possible）for sb．to do sth</li></ol><h4 id="表示措施"><a href="#表示措施" class="headerlink" title="表示措施"></a>表示措施</h4><ol><li>Some measures should be taken to deal with the problem that we are faced with.</li><li>We should try our best to overcome the difficulties that we are faced with．</li><li>We should take some effective measures to solve the problems that we are faced with．</li></ol><h4 id="表示事实"><a href="#表示事实" class="headerlink" title="表示事实"></a>表示事实</h4><ol><li>We cannot ignore the fact that．．．</li><li>No one can deny the fact that．．． </li><li>There is no denying the fact that．．． </li><li>This is a phenomenon that many people are interested in． </li></ol><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><ol><li>A may be preferable to B, but A suffers from the disadvantages that…</li><li>Compared with A，B．．． </li><li>I prefer to read rather than watch TV．</li></ol><h4 id="表示数量"><a href="#表示数量" class="headerlink" title="表示数量"></a>表示数量</h4><ol><li>The population in this city has now increased （decreased）to 800000． </li><li>The output of July in this factory increased by 15％ compared with that of January．</li></ol><h3 id="尾段"><a href="#尾段" class="headerlink" title="尾段"></a>尾段</h3><h4 id="提出结论"><a href="#提出结论" class="headerlink" title="提出结论"></a>提出结论</h4><ol><li><p>Taking all these factors into consideration, we naturally come to the conclusion that…</p><p>把所有这些因素加以考虑，我们自然会得出结论……</p></li><li><p>Taking into account all these factors, we may reasonably come to the conclusion that…</p><p>考虑所有这些因素，我们可能会得出合理的结论……</p></li><li><p>From what has been mentioned/discussed above，we can come to /draw the conclusion that ．．．</p><p>考虑所有这些因素，我们可能会得出合理的结论……</p></li><li><p>Obviously, we can draw the conclusion that…</p><p>显然，我们可以得出结论…</p></li></ol><h4 id="号召建议"><a href="#号召建议" class="headerlink" title="号召建议"></a>号召建议</h4><ol><li><p>It is high time that we took some measures to put an end to the trend  (后可跟定语从句). </p><p>该是我们采取措施停止这一趋势的时候了。</p></li><li><p>Only in this way can we… (倒装句)</p><p>只有这样,我们才能…</p></li><li><p>There is no doubt that enough concern must be paid to the problem of …</p><p>毫无疑问，对……问题应予以足够的重视。</p></li><li><p>It is essential thar effective measures should be taken to correct the tendency.</p><p>必须采取有效措施纠正这一趋势。</p></li><li><p>Following these suggestions may not guarantee the success, but the pay off might be worth the effort . It will not only benefit but also bring us an even brighter future.</p><p>以下这些建议，并不能保证成功，但回报可能是值得的努力。这不仅将造福，也有利于…</p></li><li><p>With the efforts of all parts concerned, the problem will be solved thoroughly.</p></li></ol><h4 id="预示后果"><a href="#预示后果" class="headerlink" title="预示后果"></a>预示后果</h4><ol><li><p>No doubt, unless we take effective measures, it is very likely that…</p><p>毫无疑问，除非我们采取有效措施，很可能会……</p></li><li><p>In summary, if we continue to ignore the above-mentioned issue, more problems will crop up.</p></li></ol><h2 id="高级句式"><a href="#高级句式" class="headerlink" title="高级句式"></a>高级句式</h2><h3 id="独立主格"><a href="#独立主格" class="headerlink" title="独立主格"></a>独立主格</h3><h3 id="倒装句"><a href="#倒装句" class="headerlink" title="倒装句"></a>倒装句</h3><ol><li>Only through these measures can we hope to solve the problem.</li></ol><h3 id="被动句"><a href="#被动句" class="headerlink" title="被动句"></a>被动句</h3><ol><li>Some measures should be taken to deal with the problem.</li><li>It is believed that…</li></ol><h3 id="强调句"><a href="#强调句" class="headerlink" title="强调句"></a>强调句</h3><p>是否是强调句有一个方法，就是将that以后的“句子的其余部分”拿出来单独看，看有没有缺成分，缺的是什么成分，再把谓语动词后面that前面的那部分，带到你认为缺成分的地方，如果放进去是一句完整的句子了，那就说明是强调句</p><ol><li><p>It is the times that produce their heroes.</p><p>强调主语</p></li><li><p>It is English that Prof.Lin teaches us.</p><p>强调宾语</p></li><li><p>It was in shanghai that I saw the film.</p><p>强调状语</p></li></ol><h3 id="主语从句"><a href="#主语从句" class="headerlink" title="主语从句"></a>主语从句</h3><h4 id="常规主语从句"><a href="#常规主语从句" class="headerlink" title="常规主语从句"></a>常规主语从句</h4><p>在主从复合句中充当主语，主语从句的连词主要有：</p><p>从属连词：that whether</p><p>连接代词：who whoever whom whose what whatever which whichever</p><p>连接副词：when where how why whenever wherever however</p><p>连词位于句首不能省略，主语从句的时态不受主句时态的影响和限制</p><ol><li>That he finished writing the composition in such a short time surprised us all.</li><li>Whether we will go for an outing tomorrow remains unknown.</li><li>Whom we must study for is a question of great importance.</li><li>What caused the accident remains unknown.</li></ol><h4 id="形式主语从句"><a href="#形式主语从句" class="headerlink" title="形式主语从句"></a>形式主语从句</h4><p>形式主语 it 位于句首引导从句，真正主语搁置于句末。由于主语从句一般被认为是单数形式，形式主语的谓语动词、be动词+表语 均为单数第三人称形式或过去式。</p><ol><li>It is common knowledge that honesty is the best policy.</li><li>It goes without saying that… </li><li>It is universally acknowledged that…</li></ol><h3 id="名词性从句"><a href="#名词性从句" class="headerlink" title="名词性从句"></a>名词性从句</h3><p>主句谓语动词是现在或将来时，从句谓语动词可以用任何需要的时态</p><p>主句谓语动词是过去时，从句谓语动词一般需用过去时或过去完成时。</p><p>从句时态不受下列客观的条件影响：从句说明的是不受时间限制的事实或真理（客观真理）、从句表示的是反复出现的时态不变、从句的谓语动作仍在继续时，或者表示现在仍在的状态时，时态不变。</p><h4 id="宾语从句"><a href="#宾语从句" class="headerlink" title="宾语从句"></a>宾语从句</h4><p>在主从复合句中充当宾语，位于<strong>及物动词</strong>、<strong>介词</strong>或<strong>复合谓语</strong>之后的从句称为宾语从句。宾语从句分为三类：动词的宾语从句，介词的宾语从句和形容词的宾语从句。宾语从句的语序必须是陈述语序。谓语动词、介词、动词不定式、动词现在分词、过去式、过去分词后面都能带宾语从句。有些形容词（ afraid, sure, glad 等）之后也可以带宾语从句。</p><p>特点：</p><ol><li>连接词that引导宾语从句在句中无词义，不充当句子成分</li><li>宾语从句的语序一律用陈述句语序</li><li>宾语从句可以作及物动词、介词及形容词的宾语</li><li>宾语从句的从属连词主要有 that , if , whether 。that 引导表示陈述句的宾语从句,而 if 和 whether 引导表示“是否”的宾语从句</li><li>连接代词主要有 who, whom , whose , what , whoever , whomever , whosever, whatever,  whichever等.连接代词一般指疑问,但 what ,  whatever 除了指疑问外,也可以指陈述。</li><li>如果从句太长，可以用形式宾语 it</li><li>动词 find, feel, consider, make, believe等后面有宾语补足语的时候,则需要用it做形式宾语而将 that 宾语从句后置.I think it necessary that we take plenty of hot water every day .</li><li>有些动词带宾语从句时需要在宾语与从句前加it这类动词主要有: hate, take , owe, have, see to.<ol><li>I hate it when they talk with their mouths full of food.我讨厌他们满嘴食物时说话.（when引导时间状语从句，it是代词，代指这种情况）</li><li>I hate it that i love you.我讨厌我爱你（it是形式宾语，that引导宾语从句）</li><li>We take it that you will agree with us.（it是形式宾语，that引导宾语从句）</li></ol></li><li>形容词的宾语从句常用来引导宾语从句的形容词有: sure, certain, glad, please, happy, sorry, afraid, satisfied, surprised</li><li>if,whether在宾语从句中的区别<ol><li>if和whether在作“是否”解时,引导宾语从句常放在动词know,ask,care,wonder,find out等之后,介词后一般不用if</li><li>少数动词,如:leave,put,discuss,doubt后的宾语从句常用whether</li><li>whether后可以加or not,但是if不可以.</li><li>在不定式前只能用whether.如： I can’t decide whether to stay. 我不能决定是否留下</li><li>避免歧义时,我们常用whether而不用if.</li></ol></li></ol><h4 id="表语从句"><a href="#表语从句" class="headerlink" title="表语从句"></a>表语从句</h4><h3 id="同位语从句"><a href="#同位语从句" class="headerlink" title="同位语从句"></a>同位语从句</h3><h3 id="状语从句"><a href="#状语从句" class="headerlink" title="状语从句"></a>状语从句</h3><p>表时间，原因，地点，条件，让步，转折等</p><ol><li>When the man is enjoying the cigarette, the smoke becmes a monster (怪物) which will devour him.</li><li>Whatever the reason, there are still some problems with student use of computers.</li></ol><h3 id="定语从句"><a href="#定语从句" class="headerlink" title="定语从句"></a>定语从句</h3><p>修饰限制先行词</p><ol><li><p>There are many reasons why I want to study in your university.</p></li><li><p>Helen is the most beautiful girl that I have ever seen.</p><p>~ the + 形容词最高级 + 名词 + (that) + 主语 + have ever + seen</p></li><li></li><li></li><li></li><li></li></ol><h3 id="分词短语做定语或状语"><a href="#分词短语做定语或状语" class="headerlink" title="分词短语做定语或状语"></a>分词短语做定语或状语</h3><ol><li>Prof. Kang came to our university, giving us a lecture on how to acquire English better.</li></ol><h3 id="介词引导的分词短语"><a href="#介词引导的分词短语" class="headerlink" title="介词引导的分词短语"></a>介词引导的分词短语</h3><ol><li><p>We cannot emphasize the importance of protecting our eyes too much.</p><p>我们再怎么强调保护眼睛的重要性也不为过。</p></li><li></li></ol><h2 id="词汇替换"><a href="#词汇替换" class="headerlink" title="词汇替换"></a>词汇替换</h2><ol><li>大多数人 most people→ the majority of the population </li><li>经常 often→frequently </li><li>我相信 I believe→ from my standpoint, from my perspective </li><li>必须 must→ it is a must for us to… </li><li>知道 know→ be aware of </li><li>因为 because→in that </li><li>最后 at last→eventually </li><li>然而 but→however </li><li>如果 if→provided that </li><li>各行各业的人 all kinds of people→people from all walks of life </li><li>引起，导致 lead to→contribute to </li><li>人 people→individuals </li><li>好的 good→desirable, benefitial </li><li>坏的 bad→undesirable </li><li>很多many→ numerous </li><li>越来越more and more→ a increasing/mounting number of </li><li>很very→extremely </li><li>方面side→aspects </li><li>表明 show→demonstrate, indicate </li><li>利用 use→utilize </li><li>因此/结果so→therefore </li><li>部分 part→proportion </li><li>提高 improve→enhance </li><li>改变 change→transform </li><li>强调/重视 emphasize→ attach great importance to </li><li>培养 develop→cultivate </li><li>破坏 destroy→undermine </li><li>解决 deal with →tackle /figure out </li><li>普遍的 everywhere→universal </li><li>明显的obvious→apparent </li><li>在当今社会in the modern society→in the current society </li><li>使 make→enable</li></ol><p>​        1、individuals, characters, folks替换(people ,persons)<br>　　2、positive, favorable, rosy (美好的)，promising (有希望的)，perfect, pleasurable , excellent, outstanding, superior替换good<br>　　3、dreadful, unfavorable, poor, adverse, ill (有害的)替换bad 如果bad做表语，可以有be less impressive替换<br>　　eg.An army of college students indulge themselves in playing games,enjoying romance with girls/boys or killing time passively in their dorms. When it approaches to graduation ,as a result, they find their academic records are less impressive.<br>　　4、(an army of, an ocean of, a sea of, a multitude of ,a host of, many, if not most)替换many.<br>　　注：用many, if not most 一定要小心，many后一定要有词。<br>　　Eg. Many individuals, if not most, harbor the idea that….同理 用most, if not all ,替换most.<br>　　5、a slice of, quiet a few , several替换some<br>　　6、harbor the idea that, take the attitude that, hold the view that, it is widely shared that, it is universally acknowledged that)替think (因为是书面语，所以要加that)<br>　　7、affair ,business ,matter 替换thing<br>　　8、shared 代 common<br>　　9、reap huge fruits 替换get many benefits )<br>　　10、for my part ,from my own perspective 替换 in my opinion<br>　　11、Increasing(ly),growing 替换more and more( 注意没有growingly这种形式。所以当修饰名词时用increasing/growing.修饰形容词，副词用increasingly.<br>　　关注：英语六级简答题的命题规律和对策<br>　　Eg.sth has gained growing popularity.<br>　　Sth is increasingly popular with the advancement of sth.<br>　　12、little if anything, 或little or nothing替换hardly<br>　　13、beneficial, rewarding替换helpful,<br>　　14、shopper, client, consumer, purchaser, 替换customer<br>　　15、exceedingly, extremely, intensely 替换very<br>　　16、hardly necessary, hardly inevitable … 替换 unnecessary, avoidable<br>　　17、sth appeals to sb, sth exerts a tremendous fascination on sb 替换sb take interest in / sb. be interested in<br>　　18、capture one’s attention替换attract one’s attention.<br>　　19、facet, dimension , sphere代aspect<br>　　20、be indicative of ,be suggestive of ,be fearful of代 indicate, suggest ,fear<br>　　21、give rise to, lead to, result in, trigger 替换cause.<br>　　22、There are several reasons behind sth 替换..reasons for sth<br>　　23、desire 替换want.<br>　　24、pour attention into 替换pay attention to<br>　　25、bear in mind that 替换remember<br>　　26、enjoy, possess 替换have(注意process是过程的意思)<br>　　27、interaction替换communication<br>　　28、frown on sth替换 be against , disagree with sth<br>　　29、to name only a few, as an example替换 for example, for instance</p><h2 id="写作词汇"><a href="#写作词汇" class="headerlink" title="写作词汇"></a>写作词汇</h2><h3 id="环境保护类"><a href="#环境保护类" class="headerlink" title="环境保护类"></a>环境保护类</h3><h4 id="环境保护"><a href="#环境保护" class="headerlink" title="环境保护"></a>环境保护</h4><p>提高环保意识 enhance environmental awareness<br>环境保护 environmental protection<br>保持生态系统 keep ecological balance<br>生态系统 ecosystem<br>自然保护区 nature reserve<br>可持续发展战略 sustainable development strategy<br>宜人的生活环境 pleasant living environment</p><h4 id="节能减排"><a href="#节能减排" class="headerlink" title="节能减排"></a>节能减排</h4><p>节能（节约能源） save energy<br>减排（减少温室气体排放） reduce the emission of greenhouse gases<br>降低资源消耗率 slow down the rate of resource degradation<br>环保产品 environment-friendly products<br>全球变暖 global warming<br>低碳经济 low carbon economy<br>清洁可再生能源 clean renewable energy<br>核能 nuclear energy<br>太阳能 solar energy<br>大功率电器 high-power electrical appliance<br>二氧化碳 carbon dioxide<br>气候变化 climate change</p><h4 id="环境恶化"><a href="#环境恶化" class="headerlink" title="环境恶化"></a>环境恶化</h4><p>环境恶化 environmental deterioration<br>乱砍滥伐 deforestation<br>防止过度利用森林 protect forests from overexploitation<br>水土流失 water and soil erosion<br>沙漠化 desertification<br>人口增长 population growth<br>野生动物保护 wildlife protection<br>濒危物种 endangered species<br>野生物种 wild species<br>商业捕鱼 commercial fishing<br>过度捕捞 overfishing<br>过度开发 reckless exploitation</p><h4 id="自然灾害"><a href="#自然灾害" class="headerlink" title="自然灾害"></a>自然灾害</h4><p>自然灾害 natural disasters<br>大灾难 catastrophe<br>破坏性灾难性地震 destructive and disastrous earthquake<br>沙尘暴 sandstorm<br>沙丘 sand dune/hill<br>旱灾 drought<br>水灾 flood<br>雪灾 snowstorm<br>环境污染<br>环境治理<br>污染者负担的政策 “the-polluters-pay” policy<br>执法检查 law enforcement inspection<br>限期治理 undertake treatment within a prescribed limit of time</p><h4 id="白色污染"><a href="#白色污染" class="headerlink" title="白色污染"></a>白色污染</h4><p>白色污染 white pollution<br>限制使用一次性塑料袋 limit/ban/prohibit the use of disposable plastic bags<br>可降解一次性塑料袋 throwaway bio-degradable plastic bags<br>一次性筷子 disposable chopsticks<br>垃圾处理<br>乱扔垃圾 litter<br>垃圾分类 garbage classification<br>丢弃 throw, discard<br>垃圾 trash, rubbish, garbage<br>城市垃圾无害处理 decontamination of urban refuse<br>三废 three types of wastes（waste water, waste gas, solid waster）<br>工业废弃物 industrial waste</p><h4 id="空气污染"><a href="#空气污染" class="headerlink" title="空气污染"></a>空气污染</h4><p>空气污染浓度 air pollution concentration<br>汽车尾气排放 motor vehicle exhaust<br>尾气净化器 exhaust purifier<br>无铅汽油 lead-free gasoline<br>天然气汽车 gas-fueled vehicles<br>电动汽车 cell-driven vehicles<br>小排量汽车 small-engine vehicles<br>工业粉尘排放 industrial dust discharge<br>烟尘排放 soot emissions<br>矿物燃料（煤、石油、天然气） fossil fuels（coal, oil and natural gas）</p><h3 id="教育文化类"><a href="#教育文化类" class="headerlink" title="教育文化类"></a>教育文化类</h3><h4 id="学位"><a href="#学位" class="headerlink" title="学位"></a>学位</h4><p>学士 bachelor’s degree<br>硕士 master’s degree<br>博士 doctor’s degree<br>获得学位 acquire degree<br>文科 arts<br>理科 science<br>文学硕士 Master of Arts（MA）<br>理学硕士 Master of Science（MS）<br>工商管理硕士 Master of Business Administration（MBA）<br>公共管理硕士 Master of Public Administration（MPA）<br>工程硕士 Master of Engineering（ME）<br>会计硕士 Master of Professional Accounting（MPAcc）<br>金融硕士 Master of Science in Finance（MSF）</p><h4 id="学校"><a href="#学校" class="headerlink" title="学校"></a>学校</h4><p>幼儿园 nursery/kindergarten<br>小学 primary/elementary school<br>中学 middle school<br>综合性大学 university<br>学院 institute<br>高等教育 higher education<br>大学生 college/university students<br>大学毕业生 college/university graduates<br>商学院 business school<br>法学院 law school<br>研究生院 graduate school<br>教授 professor<br>全体教师 faculty<br>系 department<br>major 专业<br>教学设施 teaching facilities<br>食堂 dining hall<br>宿舍 dormitory<br>选修课 elective/optional course<br>学杂费 tuition fees and other expenses</p><h4 id="教育"><a href="#教育" class="headerlink" title="教育"></a>教育</h4><p>终身教育 life-long education<br>素质教育 education for all-round development<br>义务教育 compulsory education<br>应试教育 exam-oriented education<br>成人教育 adult education<br>理论知识 theoretical knowledge<br>实践技能 practical skills<br>信息时代 information era<br>知识爆炸时代 era of knowledge explosion<br>影响学习成绩 affect school achievements<br>逃课 skip classes<br>学习成绩 academic performance<br>学习氛围 academic atmosphere<br>开阔眼界 broaden one’s horizon<br>激发兴趣 stimulate one’s interest<br>开发潜能 tap one’s potential<br>（学生）减负 reduce study load<br>文理分科 separation between liberal arts and science<br>放松的大学生活 relaxing college life</p><h4 id="招生就业"><a href="#招生就业" class="headerlink" title="招生就业"></a>招生就业</h4><p>招生 recruitment<br>录取 enrollment<br>申请入学 apply for admission to/into…<br>高考 College Entrance Examination<br>考研 National Entrance Test for MA/MS Candidates<br>就业市场 job market<br>雇主 employer<br>雇员 employee<br>职业培训 vocational training</p><h4 id="文化"><a href="#文化" class="headerlink" title="文化"></a>文化</h4><p>文化交流<br>文化交流 cultural exchange<br>文化融合 cultural blending/integration<br>传统中国文化 traditional Chinese culture<br>儒家 Confucianism<br>佛家 Buddhism<br>道家 Daoism/Taoism<br>京剧 Peking Opera<br>中国书法 Chinese calligraphy<br>西方文化 western cultures<br>启蒙运动 Enlightenment<br>人本主义 humanism<br>后现代主义 post-modernism<br>多元文化 multi-cultures, pluralistic/mosaic cultures<br>文化多元化 cultural diversity<br>保存珍惜 preserve and cherish<br>取其精华，去其糟粕 absorb its essence and resist its dark side<br>积极促进文化发展 promote cultural development positively<br>辉煌灿烂的文化遗产 splendid and glorious cultural heritage/legacy/relics<br>与时俱进 keep pace with times<br>跨文化交流 cross-cultural communication<br>文化差异 cultural differences<br>文化传统 cultural traditions<br>人类文明 human civilization<br>精神文明 spiritual civilization<br>主流文化 mainstream culture<br>解读经典 interpretation of classics</p><h4 id="流行文化"><a href="#流行文化" class="headerlink" title="流行文化"></a>流行文化</h4><p>流行文化 popular culture<br>电视广告泛滥 the pervasive advertisement on TV<br>偶像崇拜 idol worship<br>上网成瘾 web/Internet addiction<br>虚拟生活 virtual life<br>网上交流 making friends online<br>网聊 chatting on the Internet<br>网络谣言 online gossip<br>网上购物 online shopping<br>网络监管 the Internet supervision<br>网络暴力 the Internet violence<br>不负责的言论 irresponsible remarks<br>购买彩票 buy lottery tickets<br>网络游戏 online games<br>数码产品 digital products<br>手机短信 text message<br>垃圾短信 junk message<br>手机入网 mobile phone subscription</p><h3 id="人生哲理类"><a href="#人生哲理类" class="headerlink" title="人生哲理类"></a>人生哲理类</h3><h4 id="独立"><a href="#独立" class="headerlink" title="独立"></a>独立</h4><p>自立 self-dependence<br>溺爱 dote, spoil<br>独生子女 only child<br>激烈竞争 fierce competition<br>啃老族 boomerang kids, NEET(Not currently engaged in Education, Employment or Training)<br>不劳而获 reap without sowing</p><h4 id="坚持"><a href="#坚持" class="headerlink" title="坚持"></a>坚持</h4><p>不断努力 make constant efforts<br>决不放弃 never give up<br>决不停止进步 never stop making progress<br>获得成功 achieve success<br>创新 innovation<br>勤奋 diligence<br>奋斗精神 striving spirit<br>人生观 outlook of life<br>世界观 world outlook<br>恒心 perseverance<br>耐心 patience</p><h4 id="信心"><a href="#信心" class="headerlink" title="信心"></a>信心</h4><p>自信 self-confidence<br>谦虚 modesty<br>缺乏自信 lack of confidence<br>高估困难 exaggerate/overestimate difficulties<br>低估能力 underestimate one’s abilities</p><h4 id="合作"><a href="#合作" class="headerlink" title="合作"></a>合作</h4><p>团队合作 teamwork<br>团队精神 team spirit<br>与他人合作 cooperate with others<br>齐心协力/众志成城 joint/cooperative efforts<br>互相帮助 help each other</p><h4 id="乐观"><a href="#乐观" class="headerlink" title="乐观"></a>乐观</h4><p>保持乐观 keep optimistic<br>悲观 pessimism<br>悲观的 pessimistic<br>积极态度 positive attitude<br>仁慈 benevolence</p><h3 id="社会热点类"><a href="#社会热点类" class="headerlink" title="社会热点类"></a>社会热点类</h3><h4 id="健康"><a href="#健康" class="headerlink" title="健康"></a>健康</h4><p>生理健康 physical health<br>心理健康 mental/psychological health/fitness<br>健康问题 health concern<br>亚健康 sub-health<br>公共卫生 public health<br>心态 state of mind<br>体育锻炼 physical exercises<br>均衡饮食 well-balance diet<br>垃圾食品 junk food<br>减肥/节食 go on a diet<br>提供医疗服务 provide medical services<br>牺牲健康 sacrifice health<br>短期经济利益 short-term economic benefits<br>全面禁烟 total tobacco ban<br>疾病 illness/disease<br>慢性病 chronic disease<br>传染病 infectious disease<br>癌症 cancer<br>医疗体制改革 reform of medical system</p><h4 id="两代关系"><a href="#两代关系" class="headerlink" title="两代关系"></a>两代关系</h4><p>代沟 generation gap<br>弥合差距 bridge the gap<br>相互理解 mutual understanding<br>误解 misunderstanding<br>照顾 care, take care of, look after<br>虐待 mistreat, maltreat, ill-treat<br>老龄化社会 aging society<br>人口老龄化 population aging<br>老年人 old/aged people, the old/aged/elders/elderly, senior citizens<br>奉行孝道 practice filial piety</p><h4 id="社会公德"><a href="#社会公德" class="headerlink" title="社会公德"></a>社会公德</h4><p>公德 public morality<br>传统美德 traditional virtues<br>责任 duty/responsibility<br>责任感 sense of responsibility<br>承担责任 shoulder/assume/undertake one’s duties/responsibilities<br>逃避责任 avoid/shirk/shun one’s duties/responsibilities<br>奉献 devote/dedicate; devotion/dedication<br>无私奉献 selfless devotion<br>信任危机 the crisis of trust<br>公德堕落 the corruption of public morality<br>道德缺失 the lack of moral sense<br>不道德行为 immoral behaviors<br>希望工程 Project Hope<br>中国红十字会 China Red Cross Foundation<br>慈善 charity<br>捐款 donate/donation<br>贫困乡村地区 poor rural areas<br>入学 start schooling<br>辍学 drop out of school<br>完成学业 finish school<br>尊老爱幼 to respect the old and care for the young<br>随地吐痰 spit everywhere<br>大声喧哗 make noise, talk loudly</p><h4 id="职业道德"><a href="#职业道德" class="headerlink" title="职业道德"></a>职业道德</h4><p>空洞承诺 empty promise<br>虚假承诺 false promise<br>伪劣产品 fake commodities<br>欺诈行为 dishonest behaviors<br>诚信 honesty<br>学术腐败 academic corruption<br>剽窃抄袭 plagiarism<br>食品安全 food safety<br>工程质量 construction quality<br>地沟油 drainage oil<br>毒奶粉 poisonous milk powder<br>食品添加剂 food additives<br>过度上涨 excessive growth<br>非法广告 illegal ads<br>不公平竞争 unfair competitions<br>争抢利益 compete for benefits<br>治标不治本 address symptoms but not root causes<br>管理部门 administration department<br>监管部门 supervision department<br>商家 merchant<br>厂家 manufacturer<br>企业经营者 enterprise operator<br>有关当局 authorities concerned<br>收受贿赂 take bribes<br>漠视法律 disregard of laws<br>推卸责任 shift the blame onto…<br>消费者权益 consumers’ rights and interests<br>伪专家 unqualified experts<br>公正有效地履行职责 perform one’s tasks fairly and effectively<br>提供礼貌热情的服务 provide polite and hospitable services<br>腐败现象 corruption phenomenon</p><h4 id="交通"><a href="#交通" class="headerlink" title="交通"></a>交通</h4><p>公交专用车道 bus lane<br>（机动车）单双号限行 odd-and-even license plate rule<br>早晚高峰 morning and evening peak<br>交通拥堵 traffic jam/congestion, heavy traffic<br>交通高峰期 rush hour<br>公共交通线路网 public transport network<br>尾号限行 traffic restrictions based on the last digit of license plate numbers<br>交通管制 traffic control<br>无车日 car-free day<br>交通事故 traffic accidents<br>私家车 private cars<br>发展公共交通 develop public transport<br>醉驾 drunk drive<br>酒后驾车 drive under the influence of alcohol<br>司机 driver<br>行人 pedestrian</p><h4 id="经济管理"><a href="#经济管理" class="headerlink" title="经济管理"></a>经济管理</h4><p>经济危机 economic crisis, financial crisis, financial turmoil, financial meltdown<br>经济不景气 recession, bleeding economy, depression, sluggish economy<br>失业 lose one’s job, be unemployed, be redundant<br>失业加剧 job losses mount, unemployment climb<br>失业人数 unemployment<br>找工作 seek employment<br>找工作者 job seeker<br>严峻的就业形势 a tough job market<br>信心下滑 confidence slump<br>经济复苏 economic recovery<br>经济危机的影响 the crisis’ fallout<br>应对危机 face the crisis, meet the crisis, fight crisis<br>重建信心 confidence reconstruction<br>遏制衰退 contain declines<br>减缓衰退 slow down declines<br>安居工程 affordable/comfortable housing project<br>成本削减 cost-cutting<br>创造新的就业 generate new employment<br>刺激消费 stimulate consumer spending<br>恢复 revive, recovery, turnaround<br>积极的财政政策 proactive fiscal policy<br>减少裁员 refrain from laying off employees<br>减员 cut the salaried work force<br>结构调整 structural adjustment<br>经济刺激方案 stimulus package, stimulus plan<br>就业指导 career guidance<br>扩大内需 propel/drive/expand domestic demand<br>基础设施建设 infrastructure construction<br>减免税收 tax relief<br>实行节约 practice economy<br>适度宽松的货币政策 moderately loose monetary policy<br>政府紧急援助 government bailout<br>政府做某事的决心 government’s vow to do sth<br>市场经济体制 the market economy system<br>经济全球化 economic globalization<br>国际经济组织 international economic organization<br>科技进步 advancements in science and technology<br>跨国公司 multinationals<br>私营企业 private enterprise<br>汽车产业 automobile industry<br>房地产业 real estate industry<br>电信产业 telecommunication industry<br>国产品牌 domestic/national/Chinese brand<br>市场份额 market share/portion<br>公司 company/corporation<br>企业 enterprise<br>员工 staff/personnel<br>工作满意度 job satisfaction<br>工作压力 work/working pressure<br>提高福利待遇 improve welfare and treatment<br>吸引外资 attract foreign investment<br>法律保护 legal protection<br>深远的社会影响 profound social and economic impact<br>改革开放 the reform and opening-up<br>社会保障体系 social security system<br>失业 unemployment<br>住房问题 housing problem<br>公用基础设施 public infrastructure<br>摩天大楼 Skyscraper<br>可持续的城市发展 sustainable urban development<br>城市化 urbanization<br>城市人口 urban population<br>乡村人口 rural population</p>]]></content>
      
      
      <categories>
          
          <category> 考研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考研 </tag>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>真题词汇</title>
      <link href="/SYSU/%E8%8B%B1%E8%AF%AD%E7%9C%9F%E9%A2%98%E8%AF%8D%E6%B1%87/"/>
      <url>/SYSU/%E8%8B%B1%E8%AF%AD%E7%9C%9F%E9%A2%98%E8%AF%8D%E6%B1%87/</url>
      
        <content type="html"><![CDATA[<h2 id="真题词汇"><a href="#真题词汇" class="headerlink" title="真题词汇"></a>真题词汇</h2><a id="more"></a> <h3 id="2010真题"><a href="#2010真题" class="headerlink" title="2010真题"></a>2010真题</h3><p>swine flu 猪流感<br>epidemic 传染病，流行病<br>heightened 提高的，增加的<br>alert 警惕，警戒<br>assemble 召集，召开（会议）<br>severity 严重程度<br>in progress 在进行中<br>hospitalization 长期住院，住院治疗<br>crop up 突然出现，突然发生<br>virtually 几乎，事实上<br>stockpile 库存，积蓄<br>vaccine 疫苗<br>dose （药物的） 剂量，一剂<br>relay 转送，转发（信息，消息等）<br>place order 订购，下订单<br>take order 接受订单<br>deliver order 交付订货<br>give order 下订单，订购<br>prevalent 流行的，普遍的<br>agony 极大的痛苦，痛楚<br>ward 监护，守护；挡住，架住；避开；收容<br>ward off 避开，挡住<br>auctioneer 拍卖师，拍卖商<br>bid 出价，投标<br>bull run 牛市态势<br>file for 申请，提交<br>momentum 势头<br>bewilderingly 令人费解地<br>reckon 认为<br>rise bewilderingly 急剧增长<br>enormous egos 膨胀的自我<br>unfashionable 不合时宜的，过时的<br>auction house 拍卖行<br>downturn （经济活动、生产等）下降、衰退<br>fluctuant 波动的<br>slump （价格、数值等）暴跌、不景气、萧条<br>address 发表演说、向…讲话<br>suburban 郊区的<br>crystallize 使明确化、使具体化<br>irony 具有讽刺意味的情况<br>wreak （对某物）造成破坏，造成混乱<br>havoc 灾难，混乱<br>wreak havoc with 给…带来浩劫<br>virtual 实际上的，事实上的<br>tangible 确凿的、实在的，有形的（资产）<br>stereotypical 典型的，带有成见的<br>cue 提示、暗示<br>hygiene 卫生（学）<br>subtle 微妙的<br>disinfecting 消毒的<br>shrewd 精明的<br>adolescent 青春期的<br>ritual 仪式，例行公事<br>slip A in between B and C 将A悄悄放在B和C之间<br>viable 可行的<br>ruthless 无情的、残忍的<br>tactic 策略；战术，战略<br>jury 陪审团<br>qualification 限定性条件，资格，授权<br>entitled 有资格的<br>verdict 裁定，裁决<br>intentional 有意的<br>elite 精英，掌权人物<br>blue-ribbon 一流的、头等的<br>eligible 有资格的，合适的，合格的<br>exempt 免除、豁免<br>unconstitutional 违反宪法的，不符合章程<br>trumpet 大声宣告、大肆宣扬<br>substantially 实质上、大体上<br>intimate 亲近的<br>aviation 航空<br>sustainability 忍受力，持续性<br>sign on with 与…签约<br>translate 导致、造成<br>reciprocate 报答，回报<br>stagnant 停滞的</p><h3 id="2011真题"><a href="#2011真题" class="headerlink" title="2011真题"></a>2011真题</h3><p>sweep across 席卷，横扫<br>lawless 不守法的，不受法律控制的，无法无天的<br>credential 证书，凭据<br>issue （组织或某官员）发给，分发<br>issue a passport/permit/visa 分发护照、许可证、签证<br>carry on sth 继续进行，继续从事某事<br>linger on 逗留，继续存留<br>in effect 实际上，事实上<br>thriving 繁荣的，昌盛的<br>delight 高兴，愉快<br>initiative 倡议，新方案；主动性；自发的，创始的，初步的<br>mentality 心态，思想状况<br>envision 展望，想象<br>indifference 冷漠，冷淡<br>under fire 受到攻击和批评<br>bonus payouts 奖金支出<br>outside director 外部董事<br>presumably 据推测，大概，可能，想来<br>weather 平安渡过（难关），挨过，经受住<br>a firm’s board 公司董事会<br>make one’s wealth and reputation 功成名就<br>subsequently 其后，随后，接着<br>restate 重申，重新申报，再次声明<br>proxy statement 股东委托书<br>restate earnings 重申盈利<br>federal class-action lawsuit 联邦集体诉讼<br>incentive 动机，鼓励，刺激；刺激性的，鼓励性质的<br>a blow to reputations 有损名誉<br>chronicle 将（某事物）载入编年史<br>subsidize 以津贴补助，以金钱收买<br>flee to the Internet 转向互联网<br>shrug off 对…满不在乎，不屑一顾<br>afloat 漂流者的，飘浮不定的<br>stay afloat 维持运营<br>push sb/sth overboard 抛弃、甩掉某人/某事<br>have the nerve 好意思做某事，有胆量做某事<br>desperate measures 孤注一掷的措施<br>whirlwind 旋风；猛烈的势力；破坏性的力量或事物<br>distinctive 有特色的，与众不同的，区别的<br>bureau （美国政府部门）局，处，科；（提供某方面信息的）办事处<br>savagely 野蛮地；残忍地；粗野地<br>line up 排队<br>marriage bureau 婚姻登记处<br>take up posts 就职<br>derive from 由…起源，取自<br>sophisticated 复杂的，精致的<br>signature phrase 口头禅<br>mask the fact 掩盖事实<br>commission 委任，授予；委员会<br>aesthetic 美学的，审美的<br>forthright 直率的，直截了当的，（观点）明确的<br>cheerleader 啦啦队队长，（强有力的）支持者<br>chronic 慢性的，长期的，习惯性的<br>devaluation （货币）贬值<br>disintegration 瓦解，奔溃<br>stuck 动不了的，被卡住的，被难住的<br>sanction 制裁，处罚<br>suspension 暂停，悬挂<br>rigour 严苛，严酷<br>backed by 依靠，在…支持下<br>a small majority 微弱多数<br>intervene 介于…之间，干预，介入<br>fiscal 财政上的<br>murmur 发牢骚，私下抱怨<br>intervene in 介入，干预<br>blunt 使迟钝<br>benign 温和的，仁慈的，善良的<br>write off 毁掉，结束掉，认定…不重要（或无用、不可救药），忽视<br>halt 使停止，使中断，阻止<br>inconceivable 不能想象的，不可思议的，难以置信的<br>bold 勇敢的，无畏的，莽撞的<br>inducement 诱导，诱惑，诱因<br>lure 吸引，引诱<br>takeaway 外卖食品，外卖店<br>radical 激进的，彻底的<br>back 支持<br>take a toll on 造成损失（或危害，伤亡）</p><h3 id="2012真题"><a href="#2012真题" class="headerlink" title="2012真题"></a>2012真题</h3><p>mindless 愚笨的，盲目的，无谓的<br>tear…away from sth 使依依不舍地离开，忍痛离去<br>brutal 残忍的，野蛮的<br>rebel 反叛，反抗<br>bear 承受，忍受（负担）<br>commodity 商品<br>article 物件，物品<br>turn over 移交，交托；仔细考虑<br>pass down 继承，遗传<br>personality 性格，个性<br>portray 描绘，扮演（某角色）<br>colony 殖民地，群体<br>patrol 巡逻，巡查<br>commute 上下班往返，经常往返（于两地）<br>parallel 与…相似，与…并行<br>counteract 抵消，中和<br>from the outset 从开始时<br>scorn 蔑视，鄙视<br>revise 改变，修正<br>ritual 惯例，老规矩，例行公事，仪式<br>impoverish 贫困的<br>chaotic 混乱的<br>implication 含义，暗示<br>on one’s own 独立做某事<br>flat 固定的<br>across-the-board 一刀切的<br>thorny 棘手的<br>put on hold 搁置，暂缓实施<br>pervasive 普遍的，无处不在的<br>intrinsically 从本质上（讲）<br>fuse 使熔合<br>be obsessed with 痴迷于…<br>be pervasive in 充斥于…<br>nursery 育儿室，托儿所<br>pastel （色彩）淡的，柔和的<br>toddler 幼童<br>counsel 建议<br>agitated 紧张不安的，焦虑的<br>preliminary 初步的，预备的<br>overturn 使倾覆，打翻<br>monopoly 垄断者，垄断企业<br>file 提出，提交，发表<br>file a brief 提交案情提要<br>the Supreme Court 最高法院<br>file a patent for 就…提交专利申请<br>convention 会议，惯例，习俗<br>coach sb on sth 对某人就某事进行培训<br>prudent 明智谨慎的，节俭的，精明的<br>reckless 轻率的，鲁莽的，不顾后果的<br>find silver linings 寻找一线希望<br>stagnation 经济停滞、不景气<br>reinforce 加强，强化<br>resentment 怨气，怨恨，不满<br>discern 识别，看清，领域<br>lean 不景气的，贫瘠的，精干的<br>poll 民意调查，民意测验<br>trivial 无关紧要的，平凡的<br>craze 时尚，时髦，热潮<br>exemplary 模范的，可做楷模的<br>cunning 狡猾，狡诈<br>ruthlessness 无情，冷酷<br>commemorate 庆祝，纪念<br>resolute 坚决的，坚定的<br>steadfast 忠诚的，坚贞不渝的<br>epochal 具有时代意义的<br>immense 巨大的<br>wage 发动，进行（战争，战斗）<br>multiplicity 多样性<br>downstairs 底层阶级<br>upstairs 上层阶级<br>brain drain 人才流失<br>deprive 剥夺<br>follow the warranty policy 履行保修协议</p><h3 id="2013真题"><a href="#2013真题" class="headerlink" title="2013真题"></a>2013真题</h3><p>(just) around the corner 很近，就在附近<br>come to fruition 完成，实现<br>around 出现，有<br>reverse 承认错误，放弃（立场），反转<br>resume 重新开始，继续<br>eliminate 消除，清除<br>pass down 遗传，沿袭<br>withdraw 提，取（银行账户中的款项）<br>fraud 欺骗，诈骗<br>alter 修改，改变<br>manipulation 操纵，控制<br>trail 踪迹，痕迹<br>average is over 告别平庸<br>textile 纺织品<br>textile mill 纺织厂<br>stubbornly 顽固地；倔强地<br>stand out 突出，脱颖而出<br>shed 去除，摆脱<br>shed workers 裁员<br>above average 超越平庸，高于平均水平<br>sojourner 旅居者；逗留者<br>for good 永远地；一劳永逸地<br>affectionate 深情的；充满深情的<br>birds of passage 候鸟，漂泊的人<br>along with A come B 做某事的既有A，又有B<br>rigid 严格的；僵硬的，死板的<br>mightily 很，非常<br>thrive 兴旺发达，繁荣，蓬勃发展<br>straddle 跨立于；跨越<br>jurisdiction 管辖范围<br>in motion 在运动中的<br>middle ground 中间立场，中间地带<br>prone 有…倾向的；易于；倾向于<br>snap 仓促的，匆忙的<br>hard-wired 直觉的，天生的，本能的<br>be prone to 易于…，有…的倾向<br>snap decision 快速决策，仓促决定<br>important defense mechanism 重要防御机制<br>be hard-wired to do sth. 天生会做某事<br>exclusive 独有的，专有的，独占的<br>realm 领域，范围<br>prime 使准备好<br>be exclusive to 专为…所独享<br>prime sb to do sth 使某人准备好应付某种情况<br>screener 筛选者<br>real estate agent 房产中介<br>retreat 僻静处，隐居处，休息寓所<br>mute 减弱…的声音；引申为控制，抑制<br>intermittently 间歇地，断断续续地<br>contemplate 沉思，思忖<br>temptation 引诱，诱惑物<br>board 董事会，委员会，理事会<br>corporate boards 董事会<br>compel 强迫，迫使<br>mandate 授权，命令，指令<br>frustration 挫折，挫败<br>quota 定量，定额，指标<br>ladder 阶梯，途径，梯状物<br>binding 有约束力的<br>legally binding provisions 具有法律约束力的条款<br>run counter to 违反，与…背道而驰，逆向的，相反的<br>meritocracy 英才教育；精英管理班子<br>fancy 喜爱，想要<br>anonymity 匿名，不知名<br>come in handy 派得上用场<br>surplus 剩余的，过剩的<br>frugal 节俭的，朴素的，花钱少的<br>overwhelmed 受宠若惊的，不知所措的，压倒<br>charity sale 义卖<br>for the sake of 为了<br>on the verge of …的边缘<br>be desirous of 希望<br>desired 喜欢的，心仪的<br>in financially strained families 家境贫寒的<br>erosion of study time 侵蚀学习时间</p><h3 id="2014真题"><a href="#2014真题" class="headerlink" title="2014真题"></a>2014真题</h3><p>moderately 适度地，不过分地<br>collegiate 学院的，学院学生的<br>conversely 相反地，以相反的方法<br>in terms of 依据，按照<br>in respects of 关于，在…方面<br>in essence 本质上，实质上<br>in turn 转而，相应地<br>qualify 可被认为是，可算作是<br>disgrace 耻辱，丢脸的事；出丑<br>stereotype 陈词滥调，刻板印象，陈规旧习<br>harbor 心怀，怀有<br>institute 建立，制定<br>initiative 新倡议、行动、方案；自发的；初步的<br>despise 轻视，鄙视<br>ground in/on sth. 以…为根据<br>widow 寡妇<br>lottery 彩票<br>jackpot 头奖，最高奖<br>could do worse than 不妨试试…<br>counterintuitive 违反直觉的<br>wear off 逐渐消逝，减少，磨损<br>creep in 悄然而至<br>be packed with 挤满；塞满<br>bang for your buck 所做的努力值得；钱花得合算<br>sparingly 保守地，节俭地；慎用地；爱惜地<br>be better off 过得更好<br>an object of obsession 令人痴迷之物<br>scarcity 不足，缺乏<br>mandate 批准；授权<br>incentive 激励<br>empirical 以实验（经验）为依据的<br>deep-seated 深层的，根深蒂固的<br>amass 聚集（尤值大量）<br>illusory 错觉的，虚假的<br>oceans of 海量的，极大量的<br>rose-tint 染了玫瑰色，精饰、美化<br>esteem 尊重，尊敬<br>stalk 高视阔步地走<br>hot stuff 奇才；非凡的人物<br>stalk around 趾高气扬地大踏步行走<br>oversee 监督；监管<br>lineup 阵容，一组<br>deliberation 考虑；深思熟虑<br>flattering 使人显得更漂亮的；讨好的，谄媚的<br>doctor 篡改，伪造，修改<br>profound 深刻的，极大的，严重的，意义深远的<br>delusion 错觉；谬见；妄想<br>viscerally 发自肺腑地<br>wit 才思，才智<br>portray 描绘<br>instinctively 本能地<br>boom and bust 繁荣与萧条<br>outmoded 使过时；使不流行<br>insatiable 贪得无厌的，不知足的<br>hail from 来自<br>reinvent 彻底改造<br>innovate 改变；改革；创新；引入新事物<br>institution 制度，风俗习惯<br>shove 挤；撞；猛推<br>cap （可用或可借资金的）最高限额<br>be down to sb. 是某人的责任；由某人负责<br>expire 期满，终止，失效<br>coalition 联合；联盟<br>pressing 迫切的，紧急的<br>typify 代表；作为…的典型<br>sole 唯一的，单独的，仅有的<br>embodiment 体现，具体化<br>obscure 费解的，难以理解的<br>comprise 包含，包括<br>unwittingly 不知不觉地，不知情<br>assault 攻击，袭击<br>gravitate 被吸引到，受吸引<br>permeate 渗透，弥漫<br>perpetually 永恒地，持久地<br>gorgeous 极好的<br>humble 简单的，粗陋的</p><h3 id="2015真题"><a href="#2015真题" class="headerlink" title="2015真题"></a>2015真题</h3><p>virtually 几乎，实际上，实质上，事实上<br>beat into 强迫某人做某事<br>plug into 深陷于，沉浸于<br>weird 怪异的，不可思议的，奇怪的<br>perceive 察觉，认识到<br>unconventional 非传统的<br>rip off 扯掉，撕掉<br>band-aid 创可贴，绷带<br>tuck 把…塞入<br>commuter 通勤者，（远距离） 上下班往返的人<br>do away with 废除，去掉<br>a place of refuge 避难所<br>nonparents 无子女者<br>conventional wisdom 传统观点，普遍看法<br>hold true for 适用于，对…有效<br>home front 家庭后方；战时后方<br>lag behind 落后，拖欠<br>life-sustaining 维持生命的<br>draw out 取得<br>division 分配<br>clinically 不偏不倚地，客观地<br>methodically 系统地，有条不紊地，有条理地<br>lag 落后于<br>dropout 退学，辍学<br>paradox 自相矛盾的情形，悖论<br>forthcoming 即将到来的<br>outline 概述，勾勒<br>next-to-no-cost 接近零成本的<br>recipients 接受者<br>grant 助学金，拨款<br>thesis 论点，论题<br>modest 较小的<br>intervention 干预<br>navigate 理解，应对<br>right-brained 右脑的，感性的<br>parachute 空降，空投<br>infuse 把…注入；灌溉<br>allegiance 忠诚，拥护<br>terminology 学科术语，专门用语<br>amid 在…中间，在…当中<br>buzzword 某一领域内的时髦用语<br>linguist 语言学家<br>nonsense 无稽之谈，胡说，荒谬的想法<br>buy into it 买账，认可<br>outside of employment 失业，非就业<br>grieve 为…而悲伤，为…感到伤心<br>inopportune 不合时宜的<br>mindset 心态，思想倾向<br>weigh down 使负重担，保持留心<br>perceive 发觉，感知，意识到<br>know…like the back of one’s hand 对…十分熟悉，了如指掌<br>twist and turn 迂回曲折</p><h3 id="2016真题"><a href="#2016真题" class="headerlink" title="2016真题"></a>2016真题</h3><p>inclination 意向，倾向<br>Gallup polling 盖洛普民意测验<br>publicly traded firms 公开交易的公司，上市公司<br>sure enough 果然，果真如此<br>intensity 强度，力度<br>be headquartered 总部设在某地<br>hold （熟词僻义）继续适用，继续有效<br>echo 声音回响、回应或反映<br>invented 虚构、创造<br>headquartered 总部设立于<br>resume 中断之后继续或重新开始<br>codified 刻板的、固守成规的、循规蹈矩的<br>sentiment 情感、情绪<br>attribute to 把…归因于…<br>take a long-term view 采取更加长远的眼光、把眼光放长远<br>plausible 有道理的、可信的<br>forward-thinking 前瞻的、有远见的<br>hint at 暗示、暗指<br>lean towards 倾向于，向…倾斜<br>catch up 赶上，追上<br>assistant dean （学院）副院长<br>jobs gap 职位空缺<br>pack 塞满，挤满<br>brim 口，边沿<br>drive…away 赶跑，使离去<br>bootcamp 训练营<br>curriculum 课程<br>gear 使与…相适应，使适合于<br>drop out of 退学，辍学<br>turnover 倾覆，翻转<br>coax 劝诱<br>lend sth. to sth. 给…增加，增添（某种特色或特性）<br>crash 暴跌，猛跌<br>desperate 危急的，严峻的<br>designate 指定，认定<br>confrontational 对抗性的，挑起冲突的<br>regulatory power 监管权力<br>crack down on 严厉打击，镇压<br>prosecute 起诉，控告，检举<br>unintentionally 无意地，非故意地<br>interim 临时的，暂时的，过渡期间的<br>in the driver’s seat 处于控制地位，主导地位<br>mournfully 悲哀地，凄惨地<br>thorny 棘手的<br>flywheel 飞轮，惯性轮<br>spin 旋转，转动<br>overwhelmingly 势不可挡地，压倒地<br>instrumentally 起作用地，有帮助地<br>immersive 沉浸式的<br>conveyor belt 传送带<br>mind-set 思想倾向<br>slot in 安置，安排<br>fuel 刺激，使加剧<br>ritualistic 仪式的，例行的<br>distraction 使人分心的事物<br>backdrop 背景<br>poll 民意调查，民意测验<br>draw a road map to success 绘制一幅成功路线图<br>prize 珍视，高度重视<br>strikingly 惹人注目地，醒目地<br>prioritize 按优先顺序列出；优先考虑<br>financially secure 经济有保障<br>aftermath （战争、风暴、事故的）后果，余波<br>searing 炽热的，灼热的；灼痛的，剧痛的<br>virtually 实际上，几乎，事实上<br>spread through 蔓延到<br>overwhelming 巨大的，压倒性的<br>signpost 路标，标志物<br>mortage 抵押贷款，按揭<br>therapy 治疗，疗法<br>suppress 抑制（感情）<br>brush/sweep sth. under the carpet 掩盖某事（尤指错事）<br>silver bullet 解决某一难题的良方，高招<br>indulge 沉溺于，沉湎于，纵情于<br>giggle 傻笑<br>infection 传染病<br>mortgage 按揭<br>spree 作乐，狂欢（尤指花钱或喝酒）<br>side effect 副作用<br>backfire 发生意外，产生事与愿违的结果<br>byproduct 意外收获，额外收获；附带的结果<br>lure 引诱，诱使<br>sheer 十足的，彻底的，纯粹的<br>hone 打磨，锤炼，使精通<br>read extensively 广泛阅读，博览群书<br>a broad knowledge base 广泛的知识基础<br>keep abreast of 了解…的最新情况<br>sustained efforts 长期不懈的努力<br>illuminating 有启发性的<br>unwind 使松弛，放松<br>recharge 放松休息，恢复精力<br>antidote 克服…的良方<br>revitalized 焕发生机的<br>relieve pressure 舒缓压力<br>come into contact with 接触到，遇到<br>have one’s share of 有自己的一份儿…<br>attach meaning to 对…赋予意义</p><h3 id="2017真题"><a href="#2017真题" class="headerlink" title="2017真题"></a>2017真题</h3><p>boast 吹嘘，自吹自擂<br>speculate 推测，思索，投机<br>capital 资本<br>impoverished 穷困的<br>wasteland 荒地，不毛之地<br>resolution 解决，决心<br>wisdom 智慧<br>compensation 补偿<br>alongside 和…在一起<br>leave behind 留下；永久脱离<br>set aside 不顾；驳回；撤销<br>mutually exclusive 互相排斥<br>purposelessness 无目的<br>mortality 死亡人数<br>agonizing 痛苦难忍的<br>dullness 沉闷，无聊<br>downsides 不利的一面，缺点<br>yield 屈服；产生；放弃<br>virtue 优点，长处，美德<br>follow from 是…的必然结果<br>overblown 夸张，过分渲染<br>degrading 丧失体面的，丢脸的<br>tricky 难对付的；狡猾的<br>scarce 不足的，稀少的<br>leisure time 空闲时间<br>counterbalance 使平衡，抵消<br>staff 为…配备工作人员，在…工作<br>pledge 发誓，保证<br>legacy 遗产<br>lever 用杠杆撬动<br>couch 沙发<br>retrospection 回想，反思<br>in the run-up to sth. 重要事件的前夕<br>ethos 精神特质，理念<br>shine 干得出色，出类拔萃<br>bidder 投标人<br>intimidating 令人胆怯的<br>puffed-out 气喘吁吁的，上气不接下气的<br>preside 主持，指挥，掌管<br>thrive 兴隆，繁荣，茁壮成长<br>grassroots 草根，基层民众<br>wordy 冗长的，啰嗦的<br>engagement 参与度<br>disengage 脱离，不再感兴趣<br>bleed-over 渗透<br>tablet 平板电脑<br>verbal 文字的，言语的<br>tension 紧张关系，紧张状况<br>bid 努力争取，出价，投标<br>blank 没表情的，不感兴趣的<br>disconcerting 使人不安的<br>distressed 痛苦的，悲伤的，苦恼的<br>exquisitely 精致地，近乎完美地<br>be wired to do 天生，自然就会<br>ideology 意识形态<br>oppressive 压制的，令人焦虑的<br>get a lot out of sth. 从…中获益良多<br>get sth. out of the way 把某事处理完<br>overlook 忽略，未注意到<br>condemn 谴责<br>perpetuate 使永久化，使持续<br>lucrative 赚大钱的，获利多的<br>misconception 错误认识，误解<br>pursuit 事业，消遣，爱好<br>brand new 全新的，崭新的<br>acclimation 适应<br>blunder 愚蠢（或粗心的）错误<br>inherent 固有的，内在的<br>mandatory 强制的，法定的，义务的<br>curriculum 全部课程<br>upkeep 保养，维修<br>prone 易于发生某事的；很可能…的<br>magnifying glass 放大镜<br>hazard 危险，隐患<br>equation 影响因素，综合体<br>at the expense of 以…为代价<br>perception 认识，观念，看法<br>unleash 发泄，突然释放，使爆发<br>out of necessity 出于必要<br>tease 梳理；挑逗，取笑<br>do away with 终结，废除，去掉，消灭<br>come to terms with 与之妥协<br>pay a price for 付出代价<br>refrain 老调，一再重复的话<br>take a hit 遭到打击，被击中<br>outsourcing 外包<br>boomer 婴儿潮一代（尤指1947-1961年间）生育高峰期出生的人<br>millennial 千禧一代，20世纪的最后一个世代<br>grapple with 尽力解决（某困难问题）<br>stiff 激烈的，严厉的<br>get exposed to 接触，体验<br>flustered 紧张的，慌乱的，激动的<br>recession （经济）衰退，萧条<br>clear a hurdle 成功克服困难<br>economic downturn 经济衰退<br>be laid off 被辞退<br>trade 行业，职业<br>lure 吸引，引诱<br>sewing 缝纫<br>personality 有突出个性的人<br>promotion 推广<br>secondary school 中学<br>move on to sth./doing sth. 继续某事，接着做某事<br>fashion design 时装设计<br>Chinese martial arts 中国武术<br>annual growth 年度增长<br>line chart 折线图<br>cultural infrastructure/facilities 文化基础设施<br>public cultural undertaking 公共文化事业<br>underpin 构成…的基础<br>people’s well-being 人民福祉</p><h3 id="2018真题"><a href="#2018真题" class="headerlink" title="2018真题"></a>2018真题</h3><p>resolve 消除，解释清楚；解决<br>inherent 内在的，固有的；生来就有的<br>willingness 乐意；心甘情愿<br>stimuli 刺激（stimulus的复数）<br>twist 意外转折<br>electrified 带电的<br>incur 招致；遭受；引起<br>subsequent 随后的，继…之后的<br>reproduce 使再次发生；再现<br>fingernail 手指甲<br>chalkboard 黑板<br>schooling 学校教育<br>withdrawal 撤走；收回<br>inquiry 探究；探索；调查<br>self-reliant 自力更生的<br>self-destructive 自毁的，自残的<br>self-evident 不证自明的，显而易见的<br>self-deceptive 自欺的<br>instinct 本能；直觉<br>backfire 产生事与愿违的结果<br>insight 洞悉；深刻见解<br>profound 知识渊博的，理解深刻的，意义深远的<br>resist 按捺；抗拒<br>trace 追溯；找到<br>overlook 忽视，忽略<br>conceal 隐藏，隐瞒<br>follow through 进行到底；坚持完成<br>ahead of time 提前，提早<br>determine 查明；测定；确定<br>endeavor 尝试，努力<br>justify 证明别人认为不合理的事有道理，为…辩护<br>as though 好像，似乎<br>utterly 完全地，十足地<br>overwhelm 使不知所措，压倒<br>graffiti 涂鸦，乱涂乱画<br>accepted wisdom 传统信念，普遍看法<br>mechanical memorization 机械记忆<br>stuck with sth 粘住，无法摆脱<br>insidious 暗中为害的<br>prejudice 偏见<br>inferiority 低等，劣等<br>vocational education 职业教育<br>evaporate 逐渐消逝<br>headlong 轻率仓促的<br>turn sth. on its head 使人完全改变思路<br>be staring sb. in the face 非常清楚/容易看见（你却看不见）<br>wake-up call 叫醒电话，警示，警钟<br>one-size-fits-all 一刀切<br>momentum 势头<br>go on line 在运转，在运行<br>commitment 承诺<br>farsighted 有远见的<br>plummeting 直线下降的，暴跌的<br>stem from 出自，来源于<br>notably 尤其是，特别是<br>take the lead 取得领先地位<br>underline 强调<br>dismiss 拒绝考虑，否定，搁置<br>play with 被接受，买账<br>quick 聪明的，明锐的，反应快的<br>put-down 贬损的话，奚落的话<br>skeptic 持怀疑态度的人<br>in part 在某种程度上<br>place big bets on 在…上下大赌注<br>be a rarity 极为罕见<br>spike 激增<br>mean less and less 作用越来越小<br>upmarket 高级的，高端的<br>acquire 购得，收购<br>intricate 错综复杂的<br>grocery chain 连锁杂货店<br>physical product 实体产品<br>enormously 极其，非常<br>revealing 揭示内情的，泄密的<br>plot 密谋，策划<br>go through 被认可，成交；通过<br>not so much…but… 与其说毋宁说<br>break the promise 食言<br>clumsy 笨拙，不灵活的<br>remedy 纠正，改正；治疗，救治<br>to sb’s disadvantage 对…不利<br>predatory 捕食性的，食肉的<br>spammer 垃圾邮件发送者<br>analogy 类推；类似；类比<br>combat 防止，减轻<br>distracted 心烦意乱的，思想不集中的<br>put/place/set a premium on sb./sth. 重视，珍视<br>retreat 静修期间<br>ritual 程序，仪轨；习惯<br>throughout the day 终日，整天<br>keep to 坚持；信守；固守<br>prioritise 按重要性排列<br>craft 精心制作<br>demotivate 使失去动力，使消极<br>render 使变得；使处于某状态<br>improvisation 即兴表演<br>reap 收获，取得（成果）<br>downtime 停工期，休息<br>indulgence 沉溺，放纵<br>psychiatry 精神病学<br>pay a unique compliment 致以特别的赞美<br>make the first move 迈出第一步，先采取行动<br>stuck 卡住的<br>jolt 颠簸，震动，摇晃；一阵强烈的感情（尤指震惊或惊讶）<br>all of a sudden 突然<br>wholeheartedly 全心全意地<br>tick 打勾<br>encyclopedia 百科全书<br>institute 制定（政策等）；实行<br>avenue 途径；手段<br>passionately 炽热地，狂热地<br>reschedule 重新安排<br>terribly 非常<br>necessitate 使…不可避免<br>pie chart 饼状图<br>per capita 人均<br>dine out 外出进餐<br>disposable income 可支配收入<br>primary concern 首要关心的问题<br>catering companies 餐饮企业<br>respectively 各自地</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>dominoes 多米诺骨牌<br>slap on the wrist 象征性的惩罚<br>show the door 开除，扫地出门<br>insensitive 缺乏同情心的<br>misconduct 不端行为<br>hold sb to higher standards 对某人有更高要求<br>integrity 正直，诚实<br>pragmatic 实用主义的<br>overlook A for the sake of B 为B忽略A<br>ethical lapse 道德败坏，道德堕落<br>accountable 有责任的，负责的<br>fallout 影响，结果<br>harshly 严厉地，严酷地<br>paper over 隐瞒<br>the best bits of 最好的部分<br>compelling 令人信服的<br>premise 前提，假定<br>levy 征收<br>fine 罚款<br>enact 颁布，制定法律<br>overarching 包罗万象的<br>spray around 分散，喷洒<br>obscure 隐藏，掩盖<br>imposition 实施，强加<br>take off 起飞，腾飞<br>article 条款<br>coalition 同盟，联合<br>kick off 开始，发起<br>distraction 使人分心的事物<br>take effect 生效，起作用<br>back 支持<br>revenue 税收收入，财政收入<br>in the long run 长远来看<br>divert 转移，使…转向<br>transition 过渡，转变<br>polar opposite 完全相反，正好相反<br>be indicative of 显示出，表明，象征<br>condense 浓缩，凝结<br>sketchy 粗略的，不完全<br>hold up 经得住检验<br>in and of itself 就其本身而言<br>take a cue from sb 学某人的样<br>credit 归功于<br>credibility 可信度<br>not cut it 达不到要求，达不到标准<br>substantial 实实在在的，真实的<br>disclose 揭露，公开<br>raise a red flag 引起注意，发出警示<br>setback 挫折<br>look to 希望（做某事）<br>unmet 未满足的<br>cling to 坚持，不愿放弃<br>overwhelmingly 压倒性地<br>rigid 僵硬的，死板的<br>collide with 与…冲突/抵触<br>confront 面对<br>recruitment fair 招聘会<br>climb the career ladder 晋升<br>extracurricular 课外的<br>perceive 看待，理解<br>diminish 削弱，贬低（重要性或价值）<br>chronic 慢性的，长期的<br>uneven 不均匀的，不平坦的<br>deterioration 恶化，退化，堕落<br>agonising 痛苦难忍的，苦恼的<br>drastic 激烈的，猛烈的<br>advanced 晚期的<br>procedure 治疗，手术<br>malpractice 治疗失当，医疗纠纷<br>shutter 停止运行，关闭<br>fury 狂怒，暴怒<br>press ahead 推进，加紧进行<br>rational 理性的，合理的<br>auction 竞卖，拍卖<br>curb 抑制，控制，束缚<br>ideological 思想上的，意识形态的<br>shake off 摆脱<br>saw 格言，谚语<br>obscure 模糊的，晦涩的<br>in the unlikely event 在不太可能的情况下<br>tariff 关税<br>eligibility 合格，资格<br>explain away 为…辩解<br>conspiracy 阴谋，共谋，反叛<br>gratify 使高兴，使满意<br>fancy 异常复杂的，太花哨的，昂贵的<br>bear/take/suffer the brunt of 受到最严厉的攻击、批评<br>inexorably 不可阻挡地<br>reconcile 使和解，调停<br>opaque 司法制度<br>arbitrary 独断的，专制的<br>radical 重大的，彻底的<br>hamper 妨碍<br>boast 自夸，自吹自擂<br>spouse 配偶<br>sphere 范围，领域<br>overdue 迟到的，未兑现的<br>humility 谦卑，谦逊<br>arrogance 傲慢，自大<br>soever 不论何种，无论<br>render 使得<br>derive…from…从…中得到…<br>be prone to 易于…的<br>overcharge 索以高价<br>disjointed 混乱的<br>to the tune of 高达…<br>dwindling 减少的，降低的<br>hold sb. to account 要求某人承担责任<br>scrap 废除，取消<br>in case 以免，唯恐<br>outraged 义愤填膺的，气愤的<br>offset 抵消，弥补<br>stall 停止，停转<br>outrage 愤怒，愤慨<br>pronounced 显著的，很明显的<br>look set to 即将要<br>impetus 动力，推动<br>plague 困扰，折磨<br>disengage 脱离，不再感兴趣的<br>virtual 实际上的，实质上的<br>plateau 处于停滞<br>bear out 证明，证实<br>perversely 事与愿违地<br>drain 消耗，消费</p>]]></content>
      
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FileUpload</title>
      <link href="/Backend/FileUpload/"/>
      <url>/Backend/FileUpload/</url>
      
        <content type="html"><![CDATA[<h2 id="图片文件上传"><a href="#图片文件上传" class="headerlink" title="图片文件上传"></a>图片文件上传</h2><p>采用<code>loopback</code>的 <a href="https://github.com/strongloop/loopback-component-storage">LoopBack storage component</a>组件，可以实现上传文件或下载文件到云端网盘或者本地（服务器）的文件系统上。目前支持的云盘有：</p><ul><li>Amazon</li><li>Azure</li><li>Google Cloud</li><li>Openstack</li><li>Rackspace</li></ul><p>国内的网盘，大多并不开放API，上面的网盘大多不能访问，或者就是速度不是很理想，所以采用了本地文件系统存储的方式。</p><h3 id="关键概念"><a href="#关键概念" class="headerlink" title="关键概念"></a>关键概念</h3><ul><li><p><strong>容器</strong>： <em>容器</em> 将文件分组，类似于目录或者是文件夹。每个<em>容器</em> 定义了对象的命名空间并且使用唯一的名字来区分，通常是在用户账户内。</p><p>注意：<em>容器</em>内不能有子<em>容器。</em></p></li><li><p><strong>文件</strong>： 储存数据，例如文档或者是图像。每个文件总是在且仅仅在一个容器内。在容器内部，每个文件拥有唯一的名字。在不同容器里的文件可以有相同的名字。（这也就意味着，如果之前容器内已经有了同名文件，后上传的文件会覆盖之前的文件）</p></li></ul><h3 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h3><p>安装模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">$ npm install loopback-component-storage<br></code></pre></td></tr></table></figure><p>使用模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plain">$ lb datasource<br>[?] Enter the data-source name: picture<br>[?] Select the connector for myfile: other<br>[?] Enter the connector name without the loopback-connector- prefix: loopback-component-storage<br>[?] Install storage (Y&#x2F;n)<br></code></pre></td></tr></table></figure><p>在数据库配置文件<code>datasource.json</code>文件中，修改配置信息：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">&quot;picture&quot;: &#123;<br>    &quot;name&quot;: &quot;picture&quot;,<br>    &quot;connector&quot;: &quot;loopback-component-storage&quot;,<br>    &quot;provider&quot;: &quot;filesystem&quot;,<br>    &quot;root&quot;: &quot;./server/storage&quot;<br>  &#125;<br></code></pre></td></tr></table></figure><p>之后创建一个<code>model</code>，可以命名为<code>container</code>,将其连接到我们创建的<code>picture</code>数据源上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">$ slc loopback:model<br>? Enter the model name: Container<br>? Select the data-source to attach Container to: picture (loopback-component-storage)<br>? Select model&#39;s base class Model<br>? Expose Container via the REST API? Yes<br>? Custom plural form (used to build REST URL):<br>? Common model or server only? common<br></code></pre></td></tr></table></figure><p>之后会自动生成一个<code>container.json</code>文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;Container&quot;</span>,<br>  <span class="hljs-attr">&quot;plural&quot;</span>: <span class="hljs-string">&quot;containers&quot;</span>,<br>  <span class="hljs-attr">&quot;base&quot;</span>: <span class="hljs-string">&quot;Model&quot;</span>,<br>  <span class="hljs-attr">&quot;idInjection&quot;</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">&quot;options&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;validateUpsert&quot;</span>: <span class="hljs-literal">true</span><br>  &#125;,<br>  <span class="hljs-attr">&quot;properties&quot;</span>: &#123;&#125;,<br>  <span class="hljs-attr">&quot;validations&quot;</span>: [],<br>  <span class="hljs-attr">&quot;relations&quot;</span>: &#123;&#125;,<br>  <span class="hljs-attr">&quot;acls&quot;</span>: [],<br>  <span class="hljs-attr">&quot;methods&quot;</span>: &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="新建记录Model"><a href="#新建记录Model" class="headerlink" title="新建记录Model"></a>新建记录Model</h4><p>为了对文件上传的信息进行记录，还需要新建一个<code>model</code>,这个<code>model</code>的数据源为持久性存储，如数据库。必要的信息有<code>name</code>、<code>url</code>和<code>type</code>，下面是我配置好的<code>Storage-file.json</code>文件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;StorageFile&quot;</span>,<br>  <span class="hljs-attr">&quot;plural&quot;</span>: <span class="hljs-string">&quot;StorageFile&quot;</span>,<br>  <span class="hljs-attr">&quot;base&quot;</span>: <span class="hljs-string">&quot;PersistedModel&quot;</span>,<br>  <span class="hljs-attr">&quot;idInjection&quot;</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">&quot;options&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;validateUpsert&quot;</span>: <span class="hljs-literal">true</span><br>  &#125;,<br>  <span class="hljs-attr">&quot;properties&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;id&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;number&quot;</span><br>    &#125;,<br>    <span class="hljs-attr">&quot;type&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;string&quot;</span>,<br>      <span class="hljs-attr">&quot;default&quot;</span>: <span class="hljs-string">&quot;&quot;</span><br>    &#125;,<br>    <span class="hljs-attr">&quot;name&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;string&quot;</span>,<br>      <span class="hljs-attr">&quot;default&quot;</span>: <span class="hljs-string">&quot;&quot;</span><br>    &#125;,<br>    <span class="hljs-attr">&quot;url&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;string&quot;</span>,<br>      <span class="hljs-attr">&quot;default&quot;</span>: <span class="hljs-string">&quot;&quot;</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">&quot;validations&quot;</span>: [],<br>  <span class="hljs-attr">&quot;relations&quot;</span>: &#123;&#125;,<br>  <span class="hljs-attr">&quot;acls&quot;</span>: [],<br>  <span class="hljs-attr">&quot;methods&quot;</span>: &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后在<code>Storage-file.js</code>中将<code>StorageFile mode</code>l和<code> Container model</code>联系在一起,同时添加远程操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><br><span class="hljs-keyword">var</span> CONTAINER_URL = <span class="hljs-string">&#x27;/api/containers/&#x27;</span>;<br><br><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">StorageFile</span>) </span>&#123;<br>    StorageFile.upload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">ctx, options, cb</span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.info(ctx.req);<br>        options = options || &#123;&#125;;<br>        <span class="hljs-comment">// Firstly, you must create folder  /server/storage/common</span><br>        ctx.req.params.container = <span class="hljs-string">&#x27;common&#x27;</span>;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * ctx.req    express request object</span><br><span class="hljs-comment">         * ctx.result express response object</span><br><span class="hljs-comment">         */</span><br>        StorageFile.app.models.Container.upload(ctx.req, ctx.result,<br>            options, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, fileObj</span>) </span>&#123;<br>                <span class="hljs-keyword">if</span> (err) &#123;<br>                    <span class="hljs-keyword">return</span> cb(<span class="hljs-literal">null</span>, &#123;<br>                        code: <span class="hljs-number">200</span>,<br>                        message: <span class="hljs-string">&#x27;fail&#x27;</span>,<br>                        error: err.message<br>                    &#125;);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// The &#x27;file&#x27;below should be the same as field name in the form</span><br>                    <span class="hljs-keyword">var</span> fileInfoArr = fileObj.files.file;<br>                    <span class="hljs-keyword">var</span> objs = [];<br><br>                    <span class="hljs-built_in">console</span>.info(fileObj.files);<br>                    fileInfoArr.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>&#123;<br>                        <br>                        objs.push(&#123;<br>                            name: item.name,<br>                            type: item.type,<br>                            url: CONTAINER_URL + item.container +<br>                                <span class="hljs-string">&#x27;/download/&#x27;</span> + item.name,<br>                        &#125;);<br>                    &#125;);<br>                    <span class="hljs-built_in">console</span>.log(objs);<br>                    StorageFile.create(objs, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, instances</span>) </span>&#123;<br>                        <span class="hljs-keyword">if</span> (err) &#123;<br>                            <span class="hljs-keyword">return</span> cb(<span class="hljs-literal">null</span>, &#123;<br>                                code: <span class="hljs-number">200</span>,<br>                                message: <span class="hljs-string">&#x27;fail&#x27;</span>,<br>                                error: err.message<br>                            &#125;);<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">var</span> res = &#123;<br>                                code: <span class="hljs-number">200</span>,<br>                                message: <span class="hljs-string">&#x27;success&#x27;</span>,<br>                                data: instances<br>                            &#125;<br>                            cb(<span class="hljs-literal">null</span>, res);<br>                        &#125;<br>                    &#125;);<br>                &#125;<br>            &#125;);<br>    &#125;;<br><br>    StorageFile.remoteMethod(<br>        <span class="hljs-string">&#x27;upload&#x27;</span>, &#123;<br>            http: &#123; <span class="hljs-attr">verb</span>: <span class="hljs-string">&#x27;post&#x27;</span> &#125;,<br>            description: <span class="hljs-string">&#x27;Upload a file or more files&#x27;</span>,<br>            accepts: [<br>                &#123; <span class="hljs-attr">arg</span>: <span class="hljs-string">&#x27;ctx&#x27;</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;object&#x27;</span>, <span class="hljs-attr">http</span>: &#123; <span class="hljs-attr">source</span>: <span class="hljs-string">&#x27;context&#x27;</span> &#125; &#125;,<br>                &#123; <span class="hljs-attr">arg</span>: <span class="hljs-string">&#x27;options&#x27;</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;object&#x27;</span>, <span class="hljs-attr">http</span>: &#123; <span class="hljs-attr">source</span>: <span class="hljs-string">&#x27;query&#x27;</span> &#125; &#125;,<br>            ],<br>            returns: &#123;<br>                arg: <span class="hljs-string">&#x27;fileObject&#x27;</span>, <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;object&#x27;</span>, <span class="hljs-attr">root</span>: <span class="hljs-literal">true</span>,<br>            &#125;<br><br>        &#125;<br>    );<br>&#125;;<br><br></code></pre></td></tr></table></figure><p> 上传文件时需要为表单类型，表单的field名为file ，数据类型为<code>multipart/form-data</code>，<code>ios</code>开发实现表单上传<a href="https://www.jianshu.com/p/a0e3c77d3164">https://www.jianshu.com/p/a0e3c77d3164</a></p><h3 id="文件名添加时间戳"><a href="#文件名添加时间戳" class="headerlink" title="文件名添加时间戳"></a>文件名添加时间戳</h3><p>在<code>/server</code>新建文件<code>datasources.local.js</code>,添加限制文件代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><br><span class="hljs-keyword">var</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  picture: &#123;<br>    <br>    <span class="hljs-comment">// 限定上传文件大小为50M</span><br>    maxFileSize: <span class="hljs-number">100</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>,<br><br>    <span class="hljs-comment">// 自定义文件名</span><br>    getFilename: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fileInfo</span>) </span>&#123;<br>      <span class="hljs-keyword">var</span> fileName = fileInfo.name.replace(<span class="hljs-regexp">/\s+/g</span>, <span class="hljs-string">&#x27;-&#x27;</span>).toLowerCase();<br>      <span class="hljs-keyword">var</span> fileObj = path.parse(fileName);<br>      <span class="hljs-comment">// 给文件名加上时间戳</span><br>      <span class="hljs-keyword">return</span> fileObj.name + <span class="hljs-built_in">Date</span>.now() + fileObj.ext;<br>    &#125;,<br>  &#125;,<br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>返回数据</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br><span class="hljs-attr">&quot;code&quot;</span>:<span class="hljs-number">200</span>,<br><span class="hljs-attr">&quot;message&quot;</span>:<span class="hljs-string">&quot;success&quot;</span>,<br>    <span class="hljs-attr">&quot;data&quot;</span>:[&#123;<br>    <span class="hljs-attr">&quot;id&quot;</span>:<span class="hljs-number">34</span>,<br>    <span class="hljs-attr">&quot;type&quot;</span>:<span class="hljs-string">&quot;image/jpeg&quot;</span>,<br>    <span class="hljs-attr">&quot;name&quot;</span>:<span class="hljs-string">&quot;4bafe474-a425-4ad4-89ec-6b5f3d846f201561816439332.jpg&quot;</span>,<br>    <span class="hljs-attr">&quot;url&quot;</span>:<span class="hljs-string">&quot;/api/containers/common/download/4bafe474-a425-4ad4-89ec-6b5f3d846f201561816439332.jpg&quot;</span><br>    &#125;]    <br>&#125;<br></code></pre></td></tr></table></figure><p>多文件</p><p>返回数据</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;code&quot;</span>:<span class="hljs-number">200</span>,<br>    <span class="hljs-attr">&quot;message&quot;</span>:<span class="hljs-string">&quot;success&quot;</span>,<br>    <span class="hljs-attr">&quot;data&quot;</span>:[&#123;<br>       <span class="hljs-attr">&quot;id&quot;</span>:<span class="hljs-number">35</span>,<br>        <span class="hljs-attr">&quot;type&quot;</span>:<span class="hljs-string">&quot;image/jpeg&quot;</span>,<br>        <span class="hljs-attr">&quot;name&quot;</span>:<span class="hljs-string">&quot;40d8652c-7839-47b2-9337-898db31f87301561816572238.jpg&quot;</span>,<br>        <span class="hljs-attr">&quot;url&quot;</span>:<span class="hljs-string">&quot;/api/containers/common/download/40d8652c-7839-47b2-9337-898db31f87301561816572238.jpg&quot;</span><br>    &#125;,<br>        &#123;<br>        <span class="hljs-attr">&quot;id&quot;</span>:<span class="hljs-number">36</span>,<br>        <span class="hljs-attr">&quot;type&quot;</span>:<span class="hljs-string">&quot;image/jpeg&quot;</span>,<br>        <span class="hljs-attr">&quot;name&quot;</span>:<span class="hljs-string">&quot;993cae69-ea7c-4826-837a-098c5d2f633b1561816572247.jpg&quot;</span>,<br>        <span class="hljs-attr">&quot;url&quot;</span>:<span class="hljs-string">&quot;/api/containers/common/download/993cae69-ea7c-4826-837a-098c5d2f633b1561816572247.jpg&quot;</span>&#125;<br>        ]<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Backend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LoopBack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系分第三次作业</title>
      <link href="/SSAD/SSAD-homework3/"/>
      <url>/SSAD/SSAD-homework3/</url>
      
        <content type="html"><![CDATA[<h2 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h2><h3 id="1-简述瀑布模型、增量模型、螺旋模型（含原型方法），并分析优缺点。（从项目特点、风险特征、人力资源利用角度思考。）"><a href="#1-简述瀑布模型、增量模型、螺旋模型（含原型方法），并分析优缺点。（从项目特点、风险特征、人力资源利用角度思考。）" class="headerlink" title="1.简述瀑布模型、增量模型、螺旋模型（含原型方法），并分析优缺点。（从项目特点、风险特征、人力资源利用角度思考。）"></a>1.简述瀑布模型、增量模型、螺旋模型（含原型方法），并分析优缺点。（从项目特点、风险特征、人力资源利用角度思考。）</h3><h4 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h4><a id="more"></a> <h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ul><li>降低软件开发的复杂度，提高软件开发过程透明性</li><li>推迟软件实现，强调在软件实现前必须进行分析和设计工作</li><li>以项目的阶段评审和文档控制为手段有效地对整个开发过程进行指导，保证了阶段之间的正确衔接，能够及时发现并纠正开 发过程中存在的缺陷，使产品达到预期的质量要求。</li><li>为项目提供了按阶段划分的检查点。</li><li>当前一阶段完成后，您只需要去关注后续阶段。</li></ul><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ul><li>过分强调过程活动的线性顺序，通过过多的强制完成日期和里程碑来跟踪各个项目阶段。</li><li>缺乏灵活性，尤其无法解决软件需求不明确或不准确的问题</li><li>风险控制能力较弱，当某一个阶段产生错误时，需要回归到前几个阶段重新开始，从而增加了开发风险。</li><li>各个阶段的划分完全固定，阶段之间产生大量的文档，极大地增加了工作量</li></ul><h4 id="增量模型"><a href="#增量模型" class="headerlink" title="增量模型"></a><strong>增量模型</strong></h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li>增强客户对系统的信心。</li><li>降低系统失败风险。</li><li>提高系统可靠性。</li><li>提高系统的稳定性和可维护性。</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>建立初始模型时，作为增量基础的基本业务服务的确定有一定难度 。</li><li>增量粒度难以选择 。</li></ul><h4 id="螺旋模型（含原型方法）"><a href="#螺旋模型（含原型方法）" class="headerlink" title="螺旋模型（含原型方法）"></a><strong>螺旋模型（含原型方法）</strong></h4><h5 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h5><ul><li>设计上的灵活性, 可以在项目的各个阶段进行变更</li><li>通过原型建立，使得软件开发在每个迭代有最初明确的方向</li><li>引入风险分析，最大程度地降低软件失败造成损失的可能</li><li>客户始终参与每个阶段的开发,保证了项目不偏离正确方向以及项目的可控性</li><li>随着项目推进,客户始终掌握项目的最新信息 , 从而能够和管理层有效地交互。</li></ul><h5 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h5><ul><li>失误的风险分析可能带来更大的风险</li><li>过多的迭代次数会增加开发成本，延迟提交时间</li><li>螺旋模型强调风险分析，但说服外部客户接受和相信分析结果并做出相关反应并不容易，因此螺旋模型往往比较适合内部的大规模软件开发，过多的风险管理支出将会影响客户的最终收益</li><li>风险分析需要耗费相当的成本，因此螺旋模型比较适合投资规模较大的软件项目。</li></ul><hr><h3 id="简述统一过程三大特点，与面向对象的方法有什么关系？"><a href="#简述统一过程三大特点，与面向对象的方法有什么关系？" class="headerlink" title="简述统一过程三大特点，与面向对象的方法有什么关系？"></a>简述统一过程三大特点，与面向对象的方法有什么关系？</h3><p>用 RUP 的观点：</p><ul><li>用户为中心（描述用户使用产品的故事、用例驱动）：开发团队使用从需求收集到编程，测试阶段的测试用例</li><li>架构为重心（软件产品分解的领域最佳实践）：为整个项目建立架构，实现建模、分析与设计、实现、测试与维护的各个模块</li><li>风险驱动（早期暴露风险）：允许在不完善的条件下开始开发，并在开发的过程中不断改善</li></ul><p>统一过程是一个流行的构造面向对象系统的迭代软件开发过程,给出了有关软件开发过程组织及实施的指导</p><hr><h3 id="简述统一过程四个阶段的划分准则是什么？每个阶段关键的里程碑是什么？"><a href="#简述统一过程四个阶段的划分准则是什么？每个阶段关键的里程碑是什么？" class="headerlink" title="简述统一过程四个阶段的划分准则是什么？每个阶段关键的里程碑是什么？"></a>简述统一过程四个阶段的划分准则是什么？每个阶段关键的里程碑是什么？</h3><p>统一过程划分准则是：每个阶段结束的时候执行一次评估确定该阶段的目标是否满足，同时产生一个里程碑，如果评估结果令人满意，那么项目进入下一阶段。</p><h4 id="统一过程中的软件生命周期在时间维度上被分解为四个顺序的阶段"><a href="#统一过程中的软件生命周期在时间维度上被分解为四个顺序的阶段" class="headerlink" title="统一过程中的软件生命周期在时间维度上被分解为四个顺序的阶段"></a>统一过程中的软件生命周期在时间维度上被分解为四个顺序的阶段</h4><ul><li>初始：大体上的构想、业务案例、范围和模糊评估</li><li>细化：已精化的构想、核心架构的迭代实现、高风险的解决、确定大多数需求和范围以及进行更为实际的评估</li><li>构造：对遗留下来的风险较低和比较简单的元素进行迭代实现，准备部署</li><li>移交：进行系统部署，系统测试</li></ul><h4 id="四个阶段的里程碑"><a href="#四个阶段的里程碑" class="headerlink" title="四个阶段的里程碑"></a>四个阶段的里程碑</h4><ul><li>生命周期目标里程碑：对应初始阶段的结束。定义系统的业务模型，确定系统的范围。开发者应该可以明确软件系统的目标和范围</li><li>生命周期体系结构里程碑：对应细化阶段的结束，完成系统的体系结构设计，完成系统开发计划</li><li>初始能力里程碑：对应构造阶段的技术，构造产品，并继续演进需求、体系结构和计划，直到产品完成</li><li>产品发布里程碑：对应移交阶段的结束，移交阶段主要进行重构、修改、测试以及部署等工作，完成系统发布和用户培训等工作</li></ul><hr><h3 id="软件企业为什么能按固定节奏生产、固定周期发布软件产品？它给企业项目管理带来哪些好处？"><a href="#软件企业为什么能按固定节奏生产、固定周期发布软件产品？它给企业项目管理带来哪些好处？" class="headerlink" title="软件企业为什么能按固定节奏生产、固定周期发布软件产品？它给企业项目管理带来哪些好处？"></a><strong>软件企业为什么能按固定节奏生产、固定周期发布软件产品？它给企业项目管理带来哪些好处？</strong></h3><p>RUP将软件的生命周期划分为四个阶段，其中每个阶段的时长是固定的，并且开发被组织成一系列固定的短期小项目，称为迭代。因此在产品的的迭代开发过程有较为明确的时间限制的，企业能够按照统一过程的标准，按固定周期完成产品的生产和发布。</p><p>软件企业按照固定节奏生产、固定周期发布软件产品确保了（软件）项目能够保质保量的按时交付。企业可以更加便利地掌控开发进度以及控制预算， 对产品的质量和生产开发过程都能进行较为精准的把控。同时又能及时地收集产品反馈，提高客户体验，了解项目的不足，进一步做出项目的优化措施，降低项目风险，提高软件质量。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 系分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Objective-C基础框架</title>
      <link href="/IOS/Foundation/"/>
      <url>/IOS/Foundation/</url>
      
        <content type="html"><![CDATA[<h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><p>数据存储及检索是任何程序中最重要的一个操作</p><a id="more"></a> <h3 id="NSArray和NSMutableArray"><a href="#NSArray和NSMutableArray" class="headerlink" title="NSArray和NSMutableArray"></a>NSArray和NSMutableArray</h3><p><code>NSArray</code>用于保存不可变对象数组，<code>NSMutableArray</code>用于保存可变对象数组。<br><code>Mutablility</code>有助于在运行时更改预分配数组中的数组，但如果使用<code>NSArray</code>，只替换现有数组，并且不能更改现有数组的内容。</p><p><code>NSArray</code>的重要方法如下 -</p><ul><li><code>alloc/initWithObjects</code> − 用于使用对象初始化数组。</li><li><code>objectAtIndex</code> − 返回指定索引处的对象。</li><li><code>count</code> − 返回对象数量。</li></ul><p><code>NSMutableArray</code>继承自<code>NSArray</code>，因此<code>NSArray</code>的所有实例方法都可在<code>NSMutableArray</code>中使用</p><p><code>NSMutableArray</code>的重要方法如下 -</p><ul><li><code>removeAllObjects</code> − 清空数组。</li><li><code>addObject</code> − 在数组的末尾插入给定对象。</li><li><code>removeObjectAtIndex</code> − 这用于删除<code>objectAt</code>指定的索引处的对象。</li><li><code>exchangeObjectAtIndex:withObjectAtIndex</code> − 在给定索引处交换数组中的对象。</li><li><code>replaceObjectAtIndex:withObject</code> − 用Object替换索引处的对象。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">&#x2F;&#x2F; 访问元素<br>    NSArray * arr1 &#x3D; @[@&quot;one&quot;,@&quot;two&quot;,@&quot;three&quot;];<br><br>    &#x2F;&#x2F;用下标运算符访问某个元素<br><br>    NSLog(@&quot;arr[1] is %@&quot;, arr1[1]);<br>    &#x2F;&#x2F;调方法访问某个元素<br><br>    NSLog(@&quot;objectAtIndex:1  &#x3D;&#x3D; %@&quot;, [arr1 objectAtIndex:1]);<br>    &#x2F;&#x2F;获取元素数量<br><br>    NSLog(@&quot;arr1的元素个数为: %lu&quot;, [arr1 count]);<br><br>    &#x2F;&#x2F;遍历数组对象<br><br>    &#x2F;&#x2F;1,  用循环和下标运算符遍历<br><br>    NSUInteger i;<br><br>    for (i&#x3D;0; i&lt;[arr1 count]; i++) &#123;<br><br>        NSLog(@&quot;arr[%lu]&#x3D;%@&quot;, i,arr1[i]);<br><br>    &#125;<br><br>    &#x2F;&#x2F;2,  用循环和方法objectAtIndex： 完成遍历<br><br>    for (i&#x3D;0; i&lt;[arr1 count]; i++) &#123;<br><br>        NSLog(@&quot;[arr1 objectAtIndex:%lu] &#x3D;&#x3D; %@&quot;, (unsigned long)i, [arr1 objectAtIndex:i]);<br><br>    &#125;<br><br>    &#x2F;&#x2F;3,  快速枚举法<br><br>    for( id obj in arr1)    &#x2F;&#x2F; for(int i&#x3D;0;i&lt;10;i++)<br><br>    &#123;<br><br>        NSLog(@&quot;快速枚举法：obj&#x3D;[%@]&quot;,obj);<br><br>    &#125;<br><br>    &#x2F;&#x2F;4,枚举器法,  首先认识一种枚举器对象<br><br>    &#x2F;&#x2F;               枚举器对象        这个方法是获取一个数组的枚举器<br><br>    &#x2F;&#x2F;                                  正序枚举器<br><br>    NSEnumerator * enumerator &#x3D;[arr1 objectEnumerator];<br><br>    id obj;<br><br>    while (obj &#x3D; [enumerator nextObject]) &#123;<br><br>        NSLog(@&quot;正序枚举器法遍历: obj &#x3D;&#x3D; %@&quot;, obj);<br><br>    &#125;<br><br>    &#x2F;&#x2F;                                     逆序枚举器<br><br>    NSEnumerator *enumerator2 &#x3D; [arr1 reverseObjectEnumerator];<br><br>   <br><br>    while (obj &#x3D; [enumerator2 nextObject]) &#123;<br><br>        NSLog(@&quot;逆序枚举器法遍历: obj &#x3D;&#x3D; %@&quot;, obj);<br><br>    &#125;<br><br>**********************************************<br><br>&#x2F;&#x2F;数组排序<br><br> &#x2F;&#x2F; 要回调的函数<br><br>NSInteger compareTwoObjects(id obj1, id obj2, void * args)<br><br>&#123;<br><br>&#x2F;&#x2F;    struct student * stu &#x3D; args;<br><br>&#x2F;&#x2F;    printf(&quot;args:%s\n&quot;,args);<br><br>    &#x2F;&#x2F;1,比较字符串大小<br><br>&#x2F;&#x2F;    return [obj1 compare:obj2];<br><br>    &#x2F;&#x2F;2, 比较字符串的长度<br><br>    return [obj1 length]-[obj2 length]; <br><br>    &#x2F;&#x2F;3, 将字符串转成整型，再比较整型的大小<br><br>&#x2F;&#x2F;    return [obj1 integerValue]-[obj2 integerValue];<br><br>&#125;<br><br>  NSArray *array &#x3D; [[ NSArray alloc]initWithObjects:@&quot;123&quot;,@&quot;4567&quot;,@&quot;34&quot;,@&quot;111&quot;, @&quot;x&quot;,nil];<br><br>    &#x2F;&#x2F;  对数组的元素进行排序: 传进来的是一个回调函数，用于处理比较细节<br><br>   NSArray * newArray &#x3D;  [array sortedArrayUsingFunction: compareTwoObjects context:&quot;testString&quot;];<br></code></pre></td></tr></table></figure><h3 id="NSDictionary和NSMutableDictionary"><a href="#NSDictionary和NSMutableDictionary" class="headerlink" title="NSDictionary和NSMutableDictionary"></a>NSDictionary和NSMutableDictionary</h3><p><code>NSDictionary</code>用于保存对象的不可变字典，<code>NSMutableDictionary</code>用于保存对象的可变字典。</p><p><code>NSDictionary</code>的一些重要方法如下 -</p><ul><li><code>alloc/initWithObjectsAndKeys</code> − 使用指定的值和键集构造的条目初始化新分配的字典。</li><li><code>valueForKey</code> − 返回与给定键关联的值。</li><li><code>count</code> − 返回字典中的项目数。</li></ul><p><code>NSMutableDictionary</code>继承自<code>NSDictionary</code>，因此<code>NSDictionary</code>的所有实例方法都可以在<code>NSMutableDictionary</code>中使用。<code>NSMutableDictionary</code>的重要方法如下 -</p><ul><li><code>removeAllObjects</code> - 清空字典的条目。</li><li><code>removeObjectForKey</code> - 从字典中删除给定键及其关联值。</li><li><code>setValue：forKey</code> - 将给定的键值对添加到字典中。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">#import &lt;Foundation&#x2F;Foundation.h&gt;<br><br>int main() &#123;<br>   NSAutoreleasePool * pool &#x3D; [[NSAutoreleasePool alloc] init];<br>   NSDictionary *dictionary &#x3D; [[NSDictionary alloc] initWithObjectsAndKeys:<br>   @&quot;string1&quot;,@&quot;key1&quot;, @&quot;string2&quot;,@&quot;key2&quot;,@&quot;string3&quot;,@&quot;key3&quot;,nil];<br>   NSString *string1 &#x3D; [dictionary objectForKey:@&quot;key1&quot;];<br>   NSLog(@&quot;The object for key, key1 in dictionary is %@&quot;,string1);<br><br>   NSMutableDictionary *mutableDictionary &#x3D; [[NSMutableDictionary alloc]init];<br>   [mutableDictionary setValue:@&quot;string&quot; forKey:@&quot;key1&quot;];<br>   string1 &#x3D; [mutableDictionary objectForKey:@&quot;key1&quot;];<br>   NSLog(@&quot;The object for key, key1 in mutableDictionary is %@&quot;,string1); <br><br>   [pool drain];<br>   return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="NSSet和NSMutableSet"><a href="#NSSet和NSMutableSet" class="headerlink" title="NSSet和NSMutableSet"></a>NSSet和NSMutableSet</h3><p><code>NSSet</code>用于保存不可变的一组不同的对象，<code>NSMutableDictionary</code>用于保存一组可变的不同对象。<code>NSSet</code>的重要方法如下 -</p><ul><li><code>alloc/initWithObjects</code> - 使用从指定的对象列表中获取的成员初始化新分配的集合。</li><li><code>allObjects</code> - 返回包含集合成员的数组，如果集合没有成员，则返回空数组。</li><li><code>count</code> - 返回集合中的成员数量。</li></ul><p><code>NSMutableSet</code>继承自<code>NSSet</code>类，因此NSSet的所有实例方法都可以在<code>NSMutableSet</code>中使用。</p><p><code>NSMutableSet</code>的一些重要方法如下 -</p><ul><li><code>removeAllObjects</code> − 清空集合的所有成员。</li><li><code>addObject</code> − 如果给定对象尚未成为成员，则将该对象添加到该集合中。</li><li><code>removeObject</code> − 从集合中删除给定对象。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">#import &lt;Foundation&#x2F;Foundation.h&gt;<br><br>int main() &#123;<br>   NSAutoreleasePool * pool &#x3D; [[NSAutoreleasePool alloc] init];<br>   NSSet *set &#x3D; [[NSSet alloc]<br>   initWithObjects:@&quot;yii&quot;, @&quot;bai&quot;,@&quot;.com&quot;,nil];<br>   NSArray *setArray &#x3D; [set allObjects];<br>   NSLog(@&quot;The objects in set are %@&quot;,setArray);<br><br>   NSMutableSet *mutableSet &#x3D; [[NSMutableSet alloc]init];<br>   [mutableSet addObject:@&quot;yiibai&quot;];<br>   setArray &#x3D; [mutableSet allObjects];<br>   NSLog(@&quot;The objects in mutableSet are %@&quot;,setArray);<br><br>   [pool drain];<br>   return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="文本和字符串"><a href="#文本和字符串" class="headerlink" title="文本和字符串"></a>文本和字符串</h2><p>NSString是最常用的类，用于存储字符串和文本,<code>NSCharacterSet</code>表示<code>NSString</code>和<code>NSScanner</code>类使用的各种字符分组</p><h3 id="NSCharacterSet"><a href="#NSCharacterSet" class="headerlink" title="NSCharacterSet"></a>NSCharacterSet</h3><p><code>NSCharacterSet</code>中可用的方法集，它们表示各种字符集。</p><ul><li><code>alphanumericCharacterSet</code> - 返回包含“字母”，“标记”和“数字”类别中的字符的字符集。</li><li><code>capitalizedLetterCharacterSet</code> - 返回包含首字母大写字母类别中字符的字符集。</li><li><code>characterSetWithCharactersInString</code> - 返回包含给定字符串中字符的字符集。</li><li><code>characterSetWithRange</code> - 返回包含给定范围内具有<code>Unicode</code>值的字符的字符集。</li><li><code>illegalCharacterSet</code> - 返回一个字符集，其中包含非字符类别中的值或尚未在<code>Unicode</code>标准的<code>3.2</code>版中定义的值。</li><li><code>letterCharacterSet</code> - 返回包含<code>Letters</code>和<code>Marks</code>类别中字符的字符集。</li><li><code>lowercaseLetterCharacterSet</code> - 返回包含“小写字母”类别中字符的字符集。</li><li><code>newlineCharacterSet</code> - 返回包含换行符的字符集。</li><li><code>punctuationCharacterSet</code> - 返回包含标点符号类别中字符的字符集。</li><li><code>symbolCharacterSet</code> - 返回包含符号类别中字符的字符集。</li><li><code>uppercaseLetterCharacterSet</code> - 返回包含大写字母和标题字母类别中字符的字符集。</li><li><code>whitespaceAndNewlineCharacterSet</code> - 返回包含Unicode一般类别 <code>Z*</code>，<code>U000A~U000D</code>和<code>U0085</code>的字符集。</li><li><code>whitespaceCharacterSet</code> - 返回仅包含内嵌空白字符空间(<code>U+0020</code>)和制表符(<code>U+0009</code>)的字符集。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">NSAutoreleasePool * pool &#x3D; [[NSAutoreleasePool alloc] init];<br>NSString *string &#x3D; @&quot;....Yii Bai.com.....&quot;;<br>NSLog(@&quot;Initial String :%@&quot;, string);<br><br>NSCharacterSet *characterset &#x3D; [NSCharacterSet punctuationCharacterSet];<br>string &#x3D; [string stringByTrimmingCharactersInSet:characterset];<br>NSLog(@&quot;Final String :%@&quot;, string);<br></code></pre></td></tr></table></figure><h2 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h2><p>在Objective-C中，<code>NSDate</code>和<code>NSDateFormatter</code>类用于提供日期和时间的功能。<br><code>NSDateFormatter</code>是一个帮助程序类，可以很容易地将<code>NSDate</code>转换为<code>NSString</code>，反之亦然。</p><p>显示将<code>NSDate</code>转换为<code>NSString</code>并返回<code>NSDate</code>的简单示例如下所示 -</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">NSAutoreleasePool * pool &#x3D; [[NSAutoreleasePool alloc] init];<br>NSDate *date&#x3D; [NSDate date];<br>NSDateFormatter *dateFormatter &#x3D; [[NSDateFormatter alloc]init];<br>[dateFormatter setDateFormat:@&quot;yyyy-MM-dd&quot;];<br><br>NSString *dateString &#x3D; [dateFormatter stringFromDate:date];<br>NSLog(@&quot;Current date is %@&quot;,dateString);<br>NSDate *newDate &#x3D; [dateFormatter dateFromString:dateString];<br>NSLog(@&quot;NewDate: %@&quot;,newDate);<br></code></pre></td></tr></table></figure><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>在Objective-C中提供了基础类 - <code>NSException</code>用于异常处理。</p><p>使用以下块实现异常处理 -</p><ul><li><code>@try</code> - 此块尝试执行一组语句。</li><li><code>@catch</code> - 此块尝试捕获<code>try</code>块中的异常。</li><li><code>@finally</code> - 此块包含始终执行的一组语句。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">#import &lt;Foundation&#x2F;Foundation.h&gt;<br><br>int main() &#123;<br>   NSAutoreleasePool * pool &#x3D; [[NSAutoreleasePool alloc] init];<br>   NSMutableArray *array &#x3D; [[NSMutableArray alloc]init];        <br><br>   @try  &#123;<br>      NSString *string &#x3D; [array objectAtIndex:10];<br>   &#125; @catch (NSException *exception) &#123;<br>      NSLog(@&quot;%@ &quot;,exception.name);<br>      NSLog(@&quot;Reason: %@ &quot;,exception.reason);<br>   &#125;<br><br>   @finally  &#123;<br>      NSLog(@&quot;@@finaly Always Executes&quot;);<br>   &#125;<br><br>   [pool drain];<br>   return 0;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="文件处理"><a href="#文件处理" class="headerlink" title="文件处理"></a>文件处理</h2><p>使用<code>NSFileManager</code>类进行文件处理</p><h3 id="文件处理中使用的方法"><a href="#文件处理中使用的方法" class="headerlink" title="文件处理中使用的方法"></a>文件处理中使用的方法</h3><p>下面列出了用于访问和操作文件的方法列表。 在这里，必须将<code>FilePath1</code>，<code>FilePath2</code>和<code>FilePath</code>字符串替换为所需的完整文件路径，以获得所需的操作。</p><h4 id="1-检查文件是否存在于路径中"><a href="#1-检查文件是否存在于路径中" class="headerlink" title="1. 检查文件是否存在于路径中"></a>1. 检查文件是否存在于路径中</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">NSFileManager</span> *fileManager = [<span class="hljs-built_in">NSFileManager</span> defaultManager];<br><br><span class="hljs-comment">//Get documents directory</span><br><span class="hljs-built_in">NSArray</span> *directoryPaths = <span class="hljs-built_in">NSSearchPathForDirectoriesInDomains</span><br>(<span class="hljs-built_in">NSDocumentDirectory</span>, <span class="hljs-built_in">NSUserDomainMask</span>, <span class="hljs-literal">YES</span>);<br><span class="hljs-built_in">NSString</span> *documentsDirectoryPath = [directoryPaths objectAtIndex:<span class="hljs-number">0</span>];<br><br><span class="hljs-keyword">if</span> ([fileManager fileExistsAtPath:<span class="hljs-string">@&quot;&quot;</span>] == <span class="hljs-literal">YES</span>) &#123;<br>   <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;File exists&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-比较两个文件内容"><a href="#2-比较两个文件内容" class="headerlink" title="2. 比较两个文件内容"></a>2. 比较两个文件内容</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">if</span> ([fileManager contentsEqualAtPath:<span class="hljs-string">@&quot;FilePath1&quot;</span> andPath:<span class="hljs-string">@&quot; FilePath2&quot;</span>]) &#123;<br>   <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Same content&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-检查是否可写，可读和可执行"><a href="#3-检查是否可写，可读和可执行" class="headerlink" title="3. 检查是否可写，可读和可执行"></a>3. 检查是否可写，可读和可执行</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">if</span> ([fileManager isWritableFileAtPath:<span class="hljs-string">@&quot;FilePath&quot;</span>]) &#123;<br>   <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;isWritable&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span> ([fileManager isReadableFileAtPath:<span class="hljs-string">@&quot;FilePath&quot;</span>]) &#123;<br>   <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;isReadable&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span> ( [fileManager isExecutableFileAtPath:<span class="hljs-string">@&quot;FilePath&quot;</span>]) &#123;<br>   <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;is Executable&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-移动文件"><a href="#4-移动文件" class="headerlink" title="4. 移动文件"></a>4. 移动文件</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">if</span>([fileManager moveItemAtPath:<span class="hljs-string">@&quot;FilePath1&quot;</span> <br>   toPath:<span class="hljs-string">@&quot;FilePath2&quot;</span> error:<span class="hljs-literal">NULL</span>]) &#123;<br>      <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Moved successfully&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-复制文件"><a href="#5-复制文件" class="headerlink" title="5. 复制文件"></a>5. 复制文件</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">if</span> ([fileManager copyItemAtPath:<span class="hljs-string">@&quot;FilePath1&quot;</span> <br>   toPath:<span class="hljs-string">@&quot;FilePath2&quot;</span>  error:<span class="hljs-literal">NULL</span>]) &#123;<br>      <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Copied successfully&quot;</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="6-删除文件"><a href="#6-删除文件" class="headerlink" title="6. 删除文件"></a>6. 删除文件</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">if</span> ([fileManager removeItemAtPath:<span class="hljs-string">@&quot;FilePath&quot;</span> error:<span class="hljs-literal">NULL</span>]) &#123;<br>   <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;Removed successfully&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7-读取文件"><a href="#7-读取文件" class="headerlink" title="7. 读取文件"></a>7. 读取文件</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">NSData</span> *data = [fileManager contentsAtPath:<span class="hljs-string">@&quot;Path&quot;</span>];<br></code></pre></td></tr></table></figure><h4 id="8-写入文件"><a href="#8-写入文件" class="headerlink" title="8. 写入文件"></a>8. 写入文件</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">[fileManager createFileAtPath:<span class="hljs-string">@&quot;&quot;</span> contents:data attributes:<span class="hljs-literal">nil</span>];<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Objective-C </tag>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系分第二次作业</title>
      <link href="/SSAD/SSAD-homework2/"/>
      <url>/SSAD/SSAD-homework2/</url>
      
        <content type="html"><![CDATA[<h2 id="1-简答题"><a href="#1-简答题" class="headerlink" title="1. 简答题"></a>1. 简答题</h2><h3 id="用简短的语言给出对分析、设计的理解"><a href="#用简短的语言给出对分析、设计的理解" class="headerlink" title="用简短的语言给出对分析、设计的理解"></a>用简短的语言给出对分析、设计的理解</h3><p><strong>分析：</strong>强调对问题和需求的调查和研究，而不是解决方法</p><p><strong>设计：</strong>强调满足需求的一种概念上的软件和硬件的解决方法，而它的实现</p><a id="more"></a> <h3 id="用一句话描述面向对象的分析与设计的优势"><a href="#用一句话描述面向对象的分析与设计的优势" class="headerlink" title="用一句话描述面向对象的分析与设计的优势"></a>用一句话描述面向对象的分析与设计的优势</h3><p>面向对象的分析和设计使用相同的建模符号，问题层次和实施层次的专家可以通过通用符号进行交流。</p><h3 id="简述-UML（统一建模语言）的作用。考试考哪些图？"><a href="#简述-UML（统一建模语言）的作用。考试考哪些图？" class="headerlink" title="简述 UML（统一建模语言）的作用。考试考哪些图？"></a>简述 UML（统一建模语言）的作用。考试考哪些图？</h3><p><strong>作用：</strong>UML是种通用的可视化建模语言，用于可视化分析和设计的结果，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法</p><p><strong>考试的图：</strong>用例图、静态图、行为图、实现图等。</p><ul><li>用例图：用户角度：功能、执行者</li><li>静态图：系统静态结构<ul><li>类图：概念及关系</li><li>对象图：某种状态或时间段内，系统中活跃的对象及其关系</li><li>包图：描述系统的分解结构</li></ul></li><li>行为图：系统的动态行为<ul><li>交互图：描述对象间的消息传递<ul><li>顺序图：强调对象间消息发送的时序</li><li>合作图：强调对象间的动态协作关系</li></ul></li><li>状态图：对象的动态行为。状态-事件-状态迁移-响应动作</li><li>活动图：描述系统为完成某功能而执行的操作序列</li></ul></li><li>实现图：描述系统的组成和分布状况<ul><li>构件图：组成部件及其关系</li><li>部署图：物理体系结构及与软件单元的对应关系</li></ul></li></ul><h3 id="从软件本质的角度，解释软件范围（需求）控制的可行性"><a href="#从软件本质的角度，解释软件范围（需求）控制的可行性" class="headerlink" title="从软件本质的角度，解释软件范围（需求）控制的可行性"></a>从软件本质的角度，解释软件范围（需求）控制的可行性</h3><p>软件的本质特性包括复杂性、一致性、可变性和不可视性。正是由于这种特性，软件分析不是发现更多的功能与需求，而是确认有效的功能与需求。通常情况下，软件范围对于客户和开发者都是模糊的。我们只要在满足客户基本需求的前提下，不断砍去用户不明确的需求，完成基本的功能，然后再根据客户的需求，通过多次迭代完成最终成果。</p><h2 id="2-项目管理实践"><a href="#2-项目管理实践" class="headerlink" title="2. 项目管理实践"></a>2. 项目管理实践</h2><h3 id="看板使用练习"><a href="#看板使用练习" class="headerlink" title="看板使用练习"></a>看板使用练习</h3><p><img src= "/img/loading.gif" data-lazy-src="/assets/1553777438191-0659162.png" alt="1553777438191"></p><h3 id="UML绘图工具练习"><a href="#UML绘图工具练习" class="headerlink" title="UML绘图工具练习"></a>UML绘图工具练习</h3><p>系统分析与设计第三版 184页，<strong>书本截图：</strong></p><p><img src= "/img/loading.gif" data-lazy-src="/assets/1553778500335.png" alt="1553778500335"></p><p><strong>UML图：</strong></p><p>三个类：</p><p><img src= "/img/loading.gif" data-lazy-src="/assets/1553778445453.png" alt="1553778445453"></p><p><img src= "/img/loading.gif" data-lazy-src="/assets/1553778544498.png" alt="1553778544498"></p><p><img src= "/img/loading.gif" data-lazy-src="/assets/1553778554929.png" alt="1553778554929"></p><p>箭头：</p><p><img src= "/img/loading.gif" data-lazy-src="/assets/1553778563401.png" alt="1553778563401"></p><p><img src= "/img/loading.gif" data-lazy-src="/assets/1553778579257.png" alt="1553778579257"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 系分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机专有词汇</title>
      <link href="/SYSU/%E4%B8%93%E4%B8%9A%E8%AF%8D%E6%B1%87/"/>
      <url>/SYSU/%E4%B8%93%E4%B8%9A%E8%AF%8D%E6%B1%87/</url>
      
        <content type="html"><![CDATA[<ul><li><strong>软件工程：</strong>将系统化的、规范化的、可度量的方法应用于软件的开法、运行和维护，即将工程化方法应用于软件。</li><li><strong>中间件（Middleware）：</strong>提供<a href="https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6">系统软件</a>和<a href="https://zh.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E8%BD%AF%E4%BB%B6">应用软件</a>之间连接的软件，以便于<a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6">软件</a>各部件之间的沟通。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS Objective-C Manual</title>
      <link href="/IOS/Objective-C/"/>
      <url>/IOS/Objective-C/</url>
      
        <content type="html"><![CDATA[<p>Object-C通常写作Objective-C或者Obj-C或OC，是根据C语言所衍生出来的语言，继承了C语言的特性，是扩充C的面向对象编程语言。它主要使用于Mac OS X和IOS系统。Objective-C是非常“实际”的语言。它使用一个用C写成、很小的运行库，只会令应用程序的大小增加很小。目前apple绝大多数采用的是Object-C。</p><a id="more"></a> <p>Objective-C代码的文件扩展名</p><ul><li>.h头文件。头文件包含类，类型，函数和常数的声明。</li><li>.m源代码文件。这是典型的源代码文件扩展名，可以包含Objective-C和C代码。 </li><li>.mm源代码文件。带有这种扩展名的源代码文件，除了可以包含Objective-C和C代码以外还可以包含C++代码。仅在你的Objective-C代码中确实需要使用C++类或者特性的时候才用这种扩展名。 </li><li>#import选项和#include选项完全相同，＃import只是它可以确保相同的文件只会被包含一次。</li></ul><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h3><ol><li>预处理程序命令 <code>#import &lt;头文件&gt; </code></li><li>接口 <code>@interface name:NSObject /n内容/n @end </code></li><li>实现  <code>@implement name /n内容/n @end</code></li><li>方法 <code>- (返回类型)name; -(返回类型)name&#123;&#125;</code></li><li>变量 </li><li>声明和表达</li><li>注释 <code>/*...*/或//</code></li></ol><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><p><code>auto</code> <code>else</code> <code>long</code> <code>switch</code> <code>break</code> <code>enum</code> <code>register</code> <code>typedef</code> <code>case</code> <code>extern</code> <code>return</code> <code>union</code> <code>char</code> <code>float</code> <code>shorsst</code> <code>unsigned</code> <code>const</code> <code>for</code> <code>signed</code> <code>void</code> <code>continue</code> <code>goto</code> <code>sizeof</code> <code>volatile</code> <code>default</code> <code>if</code> <code>static</code> <code>while</code> <code>do</code> <code>int</code> <code>struct</code> <code>_Packed</code> <code>double</code> <code>protocol</code> <code>interface</code> <code>implementation</code> <code>NSObject</code> <code>NSInteger</code> <code>NSNumber</code> <code>CGFloat</code> <code>property</code> <code>nonatomic</code> <code>retain</code> <code>strong</code> <code>weak</code> <code>unsafe_unretained</code> <code>readwrite</code> <code>readonly</code> </p><h4 id="基本类型与框架"><a href="#基本类型与框架" class="headerlink" title="基本类型与框架"></a>基本类型与框架</h4><ul><li>标量类型（非对象）：int、float、char、BOOL、NSInteger、NSUInteger、CGFloat</li><li>基本类型有多种方式转化为引用类型</li><li>NSString和基本类型的互转</li><li>NSNumber和基本类型的互转</li><li>NSValue和复杂结构体的互转</li><li>NSString和CString的互转</li><li>字符编码</li><li>NSData</li><li>NSMutableData</li><li>NSNumber</li><li>NSArray/NSMutableArray</li><li>NSDictionary/NSMutableDictionary</li><li>NSSet/NSMutableSet</li><li>NSOrderedSet/NSMutableOrderedSet</li></ul><p><strong>Foundation框架</strong><br>  定义了Objective-C类的基础层。 除了提供一组有用的原始对象类之外，它还引入了几个定义Objective-C语言未涵盖的功能的范例。使用<code>#import &lt;Foundation/NSString.h&gt;</code>之类的东西来导入Objective-C类，为了避免手写导入的类太多，使用<code>#import &lt;Foundation/Foundation.h&gt;</code>导入</p><ol><li>提供一小组基本实用程序类。</li><li>通过为解除分配等事项引入一致的约定，使软件开发更容易。</li><li>支持Unicode字符串，对象持久性和对象分发。</li><li>提供一定程度的操作系统独立性以增强可移植性。</li></ol><p><strong>数据存储</strong><br>NSArray，NSDictionary和NSSet为Objective-C任何类的对象提供存储。</p><p><strong>文本和字符串</strong><br>NSCharacterSet表示NSString和NSScanner类使用的各种字符分组。NSString类表示文本字符串，并提供搜索，组合和比较字符串的方法。 NSScanner对象用于扫描NSString对象中的数字和单词。</p><p><strong>日期和时间</strong><br>NSDate，NSTimeZone和NSCalendar类存储时间和日期并表示日历信息。它们提供了计算日期和时间差异的方法。它们与NSLocale一起提供了以多种格式显示日期和时间以及根据世界中的位置调整时间和日期的方法。</p><p><strong>异常处理</strong><br>异常处理用于处理意外情况，它在Objective-C中提供NSException类对象。</p><p><strong>文件处理</strong><br>文件处理是在NSFileManager类的帮助下完成的。</p><p><strong>URL加载系统</strong><br>一组提供对常见Internet协议访问的类和协议。</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>一般定义形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">-(return_type)method_name:(argumentType1 )argumentName1 joiningArgument2:(argumentType2 )argumentName2 ...joiningArgumentn:(argumentTypen )argumentNamen &#123;body of the function&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>返回类型</strong>- 方法可以返回值。<code>return_type</code>是函数返回的值的数据类型。 某些方法执行所需的操作而不返回值。 在这种情况下，<code>return_type</code>是关键字<code>void</code>。</li><li><strong>方法名称</strong>- 这是方法的名称。方法名称和参数列表一起构成方法签名。</li><li><strong>参数</strong>- 调用函数时，将值传递给参数。参数列表指的是方法的参数的类型，顺序和数量。参数是可选的。<strong>按值调用：</strong>将参数的实际值复制到函数的形式参数中，对函数内部参数所做的更改不会对参数产生影响。 <strong>按引用调用</strong>将参数的地址复制到形式参数中。在函数内部，该地址用于访问调用中使用的实际参数。对参数所做的更改会影响参数。</li><li><strong>连接参数</strong>- 一个连接的参数是让它更易于阅读并在调用时清楚地表达它。</li><li><strong>方法体</strong>- 方法体包含一组语句用于定义方法的作用。</li></ul><h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><p>块定义了一个将数据与相关行为相结合的对象，块是Objective-C对象，因此它们可以添加到<code>NSArray</code>或<code>NSDictionary</code>等集合中。 它们还能够从封闭范围中捕获值，使其类似于其他编程语言中的闭包或<code>lambda</code>。一般形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">&lt;returntype&gt; (^blockname)(list of arguments);&#x2F;&#x2F;定义<br>&#x2F;&#x2F;实现<br>&lt;returntype&gt; (^blockname)(list of arguments) &#x3D; ^(arguments)&#123; body; &#125;;&#x2F;&#x2F;有参数<br>void (^theBlock)(void) &#x3D; ^&#123; printf(&quot;Hello Blocks!\n&quot;); &#125;;&#x2F;&#x2F;无参数<br>&#x2F;&#x2F;例子<br>double (^multiplyTwoValues)(double, double) &#x3D; <br>   ^(double firstValue, double secondValue) &#123;<br>      return firstValue * secondValue;<br>   &#125;;<br></code></pre></td></tr></table></figure><ul><li>block属性</li><li>block用于循环</li><li>block用于异步任务</li><li>block常见的内存泄露场景</li></ul><h4 id="数组、字符串、指针"><a href="#数组、字符串、指针" class="headerlink" title="数组、字符串、指针"></a>数组、字符串、指针</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-comment">//数组声明</span><br>type arrayName [ arraySize ];<br>type name[size1][size2]...[sizeN];<span class="hljs-comment">//多维数组</span><br><span class="hljs-comment">//初始化数组</span><br><span class="hljs-keyword">double</span> balance[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1000.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.4</span>, <span class="hljs-number">17.0</span>, <span class="hljs-number">50.0</span>&#125;;<br><span class="hljs-keyword">double</span> balance[] = &#123;<span class="hljs-number">1000.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.4</span>, <span class="hljs-number">17.0</span>, <span class="hljs-number">50.0</span>&#125;;<br><span class="hljs-comment">//访问数组</span><br><span class="hljs-keyword">double</span> salary = balance[<span class="hljs-number">9</span>];<br><span class="hljs-comment">//快速枚举遍历数组</span><br><span class="hljs-keyword">for</span> (classType variable <span class="hljs-keyword">in</span> collectionObject ) &#123; <br>  statements <br>&#125;<br><span class="hljs-comment">//快速枚举向后</span><br><span class="hljs-keyword">for</span> (classType variable <span class="hljs-keyword">in</span> [collectionObject reverseObjectEnumerator] ) &#123; <br>  statements <br>&#125;<br><span class="hljs-comment">//指针递增递减</span><br>ptr++ ptr--;<br><span class="hljs-comment">//指针比较 如果p1和p2指向彼此相关的变量，例如同一数组的元素，则可以有意义地比较指针</span><br>ptr &lt;= &amp;var[MAX - <span class="hljs-number">1</span>]<br><span class="hljs-comment">//字符串 字符串使用NSString表示，其子类NSMutableString提供了几种创建字符串对象的方法。 创建字符串对象的最简单方法是使用Objective-C的标识符：@&quot;&quot;来构造</span><br><span class="hljs-built_in">NSString</span> *greeting = <span class="hljs-string">@&quot;Hello&quot;</span>;<br><br>- (<span class="hljs-built_in">NSString</span> *)capitalizedString;<br>返回接收者的大写字母表示。<br>- (<span class="hljs-keyword">unichar</span>)characterAtIndex:(<span class="hljs-built_in">NSUInteger</span>)index;<br>返回给定数组位置的字符。<br>- (<span class="hljs-keyword">double</span>)doubleValue;<br>以<span class="hljs-keyword">double</span>形式返回接收者文本的浮点值。<br>- (<span class="hljs-keyword">float</span>)floatValue;<br>以<span class="hljs-keyword">float</span>形式返回接收者文本的浮点值<br>- (<span class="hljs-built_in">BOOL</span>)isEqualToString:(<span class="hljs-built_in">NSString</span> *)aString;<br>返回一个布尔值，该值使用基于Unicode的文字比较指示给定字符串是否等于接收者。<br>- (<span class="hljs-built_in">NSUInteger</span>)length;<br>返回接收者中的Unicode字符数。 <br>stringByAppendingFormat<br>连接str1和str2 <br></code></pre></td></tr></table></figure><h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-keyword">struct</span> [structure tag] &#123;<br>   member definition;<br>   member definition;<br>   ...<br>   member definition;<br>&#125; [one or more structure variables];<br></code></pre></td></tr></table></figure><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objc"><span class="hljs-built_in">NSString</span> *domain = <span class="hljs-string">@&quot;com.yiibai.MyApplication.ErrorDomain&quot;</span>;<br><span class="hljs-built_in">NSString</span> *desc = <span class="hljs-built_in">NSLocalizedString</span>(<span class="hljs-string">@&quot;Unable to complete the process&quot;</span>, <span class="hljs-string">@&quot;&quot;</span>);<br><span class="hljs-built_in">NSDictionary</span> *userInfo = @&#123; <span class="hljs-built_in">NSLocalizedDescriptionKey</span> : desc &#125;;<br><span class="hljs-built_in">NSError</span> *error = [<span class="hljs-built_in">NSError</span> errorWithDomain:domain code:<span class="hljs-number">-101</span> userInfo:userInfo];<br></code></pre></td></tr></table></figure><h2 id="高级部分"><a href="#高级部分" class="headerlink" title="高级部分"></a>高级部分</h2><h3 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h3><h4 id="Objective-C特征"><a href="#Objective-C特征" class="headerlink" title="Objective-C特征"></a>Objective-C特征</h4><ul><li>类定义在两个不同的部分，即<code>@interface</code>和<code>@implementation</code>。</li><li>几乎所有东西都是对象的形式。</li><li>对象接收消息，对象通常称为接收者。</li><li>对象包含实例变量。</li><li>对象和实例变量具有范围。</li><li>类隐藏对象的实现。</li><li>属性用于提供用于其他类对此类实例变量的访问。</li></ul><h4 id="类定义实现"><a href="#类定义实现" class="headerlink" title="类定义实现"></a>类定义实现</h4><p>类定义以关键字<code>@interface</code>开头，后跟接口(类)名称; 和一个由一对花括号括起来的类体。 在Objective-C中，所有类都派生自名为<code>NSObject</code>的基类。 它是所有Objective-C类的超类。 它提供了内存分配和初始化等基本方法。 </p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@interface Box:NSObject &#123;<br>   &#x2F;&#x2F;实例变量<br>   double length;    &#x2F;&#x2F; Length of a box<br>   double breadth;   &#x2F;&#x2F; Breadth of a box<br>   double height;    &#x2F;&#x2F; Height of a box<br>&#125;<br>@property(nonatomic, readwrite) double height;  &#x2F;&#x2F; Property<br>@end<br>  <br>@implementation Box<br>@synthesize height; <br><br>-(id)init &#123;<br>   self &#x3D; [super init];<br>   length &#x3D; 1.0;<br>   breadth &#x3D; 1.0;<br>   return self;<br>&#125;<br><br>-(double) volume &#123;<br>   return length*breadth*height;<br>&#125;<br>@end<br></code></pre></td></tr></table></figure><h4 id="类初始化和访问"><a href="#类初始化和访问" class="headerlink" title="类初始化和访问"></a>类初始化和访问</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">Box box1 &#x3D; [[Box alloc]init];<br>box1.height &#x3D; 15.0<br></code></pre></td></tr></table></figure><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>在Objective-C中引入了属性，以确保可以在类外部访问类的实例变量，只有属性才能访问类的实例变量。 实际上，为属性创建了内部<code>getter</code>和<code>setter</code>方法。</p><ul><li>属性以<code>@property</code>开头，它是一个关键字</li><li>接下来是访问说明符，它们是非原子，读写或只读，强，不安全或不完整。 这取决于变量的类型。 对于任何指针类型，可以使用<code>strong</code>，<code>unsafe_unretained</code>或<code>weak</code>。 类似地，对于其他类型，可以使用<code>readwrite</code>或<code>readonly</code>。</li><li>接下来是变量的数据类型。</li><li>最后，将属性名称以分号结束。</li><li>在实现类中添加<code>synthesize</code>语句。 但是在最新的<code>XCode</code>中，合成部分由<code>XCode</code>处理，不需要包含<code>synthesize</code>语句。</li></ul><h5 id="synthesize"><a href="#synthesize" class="headerlink" title="@synthesize"></a>@synthesize</h5><p>该关键字指定了属性的实例变量名称，并且根据存储语义（readwrite、readonly）系统自动合成setter和getter方法，当然也可以手写来覆盖系统提供的。</p><h5 id="dynamic"><a href="#dynamic" class="headerlink" title="@dynamic"></a>@dynamic</h5><p>该关键字告诉编译器不要为我合成setter和getter方法，这些方法将由我自己实现。当然我们可以不实现这在编译阶段不会出现问题，直到运行时才会检查是否实现了setter和getter，如果没有实现就会抛出异常。</p><h4 id="属性的特质："><a href="#属性的特质：" class="headerlink" title="属性的特质："></a><strong>属性的特质：</strong></h4><p>1.原子性：</p><p>　　原子性就是指该属性是否为同步的，OC中大部分属性都是nonatomic（非原子性）的，如果不写nonatomic那么就会是原子性的。理论上来说原子性属性的读写都将会是同步的，但是OC中atomic并不能一定确定属性为同步的，如果真要进行同步操作，还要用更加深层次的同步锁API。而且atomic会很影响效率，所以一般都会写nonatomic。</p><p>2.读/写权限：</p><p>　　读写为readonly和readwrite两种，前一种在系统只会合成getter方法，而后一种则会同时生成setter和getter。如果属性设置为了readonly属性，那么该属性是不可以修改的。</p><p>3.内存管理语义：</p><p>　　assign：该方法只会针对“纯量类型”(CGFloat或NSInteger等)的简单赋值操作，id类型也要用assign，所以一般iOS中的代理delegate属性都会用assign来标示，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@property (nonatomic, assign)   id &lt;UITableViewDataSource&gt; dataSource;<br>@property (nonatomic, assign)   id &lt;UITableViewDelegate&gt;   delegate;<br></code></pre></td></tr></table></figure><p>　　strong: 使用该特性实例变量在赋值时，会释放旧值同时设置新值，对对象产生一个强引用，用MRC来说就是引用计数+1。</p><p>　　weak: 属性表明了一种”非拥有关系“，既不释放旧值，也不保留新值。用MRC就是引用计数不变，当指向的对象被释放时，该属性自动被设置为nil。这里多说一点，weak的runtime实现是通过hash表完成的，用变量名做键，一旦发现属性所指的对象被释放了，立刻设置为nil。</p><p>　　unsafe_unretained：和weak一样，唯一的区别就是当对象被释放后，该属性不会被设置为nil。所以是unsafe的。</p><p>　　copy：和strong类似，不过该属性会被复制一个新的副本。很多时使用copy是为了方式Mutable（可变类型）在我们不知道的情况下修改了属性值，而用copy可以生成一个不可变的副本防止被修改。如果我们自己实现setter方法的话，需要手动copy。</p><p>4.方法名：方法名可以修改为我们合成的方法名，可以使存取方法语义更加符合应用场景。　</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">getter &#x3D; &lt;name&gt;<br>setter &#x3D; &lt;name&gt;<br></code></pre></td></tr></table></figure><h3 id="继承与多态"><a href="#继承与多态" class="headerlink" title="继承与多态"></a>继承与多态</h3><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>Objective-C只允许多级继承，即它只能有一个基类但允许多级继承。 Objective-C中的所有类都派生自超类<code>NSObject</code>。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">@interfacederived-<span class="hljs-keyword">class</span>:base-<span class="hljs-keyword">class</span><br></code></pre></td></tr></table></figure><p>如果派生类在接口类中定义，则它可以访问其基类的所有私有成员，但它不能访问在实现文件中定义的私有成员。派生类继承所有基类在声明中方法和变量</p><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>Objective-C多态表示对成员函数的调用将导致执行不同的函数，具体取决于调用该函数的对象的类型。在使用多态是，会进行动态检测，以调用真实的对象方法。多态在代码中的体现即父类指针指向子类对象。子类必须重写父类的方法</p><ul><li>好处：如果函数方法参数中使用的是父类类型，则可以传入父类和子类对象，而不用再去定义多个函数来和相应的类进行匹配了。</li><li>局限性：父类类型的变量不能直接调用子类特有的方法，如果必须要调用，则必须强制转换为子类特有的方法。</li></ul><p>代码例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@interface Shape : NSObject &#123;<br>   CGFloat area;<br>&#125;<br><br>- (void)printArea;<br>- (void)calculateArea;<br>@end<br><br>@implementation Shape<br>- (void)printArea &#123;<br>   NSLog(@&quot;The area is %f&quot;, area);<br>&#125;<br><br>- (void)calculateArea &#123;<br><br>&#125;<br><br>@end<br><br>@interface Square : Shape &#123;<br>   CGFloat length;<br>&#125;<br><br>- (id)initWithSide:(CGFloat)side;<br>- (void)calculateArea;<br><br>@end<br><br>@implementation Square<br>- (id)initWithSide:(CGFloat)side &#123;<br>   length &#x3D; side;<br>   return self;<br>&#125;<br><br>- (void)calculateArea &#123;<br>   area &#x3D; length * length;<br>&#125;<br><br>- (void)printArea &#123;<br>   NSLog(@&quot;The area of square is %f&quot;, area);<br>&#125;<br><br>@end<br><br>@interface Rectangle : Shape &#123;<br>   CGFloat length;<br>   CGFloat breadth;<br>&#125;<br><br>- (id)initWithLength:(CGFloat)rLength andBreadth:(CGFloat)rBreadth;<br>@end<br><br>@implementation Rectangle<br>- (id)initWithLength:(CGFloat)rLength andBreadth:(CGFloat)rBreadth &#123;<br>   length &#x3D; rLength;<br>   breadth &#x3D; rBreadth;<br>   return self;<br>&#125;<br><br>- (void)calculateArea &#123;<br>   area &#x3D; length * breadth;<br>&#125;<br><br>@end<br><br>int main(int argc, const char * argv[]) &#123;<br>   NSAutoreleasePool * pool &#x3D; [[NSAutoreleasePool alloc] init];<br>   Shape *square &#x3D; [[Square alloc]initWithSide:10.0];<br>   [square calculateArea];<br>   [square printArea];<br>   Shape *rect &#x3D; [[Rectangle alloc]<br>   initWithLength:10.0 andBreadth:5.0];<br>   [rect calculateArea];<br>   [rect printArea];        <br>   [pool drain];<br>   return 0;<br>&#125;<br>&#x2F;&#x2F;output<br>2018-11-16 02:02:22.096 main[159689] The area of square is 100.000000<br>2018-11-16 02:02:22.098 main[159689] The area is 50.000000<br></code></pre></td></tr></table></figure><h3 id="类别、类拓展"><a href="#类别、类拓展" class="headerlink" title="类别、类拓展"></a>类别、类拓展</h3><h4 id="类别Category"><a href="#类别Category" class="headerlink" title="类别Category"></a><strong>类别</strong>Category</h4><p>常用于给已知的类（Class）增加行为，注意类别会有隐式重名冲突的问题。当你已经封装好了一个类（也可能是系统类、第三方库），不想在改动这个类了，可是随着程序功能的增加需要在类中增加一个方法，这时我们不必修改主类，只需要给你原来的类增加一个分类。将一个大型的类拆分成不同的分类，在不同分类中实现类别声明的方法，这样可以将一个类的实现写到多个.m文件中，方便管理和协同开发。分类中的方法可以只声明，不实现，所以在协议不支持可选方法的时候（协议现在已经支持可选方法），通常把分类作为非正式协议使用。添加属性和成员变量的一种常见的办法是通过runtime.h中objc_getAssociatedObject / objc_setAssociatedObject来访问和生成关联对象。通过这种方法来模拟生成属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@interface XYZPerson (XYZPersonNameDisplayAdditions) <br>-(NSString *)lastNameFirstNameString; <br>@end<br></code></pre></td></tr></table></figure><ul><li>分类中方法的优先级比原来类中的方法高，也就是说，在分类中重写了原来类中的方法，那么分类中的方法会覆盖原来类中的方法</li><li>分类中只能声明方法，不能添加属性变量，在运行时分类中的方法与主类中的方法没有区别。</li><li>通常来讲，分类定义在.h文件中，但也可以定义.m文件中，此时分类的方法就变成私有方法</li></ul><h4 id="拓展Extension"><a href="#拓展Extension" class="headerlink" title="拓展Extension"></a>拓展Extension</h4><p>扩展是分类的一种特殊形式。拓展作用：</p><p>1.能为某个类附加额外的属性，成员变量，方法声明<br>2.一般的将类扩展直接写在.m文件中，而不单独建立类扩展文件<br>3.一般的私有属性和方法写到类扩展<br>4.和类别相似，但是小括号里面没有扩展的名字，就像匿名的类别</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@interface 主类类名（）<br>@end<br></code></pre></td></tr></table></figure><p>扩展通常定义在主类.m文件中，扩展中声明的方法直接在主类.m文件中实现。</p><p><strong>局限性：</strong></p><ul><li><p>不能为任何类声明扩展，仅适用于原始实现源代码的类。</p></li><li><p>扩展是添加仅特定于类的私有方法和私有变量。</p></li><li><p>扩展内部声明的任何方法或变量即使对于继承的类也是不可访问的。</p></li></ul><h4 id="类别和扩展的区别"><a href="#类别和扩展的区别" class="headerlink" title="类别和扩展的区别"></a><strong>类别和扩展的区别</strong></h4><ul><li>需不需要源码</li><li>能不能增加属性</li><li>分类是不可以声明实例变量，通常是公开的，文件名是：主类名+分类名.h</li><li>扩展是可以声明实例变量，是私有的，文件名为：主类名_扩展标识.h，在主类的.m文件中#import该头文件</li></ul><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>protocol协议的<strong>基本用途</strong>：</p><ol><li>可以用来声明一大堆方法（不能声明成员变量）</li><li>只要某个类遵守了这个协议，就相当于拥有了这个协议中的所有方法声明。</li><li>只要父类遵守了某个协议，就相当于子类也遵守了。</li></ol><p>注意：协议内仅仅写方法声明，不能写实现，不能写成员变量</p><p>对协议的简单理解：</p><ol><li><p>protocol声明的方法可以交给任何类去实现。</p></li><li><p>protocol的作用仅仅就是声明方法，所以新建协议就是.h文件。</p></li><li><p>@protocol关键字表示声明协议，同样以@end结尾。例如：@protocol  MyProtocol@end</p></li><li><p>@protocol声明的方法要交给类去实现，即类遵守协议。也就是说只要类遵守了这个协议，就相当于拥有了这个协议内的所有方法声明。（协议仅仅用来声明方法，以交给多个类去实现（去遵守））</p></li><li><p>协议与分类一样只能写方法，不能声明成员变量。但是和分类不同的是协议只能写方法声明，分类是给某个类扩充一些方法</p></li><li><p>协议遵守协议</p><p>（1）一个类可以继承别的类，同样协议也可以遵守协议。</p><p>（2）一个协议可以遵守多个协议，多个协议之间用逗号隔开</p><p>（3）一个协议遵守了其他协议，就相当于拥有了其他协议中的所有方法声明。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">1&gt; 类遵守协议<br>@interface 类名：父类名 &lt;协议名称1，协议名称2&gt;<br><br>@end;<br>2&gt; 协议遵守协议<br>@protocol 协议名称 &lt;其他协议名称1，其他协议名称2&gt;<br>&#x2F;&#x2F;方法声明列表,,,,<br>@end<br>3&gt; 协议中方法声明的关键字<br>1&gt;@required（默认） 要求实现，若没实现，将出现警告。<br>2&gt;@optional    不要求实现，实不实现都不会有警告。<br><br></code></pre></td></tr></table></figure><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>Objective-C内存管理技术大致可分为两类 - </p><ul><li>“手动保留或释放”或MRR</li><li>“自动参考计数”或ARC</li></ul><p>在MRR中，通过跟踪自己的对象来明确管理内存。这是使用一个称为引用计数的模型实现的，<code>Foundation</code>类<code>NSObject</code>与运行时环境一起提供。MRR和ARC之间的唯一区别是保留和释放，前者是手动处理，而后者则自动处理。</p><h4 id="MRR基本规则"><a href="#MRR基本规则" class="headerlink" title="MRR基本规则"></a>MRR基本规则</h4><ul><li>拥有创建的任何对象：使用名称以“alloc”，“new”，“copy”或“mutableCopy”开头的方法创建对象</li><li>使用<code>retain</code>获取对象的所有权：通常保证接收到的对象在接收到的方法中保持有效，并且该方法也可以安全地将对象返回给它的调用者。在两种情况下使用<code>retain</code>-<ul><li>在访问器方法或<code>init</code>方法的实现中，获取想要存储为对象属性值的对象的所有权。</li><li>防止对象因某些其他操作的副作用而失效。</li></ul></li><li>当不再需要它时，必须放弃对拥有的对象的所有权：通过向对象发送释放消息或自动释放消息来放弃对象的所有权。 因此，在Cocoa术语中，放弃对象的所有权通常被称为“释放”对象。</li><li>不得放弃不拥有的对象的所有权。</li></ul><h4 id="“自动参考计数”或ARC"><a href="#“自动参考计数”或ARC" class="headerlink" title="“自动参考计数”或ARC"></a>“自动参考计数”或ARC</h4><p>在自动引用计数或ARC中，系统使用与MRR相同的引用计数系统，但它在编译时为我们插入适当的内存管理方法调用。 强烈建议将ARC用于新项目。 如果使用ARC，通常不需要理解本文档中描述的底层实现，尽管在某些情况下它可能会有所帮助。 </p><p>如上所述，在ARC中，不需要添加<code>release</code>和<code>retain</code>方法，因为编译器会对此进行处理。 实际上，Objective-C的基本过程仍然是相同的。 它在内部使用保留和释放操作，使开发人员更容易编码而无需担心这些操作，这将减少写入的代码量和内存泄漏的可能性。</p><p>还有另一个原则叫做垃圾收集，它在Mac OS-X中与MRR一起使用，但由于它在OS-X Mountain Lion中的弃用，它还没有与MRR一起讨论过。 此外，iOS对象从未拥有垃圾收集功能。 使用ARC，OS-X中也没有使用垃圾收集。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Objective-C </tag>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS Objective-C 面试知识整理</title>
      <link href="/IOS/Objective-C%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
      <url>/IOS/Objective-C%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="Objective-C-基础"><a href="#Objective-C-基础" class="headerlink" title="Objective-C 基础"></a>Objective-C 基础</h2><h3 id="对象方法和类方法的区别"><a href="#对象方法和类方法的区别" class="headerlink" title="对象方法和类方法的区别?"></a>对象方法和类方法的区别?</h3><ul><li>对象方法：以减号开头,只可以被对象调用，可以访问成员变量</li><li>类方法：以加号开头只能用类名调用，对象不可以调用，类方法不能访问成员变量</li></ul><h3 id="什么是分类"><a href="#什么是分类" class="headerlink" title="什么是分类?"></a>什么是分类?</h3><ul><li>分类: 在不修改原有类代码的情况下,可以给类添加方法<br>Categroy 给类扩展方法,或者关联属性, Categroy底层结构也是一个结构体:内部存储这结构体的名字,那个类的分类,以及对象和类方法列表,协议,属性信息</li><li>通过Runtime加载某个类的所有Category数据</li><li>把所有Category的方法、属性、协议数据，合并到一个大数组中后面参与编译的Category数据，会在数组的前面</li><li>将合并后的分类数据（方法、属性、协议），插入到类原来数据的前面</li></ul><h3 id="什么是协议"><a href="#什么是协议" class="headerlink" title="什么是协议?"></a>什么是协议?</h3><ul><li>协议：协议是一套标准，这个标准中声明了很多方法，但是不关心具体这些方法是怎么实现的，具体实现是由遵循这个协议的类去完成的。</li><li>在OC中，一个类可以实现多个协议，通过协议可以弥补单继承的缺陷但是协议跟继承不一样，协议只是一个方法列表，方法的实现得靠遵循这个协议的类去实现。</li></ul><h3 id="为什么说OC是一门动态语言？"><a href="#为什么说OC是一门动态语言？" class="headerlink" title="为什么说OC是一门动态语言？"></a>为什么说OC是一门动态语言？</h3><ul><li>动态语言:是指程序在运行时可以改变其结构，新的函数可以被引进,已有的函数可以被删除等在结构上的变化</li><li>动态类型语言: 就是类型的检查是在运行时做的。</li></ul><p>OC的动态特性可从三方面:</p><ul><li>动态类型（Dynamic typing）：最终判定该类的实例类型是在运行期间</li><li>动态绑定（Dynamic binding）：在运行时确定调用的方法</li><li>动态加载（Dynamic loading）：在运行期间加载需要的资源或可执行代码</li></ul><h3 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h3><ul><li>动态绑定 将调用方法的确定也推迟到运行时。OC可以先跳过编译，到运行的时候才动态地添加函数调用，在运行时才决定要调用什么方法，需要传什么参数进去，这就是动态绑定。</li><li>在编译时，方法的调用并不和代码绑定在一起，只有在消息发送出来之后，才确定被调用的代码。</li></ul><h3 id="cocoa-touch底层技术架构"><a href="#cocoa-touch底层技术架构" class="headerlink" title="cocoa touch底层技术架构?"></a>cocoa touch底层技术架构?</h3><p>cocoa touch底层技术架构 主要分为4层:</p><ul><li>可触摸层 Cocoa Touch : UI组件,触摸事件和事件驱动,系统接口</li><li>媒体层 Media: 音视频播放,动画,2D和3D图形</li><li>Core Server: 核心服务层,底层特性,文件,网络,位置服务区等</li><li>Core OS: 内存管理,底层网络,硬盘管理</li></ul><h3 id="什么是谓词"><a href="#什么是谓词" class="headerlink" title="什么是谓词?"></a>什么是谓词?</h3><p>谓词(<code>NSPredicate</code>)是OC针对数据集合的一种逻辑帅选条件,类似一个过滤器,简单实实用代码如下:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">Person * p1 = [Person personWithName:<span class="hljs-string">@&quot;alex&quot;</span> Age:<span class="hljs-number">20</span>];<br>Person * p2 = [Person personWithName:<span class="hljs-string">@&quot;alex1&quot;</span> Age:<span class="hljs-number">30</span>];<br>Person * p3 = [Person personWithName:<span class="hljs-string">@&quot;alex2&quot;</span> Age:<span class="hljs-number">10</span>];<br>Person * p4 = [Person personWithName:<span class="hljs-string">@&quot;alex3&quot;</span> Age:<span class="hljs-number">40</span>];<br>Person * p5 = [Person personWithName:<span class="hljs-string">@&quot;alex4&quot;</span> Age:<span class="hljs-number">80</span>];<br>    <br><span class="hljs-built_in">NSArray</span> * persons = @[p1, p2, p3, p4, p5];<br><span class="hljs-comment">//定义谓词对象,谓词对象中包含了过滤条件</span><br><span class="hljs-built_in">NSPredicate</span> *predicate = [<span class="hljs-built_in">NSPredicate</span> predicateWithFormat:<span class="hljs-string">@&quot;age &lt; 30&quot;</span>];<br><span class="hljs-comment">//使用谓词条件过滤数组中的元素,过滤之后返回查询的结果</span><br><span class="hljs-built_in">NSArray</span> *array = [persons filteredArrayUsingPredicate:predicate];<br></code></pre></td></tr></table></figure><h3 id="什么是类工厂方法"><a href="#什么是类工厂方法" class="headerlink" title="什么是类工厂方法?"></a>什么是类工厂方法?</h3><p>类工厂方法就是用来快速创建对象的类方法, 他可以直接返回一个初始化好的对象,具备以下特征:</p><ol><li>一定是类方法</li><li>返回值需要是 id/instancetype 类型</li><li>规范的方法名说说明类工厂方法返回的是一个什么对象,一般以类名首字母小写开始;</li></ol><p>比如系统 UIButton 的buttonWithType 就是一个类工厂方法:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// 类工厂方法</span><br>+ (<span class="hljs-keyword">instancetype</span>)buttonWithType:(<span class="hljs-built_in">UIButtonType</span>)buttonType;<br><span class="hljs-comment">// 使用</span><br>+ <span class="hljs-built_in">UIButton</span> * button = [<span class="hljs-built_in">UIButton</span> buttonWithType:<span class="hljs-built_in">UIButtonTypeCustom</span>];<br></code></pre></td></tr></table></figure><h3 id="Svn-和-Git-区别"><a href="#Svn-和-Git-区别" class="headerlink" title="Svn 和 Git 区别"></a>Svn 和 Git 区别</h3><ul><li>svn 和 git 都是用来对项目进行版本控制以及代码管理的.可以监测代码及资源的更改变化.有利于实现高效的团队合作;</li><li>svn 是集中式的,集中式是指只有一个远程版本库,git 是分布式的,分布式有本地和远程版本库,本地仓库都保留了整个项目的完整备份;<br>如果存储远程版本库的服务器挂了，所有人的代码都无法提交，甚至丢失版本库, git则因为有本地版本库而不会有这个问题。</li><li>由于两者的架构不同,git 和 svn 的分支也是不同的, svn 的分支是一个完整的目录,包含所有的实际文件,和中心仓库是保持同步的,如果某个团队成员创建新的分支,那么会同步到所有的版本成员中,所有人都会收到影响. 而 git下创建的分支合并前是不会影响到任何人的.创建分支可以在本地脱机进行任何操作.测试无误后在合并到主分支,然后其他成员才可以看得到.</li></ul><h3 id="CocoaPods理解"><a href="#CocoaPods理解" class="headerlink" title="CocoaPods理解"></a>CocoaPods理解</h3><p>CocoaPods 是一个 objc 的依赖管理工具，而其本身是利用 ruby 的依赖管理 gem 进行构建的</p><ul><li>想深入了解这个命令执行的详细内容，可以在这个命令后面加上 –verbose。现在运行这个命令 pod install –verbose</li><li>CocoaPod三方库,会优先编译</li></ul><h3 id="–verbose-和-–no-repo-update有什么用"><a href="#–verbose-和-–no-repo-update有什么用" class="headerlink" title="–verbose 和 –no-repo-update有什么用?"></a>–verbose 和 –no-repo-update有什么用?</h3><ul><li>verbose意思为 冗长的、啰嗦的，一般在程序中表示详细信息。此参数可以显示命令执行过程中都发生了什么。</li><li>pod install或pod update可能会卡在Analyzing dependencies步骤，因为这两个命令会升级 CocoaPods 的 spec 仓库，追加该参数可以省略此步骤，命令执行速度会提升。</li></ul><h3 id="简要说明const-宏-static-extern区分以及使用"><a href="#简要说明const-宏-static-extern区分以及使用" class="headerlink" title="简要说明const,宏,static,extern区分以及使用?"></a>简要说明const,宏,static,extern区分以及使用?</h3><p><strong>const</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span>常量修饰符,经常使用的字符串常量，一般是抽成宏，但是苹果不推荐我们抽成宏，推荐我们使用<span class="hljs-keyword">const</span>常量。<br><br>- <span class="hljs-keyword">const</span> 作用：限制类型<br>- 使用<span class="hljs-keyword">const</span>修饰基本变量, 两种写法效果一致 , b都是只读变量<br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> b = <span class="hljs-number">5</span>; <br>  <span class="hljs-keyword">int</span> <span class="hljs-keyword">const</span> b = <span class="hljs-number">5</span>;   <br>- 使用<span class="hljs-keyword">const</span>修饰指针变量的变量 <br>  第一种: <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *p = &amp;a 和 <span class="hljs-keyword">int</span> <span class="hljs-keyword">const</span> *q = &amp;a; 效果一致,*p 的值不能改,p 的指向可以改; <br>  第二种: <span class="hljs-keyword">int</span> * <span class="hljs-keyword">const</span> p = &amp;a;  表示 p 的指向不能改,*p 的值可以改<br>  第三种: <br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> * <span class="hljs-keyword">const</span> p = &amp;a; *p 值和 p 的指向都不能改<br>  <br>  <span class="hljs-keyword">const</span> 在*左边, 指向可变, 值不可变<br>  <span class="hljs-keyword">const</span> 在*的右边, 指向不可变, 值可变<br>  <span class="hljs-keyword">const</span> 在*的两边, 都不可变<br></code></pre></td></tr></table></figure><p><strong>宏</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">* 基本概念：宏是一种批量处理的称谓。一般说来，宏是一种规则或模式，或称语法替换 ，用于说明某一特定输入（通常是字符串）如何根据预定义的规则转换成对应的输出（通常也是字符串)。这种替换在预编译时进行，称作宏展开。编译器会在编译前扫描代码，如果遇到我们已经定义好的宏那么就会进行代码替换，宏只会在内存中<span class="hljs-built_in">copy</span>一份，然后全局替换，宏一般分为对象宏和函数宏。 宏的弊端：如果代码中大量的使用宏会使预编译时间变长。<br><br><span class="hljs-keyword">const</span>与宏的区别？<br><br>* 编译检查 宏没有编译检查，<span class="hljs-keyword">const</span>有编译检查；<br>* 宏的好处 定义函数，方法 <span class="hljs-keyword">const</span>不可以；<br>* 宏的坏处 大量使用宏，会导致预编译时间过长<br></code></pre></td></tr></table></figure><p><strong>static</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">* 修饰局部变量: 被<span class="hljs-keyword">static</span>修饰局部变量，延长生命周期，跟整个应用程序有关，程序结束才会销毁,被 <span class="hljs-keyword">static</span> 修饰局部变量，只会分配一次内存<br>* 修饰全局变量: 被<span class="hljs-keyword">static</span>修饰全局变量，作用域会修改，也就是只能在当前文件下使用<br></code></pre></td></tr></table></figure><p><strong>extern</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs objectivec">声明外部全局变量(只能用于声明，不能用于定义)<br><br>常用用法（.h结合<span class="hljs-keyword">extern</span>联合使用）<br>如果在.h文件中声明了<span class="hljs-keyword">extern</span>全局变量，那么在同一个类中的.m文件对全局变量的赋值必须是：数据类型+变量名（与声明一致）=XXXX结构。并且在调用的时候，必须导入.h文件。代码如下：<br><br>.h<br><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">ExternModel</span> : <span class="hljs-title">NSObject</span></span><br><span class="hljs-keyword">extern</span> <span class="hljs-built_in">NSString</span> *lhString;<br><span class="hljs-keyword">@end</span> <br>.m     <br><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">ExternModel</span></span><br><span class="hljs-built_in">NSString</span> *lhString=<span class="hljs-string">@&quot;hello&quot;</span>;<br><span class="hljs-keyword">@end</span><br><br>调用的时候：例如：在viewController.m中调用，则可以引入：ExternModel.h，否则无法识别全局变量。当然也可以通过不导入头文件的方式进行调用（通过<span class="hljs-keyword">extern</span>调用）。<br></code></pre></td></tr></table></figure><h3 id="编译型和解释型的区别"><a href="#编译型和解释型的区别" class="headerlink" title="编译型和解释型的区别?"></a>编译型和解释型的区别?</h3><ul><li>编译型语言: 首先是将源代码编译生成机器指令，再由机器运行机器码 (二进制)。</li><li>解释型语言: 源代码不是直接翻译成机器指令，而是先翻译成中间代码，再由解释器对中间代码进行解释运行。</li></ul><h3 id="动态语言和静态语言"><a href="#动态语言和静态语言" class="headerlink" title="动态语言和静态语言?"></a>动态语言和静态语言?</h3><ul><li>动态类型语言: 是指数据类型的检查是在运行时做的。用动态类型语言编程时，不用给变量指定数据类型，该语言会在你第一次赋值给变量时，在内部记录数据类型。</li><li>静态类型语言: 是指数据类型的检查是在运行前（如编译阶段）做的。</li></ul><h3 id="什么是指针常量和常量指针？"><a href="#什么是指针常量和常量指针？" class="headerlink" title="什么是指针常量和常量指针？"></a>什么是指针常量和常量指针？</h3><h4 id="指针常量——指针类型的常量（int-const-p）"><a href="#指针常量——指针类型的常量（int-const-p）" class="headerlink" title="指针常量——指针类型的常量（int *const p）"></a>指针常量——指针类型的常量（int *const p）</h4><p>本质上一个常量，指针用来说明常量的类型，表示该常量是一个指针类型的常量。<strong>在指针常量中，指针自身的值是一个常量，不可改变，始终指向同一个地址。在定义的同时必须初始化。</strong>用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">int a &#x3D; 10, b &#x3D; 20;<br>int * const p &#x3D; &amp;a;<br>*p &#x3D; 30; &#x2F;&#x2F; p指向的地址是一定的，但其内容可以修改<br></code></pre></td></tr></table></figure><h4 id="常量指针——指向“常量”的指针（const-int-p，-int-const-p）"><a href="#常量指针——指向“常量”的指针（const-int-p，-int-const-p）" class="headerlink" title="常量指针——指向“常量”的指针（const int *p， int const *p）"></a>常量指针——指向“常量”的指针（const int *p， int const *p）</h4><p>常量指针本质上是一个指针，常量表示指针指向的内容，说明该指针指向一个“常量”。<strong>在常量指针中，指针指向的内容是不可改变的，指针看起来好像指向了一个常量。</strong>用法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">int a &#x3D; 10, b &#x3D; 20;<br>const int *p &#x3D; &amp;a;<br>p &#x3D; &amp;b; &#x2F;&#x2F; 指针可以指向其他地址，但是内容不可以改变<br></code></pre></td></tr></table></figure><h3 id="指针函数和函数指针"><a href="#指针函数和函数指针" class="headerlink" title="指针函数和函数指针"></a>指针函数和函数指针</h3><p><strong>指针函数</strong></p><ul><li>指针函数： 顾名思义，它的本质是一个函数，不过它的返回值是一个指针。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 指针函数</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> *<span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> result = a + b;<br>    <span class="hljs-keyword">int</span> *c = &amp;result;<br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br><span class="hljs-keyword">int</span> *p = sum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sum:%d\n&quot;</span>, *p);<br></code></pre></td></tr></table></figure><p><strong>函数指针</strong></p><ul><li>与指针函数不同，函数指针 的本质是一个指针，该指针的地址指向了一个函数，所以它是指向函数的指针。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 函数指针</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> (a &gt; b)?a:b;<br>&#125;<br><span class="hljs-keyword">int</span> (*p)(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>) = max;<br><span class="hljs-keyword">int</span> result = p(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;result:%d\n&quot;</span>, result);<br></code></pre></td></tr></table></figure><h3 id="自定义宏-define-MIN-A-B-A-lt-B-A-B-代码运行结果"><a href="#自定义宏-define-MIN-A-B-A-lt-B-A-B-代码运行结果" class="headerlink" title="自定义宏 #define MIN(A,B) A&lt;B?A:B 代码运行结果?"></a>自定义宏 #define MIN(A,B) A&lt;B?A:B 代码运行结果?</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">float</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">float</span> b = MIN(a++,<span class="hljs-number">1.5</span>);<br>问 a= ? b = ?<br>答案: a = <span class="hljs-number">3</span>; b = <span class="hljs-number">2</span><br>a++ 会后执行, a++在表达式出现了<span class="hljs-number">2</span>次,得<span class="hljs-number">3</span>,  a++&lt;<span class="hljs-number">1.5</span>,返回a++,得<span class="hljs-number">2</span><br><br><span class="hljs-comment">// 扩展</span><br><span class="hljs-keyword">float</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">float</span> b = [<span class="hljs-keyword">self</span> getMax:a++ b:<span class="hljs-number">1.5</span>];<br>- (<span class="hljs-built_in">CGFloat</span>)getMax:(<span class="hljs-built_in">CGFloat</span> ) a b:(<span class="hljs-built_in">CGFloat</span>)b&#123;<br>   <span class="hljs-keyword">return</span> a&gt;b?a:b;<br>&#125;<br>运行 a = <span class="hljs-number">2</span>; b =<span class="hljs-number">1.5</span>;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Objective-C </tag>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My Plan</title>
      <link href="/SYSU/MyPlan/"/>
      <url>/SYSU/MyPlan/</url>
      
        <content type="html"><![CDATA[<h2 id="网站资料"><a href="#网站资料" class="headerlink" title="网站资料"></a>网站资料</h2><p><a href="https://yz.chsi.com.cn/">研招网</a><br><a href="http://graduate.sysu.edu.cn/gra02/g02a/g02a04/32890.htm">中大招生简章</a><br><a href="http://www.zdwky.com/yuanxixinxi/rjxy/2018-06-27/3394.html">2018中大录取名单</a><br><a href="http://www.gsao.fudan.edu.cn/15015/list2.htm">复旦招生简章</a><br><a href="https://pan.baidu.com/mbox/homepage?short=eSSsDLw#share/type=session">百度网盘资料</a><br><a href="http://kysfc.ys168.com/?tdsourcetag=s_pcqq_aiomsg">分享资料</a></p><a id="more"></a> <h2 id="101-思想政治理论"><a href="#101-思想政治理论" class="headerlink" title="101 思想政治理论"></a>101 思想政治理论</h2><h3 id="参考书："><a href="#参考书：" class="headerlink" title="参考书："></a>参考书：</h3><ul><li><input disabled="" type="checkbox"> 肖秀荣考研政治命题人知识点精讲精练</li><li><input disabled="" type="checkbox"> 肖秀荣考研政治命题人1000题<h2 id="204-英语二"><a href="#204-英语二" class="headerlink" title="204 英语二"></a>204 英语二</h2><h3 id="参考书：-1"><a href="#参考书：-1" class="headerlink" title="参考书："></a>参考书：</h3></li><li><input checked="" disabled="" type="checkbox"> 恋恋有词考研英 语词汇</li><li><input disabled="" type="checkbox"> 考研词汇闪过</li><li><input checked="" disabled="" type="checkbox"> 2020考研英语长难句解密</li></ul><p><a href="http://s8.bookln.cn/chapter.htm?_appbiz=bookresdetail&bookid=47080&bookId=47080&srcchannel=mp&r=0.8920505673577417#10654171">恋练有词电子资源</a></p><ul><li><input disabled="" type="checkbox"> </li></ul><h2 id="302-数学二"><a href="#302-数学二" class="headerlink" title="302 数学二"></a>302 数学二</h2><h3 id="试卷结构"><a href="#试卷结构" class="headerlink" title="试卷结构"></a>试卷结构</h3><p><strong>（一）试卷满分及考试时间</strong><br>1.试卷满分为150分<br>2.考试时间为180分钟。<br><strong>（二）试卷内容结构</strong><br>1.高等数学 78%<br>2.线性代数 22%<br><strong>（三）卷题型结构</strong><br>1.单项选择题 8小题，每题4分，共32分<br>2.填空题 6小题，每题4分，共24分<br>3.解答题（包括证明题） 9小题，共94分</p><h3 id="参考书：-2"><a href="#参考书：-2" class="headerlink" title="参考书："></a>参考书：</h3><p>李永乐复习全书</p><h3 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h3><h4 id="第三周"><a href="#第三周" class="headerlink" title="第三周"></a>第三周</h4><ul><li><input checked="" disabled="" type="checkbox"> 第一章 函数 极限 连续性</li></ul><h4 id="第四周"><a href="#第四周" class="headerlink" title="第四周"></a>第四周</h4><ul><li><input disabled="" type="checkbox"> 复习相关第一章 函数 极限 连续性</li><li><input disabled="" type="checkbox"> 第一章练习题</li><li><input disabled="" type="checkbox"> 线性代数第一章</li></ul><h2 id="408-计算机学科专业基础综合"><a href="#408-计算机学科专业基础综合" class="headerlink" title="408 计算机学科专业基础综合"></a>408 计算机学科专业基础综合</h2><h3 id="参考书"><a href="#参考书" class="headerlink" title="参考书"></a>参考书</h3><ul><li><input checked="" disabled="" type="checkbox"> 《数据结构》(C语言版) (严蔚敏 清华大学出版社)</li><li><input disabled="" type="checkbox"> 《计算机组成原理》唐朔飞 高等教育出版社 </li><li><input disabled="" type="checkbox"> 《计算机操作系统》(汤子瀛 西安电子科技大学)</li><li><input disabled="" type="checkbox"> 《计算机网络》(谢希仁 电子工业出版社)</li></ul><p>数据结构 45分<br>计算机组成原理 45分<br>操作系统 35分<br>计算机网络 25分</p><h3 id="题型结构"><a href="#题型结构" class="headerlink" title="题型结构"></a>题型结构</h3><p>单项选择题 80分（40小题）</p><p>综合应用题 70分</p><h3 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><h5 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h5><ol><li>线性表的定义和基本操作</li><li>线性表的实现<ol><li>顺序存储</li><li>链式存储</li><li>线性表的应用</li></ol></li></ol><h5 id="栈、队列和数组"><a href="#栈、队列和数组" class="headerlink" title="栈、队列和数组"></a><strong>栈、队列和数组</strong></h5><ol><li>栈和队列的基本概念</li><li>栈和队列的顺序存储结构</li><li>栈和队列的链式存储结构</li><li>栈和队列的应用</li><li>特殊矩阵的压缩存储</li></ol><h5 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h5><ol><li>树的基本概念</li><li>二叉树<ol><li>二叉树的定义及其主要特性</li><li>二叉树的顺序存储结构和链式结构</li><li>二叉树的遍历</li><li>线索二叉树的基本概念和构造</li></ol></li><li>树、森林<ol><li>树的存储结构</li><li>森林与二叉树的转换</li><li>树和森林的遍历</li></ol></li><li>树与二叉树的应用<ol><li>二叉排序树</li><li>平衡二叉树</li><li>哈夫曼树和哈夫曼编码</li></ol></li></ol><h5 id="图"><a href="#图" class="headerlink" title="图"></a>图</h5><ol><li>图的基本概念</li><li>图的存储及基本操作<ol><li>邻接矩阵法</li><li>邻接表法</li><li>邻接多重表、十字链表</li></ol></li><li>图的遍历<ol><li>深度优先搜索</li><li>广度优先搜索</li></ol></li><li>图的基本应用<ol><li>最小（代价）生成树</li><li>最短路径</li><li>拓扑排序</li><li>关键路径</li></ol></li></ol><h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><ol><li>查找的基本概念</li><li>顺序查找法</li><li>分块查找法</li><li>折半查找法</li><li>B树及其基本操作、B+树的基本概念</li><li>散列（Hash）表</li><li>字符串模式匹配</li><li>查找算法的分析及应用</li></ol><h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><ol><li>排序的基本概念</li><li>插入排序<ol><li>直接插入排序</li><li>折半插入排序</li></ol></li><li>冒泡排序</li><li>简单选择排序</li><li>希尔排序</li><li>快速排序</li><li>堆排序</li><li>二路归并排序</li><li>基数排序</li><li>外部排序</li><li>各种排序算法的比较</li><li>排序算法的应用</li></ol><h4 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h4><h5 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h5><ol><li>计算机发展历程</li><li>计算机系统层次结构<ol><li>计算机硬件的基本组成</li><li>计算机软件的分类</li><li>计算机的工作过程</li></ol></li><li>计算机性能指标<br>吞吐量、响应时间、CPU时钟周期、主频、CPI、 CPU执行时间MIPS、MFLOPS、GFLOPS、TFLOPS</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 考研 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据挖掘第一次作业</title>
      <link href="/AI/DataMining_assign1/"/>
      <url>/AI/DataMining_assign1/</url>
      
        <content type="html"><![CDATA[<p><strong>蒙特卡罗方法</strong>（英语：Monte Carlo method），也称<strong>统计模拟方法</strong>，是指使用随机数（或更常见的伪随机数）来解决很多计算问题的方法。在解决实际问题的时候应用蒙特卡罗方法主要有两部分工作：</p><ol><li>用蒙特卡罗方法模拟某一过程时，需要产生各种概率分布的随机变量。</li><li>用统计方法把模型的数字特征估计出来，从而得到实际问题的数值解。</li></ol><p>蒙特卡洛算法也常用于机器学习，特别是强化学习的算法中。一般情况下，针对得到的样本数据集创建相对模糊的模型，通过蒙特卡洛方法对于模型中的参数进行选取，使之于原始数据的残差尽可能的小。从而达到创建模型拟合样本的目的。</p><a id="more"></a> <h2 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h2><p><strong>简述：</strong>蒙特卡罗方法可用于近似计算圆周率：让计算机每次随机生成两个0到1之间的数，看以这两个实数为横纵坐标的点是否在单位圆内。生成一系列随机点，统计单位圆内的点数与总点数，（圆面积和正方形面积之比为PI:4，PI为圆周率），当随机点获取越多时，其结果越接近于圆周率。</p><p><strong>实验过程：</strong>重复次数设为50，使用matlab实现，代码：</p><p><strong>myPi.m</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[means,variances]</span> = <span class="hljs-title">myPi</span><span class="hljs-params">(num)</span></span><br>    <span class="hljs-comment">% num: 随机样本数</span><br>    <span class="hljs-comment">% 使用蒙特卡洛方法求pi</span><br>    my_pi = <span class="hljs-built_in">zeros</span>(<span class="hljs-number">1</span>,<span class="hljs-number">50</span>);<br>    <span class="hljs-keyword">for</span> t=<span class="hljs-number">1</span>:<span class="hljs-number">50</span>     <br>        <span class="hljs-comment">%% 生成随机数</span><br>        s=rng;<br>        rng(s);<br>        point=<span class="hljs-number">2</span>*<span class="hljs-built_in">rand</span>(<span class="hljs-number">2</span>,num);   <br>        <span class="hljs-comment">%% 统计落入圆中的点</span><br>        total_in=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>:num<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">sqrt</span>((point(<span class="hljs-number">1</span>,<span class="hljs-built_in">i</span>)<span class="hljs-number">-1</span>)^<span class="hljs-number">2</span>+(point(<span class="hljs-number">2</span>,<span class="hljs-built_in">i</span>)<span class="hljs-number">-1</span>)^<span class="hljs-number">2</span>) &lt; <span class="hljs-number">1</span><br>                total_in=total_in+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">end</span>     <br>       <span class="hljs-comment">%% 计算pi</span><br>        my_pi(t)=total_in/num*<span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">end</span><br>    means = <span class="hljs-built_in">mean</span>(my_pi);<br>    variances = std(my_pi,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)^<span class="hljs-number">2</span>;<br><span class="hljs-keyword">end</span>   <br></code></pre></td></tr></table></figure><p><strong>exercise1.m</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs matlab">number = [ <span class="hljs-number">20</span>,<span class="hljs-number">50</span>,<span class="hljs-number">100</span>,<span class="hljs-number">200</span>,<span class="hljs-number">300</span>,<span class="hljs-number">500</span>,<span class="hljs-number">1000</span>,<span class="hljs-number">5000</span>];<br>result = <span class="hljs-built_in">zeros</span>(<span class="hljs-number">2</span>,<span class="hljs-number">8</span>);<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>:<span class="hljs-number">8</span><br>   [result(<span class="hljs-number">1</span>,<span class="hljs-built_in">i</span>),result(<span class="hljs-number">2</span>,<span class="hljs-built_in">i</span>)] = myPi(number(<span class="hljs-built_in">i</span>));<br><span class="hljs-keyword">end</span><br>result<br></code></pre></td></tr></table></figure><h4 id="实验结果："><a href="#实验结果：" class="headerlink" title="实验结果："></a><strong>实验结果：</strong></h4><table><thead><tr><th></th><th align="center">20</th><th>50</th><th>100</th><th>200</th><th>300</th><th>500</th><th>1000</th><th>5000</th></tr></thead><tbody><tr><td>均值</td><td align="center">3.1400</td><td>3.1232</td><td>3.2000</td><td>3.1412</td><td>3.1099</td><td>3.1371</td><td>3.1297</td><td>3.1407</td></tr><tr><td>方差</td><td align="center">0.0886</td><td>0.0580</td><td>0.0269</td><td>0.0125</td><td>0.0096</td><td>0.0061</td><td>0.0023</td><td>0.0006</td></tr></tbody></table><h2 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2"></a>Exercise 2</h2><p><strong>简述：</strong>使用蒙特卡洛方法求定积分，非权重蒙特卡罗积分，也称确定性抽样，是对被积函数变量区间进行随机均匀抽样，然后对抽样点的函数值求平均，从而可以得到函数积分的近似值。此种方法的正确性是基于概率论的中心极限定理。当抽样点数为m时，使用此种方法所得近似解的统计误差只与m有关，不随积分维数的改变而改变。因此当积分维度较高时，蒙特卡罗方法相对于其他数值解法更优。大致方法有：</p><ol><li>随机投点法（最常用）</li><li>期望法（平均值法）</li></ol><p><strong>实验过程：</strong>x使用均分分布采样，这样能保证在边长为1的正方形中各个位置的概率相等，重复次数设为100, matlab代码：</p><p><strong>x3.m</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[means,variances]</span> = <span class="hljs-title">x3</span><span class="hljs-params">(num)</span></span><br>    <span class="hljs-comment">% num: 随机样本数</span><br>    <span class="hljs-comment">% 使用蒙特卡罗方法求定积分</span><br>    my_res = <span class="hljs-built_in">zeros</span>(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>);<br>    <span class="hljs-keyword">for</span> t=<span class="hljs-number">1</span>:<span class="hljs-number">100</span>     <br>        <span class="hljs-comment">%% 生成随机数</span><br>        s=rng;<br>        rng(s);<br>        point=<span class="hljs-built_in">rand</span>(<span class="hljs-number">2</span>,num);   <br>        <span class="hljs-comment">%% 统计线下面的点</span><br>        total_in=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>:num<br>            <span class="hljs-keyword">if</span> (point(<span class="hljs-number">1</span>,<span class="hljs-built_in">i</span>))^<span class="hljs-number">3</span> &gt; point(<span class="hljs-number">2</span>,<span class="hljs-built_in">i</span>)<br>                total_in=total_in+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">end</span>     <br>       <span class="hljs-comment">%% 计算结果</span><br>        my_res(t)=total_in/num;<br>    <span class="hljs-keyword">end</span><br>    means = <span class="hljs-built_in">mean</span>(my_res);<br>    variances = std(my_res,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)^<span class="hljs-number">2</span>;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><strong>exercise2.m</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs matlab">number = [ <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>, <span class="hljs-number">60</span>, <span class="hljs-number">70</span>, <span class="hljs-number">80</span>,<span class="hljs-number">100</span>];<br>result = <span class="hljs-built_in">zeros</span>(<span class="hljs-number">2</span>,<span class="hljs-number">10</span>);<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>:<span class="hljs-number">10</span><br>   [result(<span class="hljs-number">1</span>,<span class="hljs-built_in">i</span>),result(<span class="hljs-number">2</span>,<span class="hljs-built_in">i</span>)] = x3(number(<span class="hljs-built_in">i</span>));<br><span class="hljs-keyword">end</span><br>result<br></code></pre></td></tr></table></figure><h4 id="实验结果：-1"><a href="#实验结果：-1" class="headerlink" title="实验结果："></a>实验结果：</h4><table><thead><tr><th align="center"></th><th align="center">5</th><th align="center">10</th><th align="center">20</th><th align="center">30</th><th align="center">40</th></tr></thead><tbody><tr><td align="center">均值</td><td align="center">0.2660</td><td align="center">0.2540</td><td align="center">0.2460</td><td align="center">0.2563</td><td align="center">0.2387</td></tr><tr><td align="center">方差</td><td align="center">0.0413</td><td align="center">0.0175</td><td align="center">0.0101</td><td align="center">0.0061</td><td align="center">0.0043</td></tr><tr><td align="center"></td><td align="center"><strong>50</strong></td><td align="center"><strong>60</strong></td><td align="center"><strong>70</strong></td><td align="center"><strong>80</strong></td><td align="center"><strong>100</strong></td></tr><tr><td align="center">均值</td><td align="center">0.2502</td><td align="center">0.2465</td><td align="center">0.2539</td><td align="center">0.2616</td><td align="center">0.2479</td></tr><tr><td align="center">方差</td><td align="center">0.0041</td><td align="center">0.0026</td><td align="center">0.0029</td><td align="center">0.0025</td><td align="center">0.0022</td></tr></tbody></table><h2 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3"></a>Exercise 3</h2><p>不能使用公式直接获得，使用蒙特卡洛方法求定积分，方法为随机投点法</p><p>x使用均分分布采样，重复次数设为100, matlab代码：</p><p><strong>func3.m</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">[means,variances]</span> = <span class="hljs-title">func3</span><span class="hljs-params">(num)</span></span><br>    <span class="hljs-comment">% num: 随机样本数</span><br>    <span class="hljs-comment">% 使用蒙特卡洛方法求定积分</span><br>    my_res = <span class="hljs-built_in">zeros</span>(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>);<br>    <span class="hljs-keyword">for</span> t=<span class="hljs-number">1</span>:<span class="hljs-number">100</span>     <br>        <span class="hljs-comment">%% 生成随机数</span><br>        s=rng;<br>        rng(s);<br>        x=<span class="hljs-number">2</span>+<span class="hljs-number">2</span>*<span class="hljs-built_in">rand</span>(<span class="hljs-number">1</span>,num);<br>        y=<span class="hljs-number">-1</span>+<span class="hljs-number">2</span>*<span class="hljs-built_in">rand</span>(<span class="hljs-number">1</span>,num);<br>        z=<span class="hljs-number">800000</span>*<span class="hljs-built_in">rand</span>(<span class="hljs-number">1</span>,num);<br>        <span class="hljs-comment">%% 统计线下面的点</span><br>        total_in=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>:num<br>            d = (y(<span class="hljs-number">1</span>,<span class="hljs-built_in">i</span>)^<span class="hljs-number">2</span>*<span class="hljs-built_in">exp</span>(-y(<span class="hljs-number">1</span>,<span class="hljs-built_in">i</span>)^<span class="hljs-number">2</span> )+x(<span class="hljs-number">1</span>,<span class="hljs-built_in">i</span>)^<span class="hljs-number">4</span>*<span class="hljs-built_in">exp</span>(-x(<span class="hljs-number">1</span>,<span class="hljs-built_in">i</span>)^<span class="hljs-number">2</span> ))/(x(<span class="hljs-number">1</span>,<span class="hljs-built_in">i</span>)*<span class="hljs-built_in">exp</span>(-x(<span class="hljs-number">1</span>,<span class="hljs-built_in">i</span>)^<span class="hljs-number">2</span> ) );<br>            <span class="hljs-keyword">if</span> z(<span class="hljs-number">1</span>,<span class="hljs-built_in">i</span>) &lt; d<br>                total_in=total_in+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">end</span><br>        <span class="hljs-keyword">end</span>  <br>        <br>       <span class="hljs-comment">%% 计算结果</span><br>        my_res(t)=<span class="hljs-number">2</span>*<span class="hljs-number">2</span>*<span class="hljs-number">800000</span>*total_in/num;<br>    <span class="hljs-keyword">end</span><br>    means = <span class="hljs-built_in">mean</span>(my_res);<br>    variances = std(my_res,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)^<span class="hljs-number">2</span>;<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><strong>exercise3.m</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs matlab">format long<br>number = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>, <span class="hljs-number">60</span>, <span class="hljs-number">70</span>, <span class="hljs-number">80</span>,<span class="hljs-number">100</span>,<span class="hljs-number">200</span>,<span class="hljs-number">500</span>];<br>result = <span class="hljs-built_in">zeros</span>(<span class="hljs-number">2</span>,<span class="hljs-number">11</span>);<br><br><span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>:<span class="hljs-number">11</span><br>   [result(<span class="hljs-number">1</span>,<span class="hljs-built_in">i</span>),result(<span class="hljs-number">2</span>,<span class="hljs-built_in">i</span>)] = func3(number(<span class="hljs-built_in">i</span>));<br><span class="hljs-keyword">end</span><br>result<br></code></pre></td></tr></table></figure><h4 id="实验结果：-2"><a href="#实验结果：-2" class="headerlink" title="实验结果："></a><strong>实验结果：</strong></h4><table><thead><tr><th align="center">采样次数N</th><th align="center">均值</th><th align="center">方差</th></tr></thead><tbody><tr><td align="center">10</td><td align="center">1.0e+10 *0.000010560000000</td><td align="center">1.0e+10 *3.735014141414141</td></tr><tr><td align="center">20</td><td align="center">1.0e+10 *0.000009600000000</td><td align="center">1.0e+10 *1.603232323232323</td></tr><tr><td align="center">30</td><td align="center">1.0e+10 *0.000011946666667</td><td align="center">1.0e+10 *1.109735578002245</td></tr><tr><td align="center">40</td><td align="center">1.0e+10 *0.000011760000000</td><td align="center">1.0e+10 *0.833357575757576</td></tr><tr><td align="center">50</td><td align="center">1.0e+10 *0.000011648000000</td><td align="center">1.0e+10 *0.632025212121212</td></tr><tr><td align="center">60</td><td align="center">1.0e+10 *0.000010400000000</td><td align="center">1.0e+10 *0.559551066217732</td></tr><tr><td align="center">70</td><td align="center">1.0e+10 *0.000011337142857</td><td align="center">1.0e+10 *0.538196330653474</td></tr><tr><td align="center">80</td><td align="center">1.0e+10 *0.000010840000000</td><td align="center">1.0e+10 *0.401761616161616</td></tr><tr><td align="center">100</td><td align="center">1.0e+10 *0.000010816000000</td><td align="center">1.0e+10 *0.409144888888889</td></tr><tr><td align="center">200</td><td align="center">1.0e+10 *0.000010640000000</td><td align="center">1.0e+10 *0.132072727272727</td></tr><tr><td align="center">500</td><td align="center">1.0e+10 *0.000011353600000</td><td align="center">1.0e+10 *0.058057283232323</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 数据挖掘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系分第一次作业</title>
      <link href="/SSAD/SSAD-homework1/"/>
      <url>/SSAD/SSAD-homework1/</url>
      
        <content type="html"><![CDATA[<h2 id="1-软件工程的定义"><a href="#1-软件工程的定义" class="headerlink" title="1. 软件工程的定义"></a>1. 软件工程的定义</h2><p>软件工程是软件开发领域里对工程方法的系统应用，是研究和应用如何以系统性的、规范化的、可定量的过程化方法去开发和维护软件，以及如何把经过时间考验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来的学科。</p><p><strong>IEEE</strong>给出了一个更加综合的定义：将系统化的、规范的、可度量的方法用于软件的开发、运行和维护的过程，即将工程化应用于软件开发中。</p><a id="more"></a> <h2 id="2-软件危机"><a href="#2-软件危机" class="headerlink" title="2. 软件危机"></a>2. 软件危机</h2><h3 id="本质原因"><a href="#本质原因" class="headerlink" title="本质原因"></a>本质原因</h3><p>软件危机是指在计算机软件的开发和维护过程中所遇到的一系列严重问题。概括地说，软件危机包含下述两方面的问题：如何开发软件，以满足对软件日益增长的需求；如何维护数量不断膨胀的已有软件。软件开发是一项高难度、高风险的活动，由于它的高失败率，故有所谓“软件危机”之说。软件危机的本源是复杂、期望和改变。</p><p>一方面与软件本身的特点有关，另一方面也和软件开发与维护的方法不正确有关。软件不同于硬件，它是计算机系统中的逻辑部件而不是物理部件。管理和控制软件开发过程相当困难。软件是规模庞大，而且程序复杂性将随着程序规模的增加而呈指数上升。目前相当多的软件专业人员对软件开发和维护还有不省糊涂观念，在实践过程中或多或少地采用了错误的方法和技术，这是使软件问题发展成软件危机的主要原因。</p><h3 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h3><p>对软件开发成本和进度的估计常常很不准确。用户对“已完成的”软件系统不满意的现象经常发生。软件产品的质量往往靠不住。软件常常是不可维护的。软件通常没有适当的文档资料。软件成本在计算机系统总成本中所占的比例逐年上升。软件开发生产率提高的速度，远远跟不上计算机应用迅速普及深入的趋势。</p><p>大致可概括为：</p><ul><li>项目运行超出预算。</li><li>项目运行超过时间。</li><li>软件质量低落。</li><li>软件通常不匹配需求。</li><li>项目无法管理，且代码难以维护。</li></ul><h3 id="消除软件危机途径"><a href="#消除软件危机途径" class="headerlink" title="消除软件危机途径"></a>消除软件危机途径</h3><p>为了消除软件危机，首先应该对计算机软件有一个正确的认识。必须充分认识到软件开发不是某种个体劳动的神秘技巧，而应该是一种组织良好、管理严密、各类人员协同配合、共同完成的工程项目。应该推广使用在实践中总结出来的开发软件的成功的技术和方法，并且研究探索更好更有效的技术和方法，尽快消除在计算机系统早期发展阶段形成的一些错误概念和做法。应该开发和使用更好的软件工具。为了解决软件危机，既要有技术措施（方法和工具），又要有必要的组织管理措施。</p><h2 id="3-软件生命周期"><a href="#3-软件生命周期" class="headerlink" title="3. 软件生命周期"></a>3. 软件生命周期</h2><p>软件生命周期是指软件的产生直到成熟的全部过程。软件生命周期模型是指人们为开发更好的软件而归纳总结的软件生命周期的典型实践参考。生命周期模型简洁地描述软件过程，规定了把生命周期划分成哪些阶段及各个阶段执行顺序。</p><p>常用的模型大致有瀑布模型、快速原型模型、增量模型和螺旋模型。</p><ul><li><strong>瀑布模型</strong>历史悠久、广为人知，它的优势在于它是规范的、文档驱动的方法；这种模型的问题是，最终开发出的软件产品可能并不是用户真正需要的。</li><li><strong>快速原型模型</strong>正是为了克服瀑布模型的缺点而提出来的。它通过快速构建起一个可在计算机上运行的原型系统，让用户试用原型并收集用户反馈意见的办法，获取用户的真实需求。</li><li><strong>增量模型</strong>具有可在软件开发的早期阶段使投资获得明显回报和较易维护的优点，但是，要求软件具有开放的结构是使用这种模型时固有的困难。</li><li><strong>螺旋模型</strong>适用于内部开发的大型软件项目，但是，只有在开发人员具有风险分析和排除风险的经验及专门知识时，使用这种模型才会获得成功。</li></ul><h2 id="4-SWEBoK"><a href="#4-SWEBoK" class="headerlink" title="4. SWEBoK"></a>4. SWEBoK</h2><h3 id="软件需求"><a href="#软件需求" class="headerlink" title="软件需求"></a>软件需求</h3><p>软件需求KA关注软件需求的启发，协商，分析，规范和验证。在软件行业中，人们普遍认为，当这些活动表现不佳时，软件工程项目非常容易受到攻击。软件需求表达了对软件产品的需求和限制，这些需求和约束有助于解决一些现实问题。</p><h3 id="软件设计"><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h3><p>设计被定义为两个限定的体系结构，组件，接口，以及其它的系统或部件的特性的过程中，和过程的结果（IEEE 1991）。软件设计KA涵盖了设计过程和最终产品。软件设计过程是软件工程生命周期活动，其中分析软件需求以产生软件内部结构及其行为的描述，其将作为其构造的基础。软件设计（结果）必须描述软件体系结构，即软件如何分解和组织成组件以及这些组件之间的接口。它还必须描述能够构建它们的详细程度的组件。</p><h3 id="软件构建"><a href="#软件构建" class="headerlink" title="软件构建"></a>软件构建</h3><p>软件构建是指通过结合详细设计，编码，单元测试，集成测试，调试和验证来详细创建工作软件。软件构建KA包括与满足其要求和设计约束的软件程序开发相关的主题。该KA涵盖了软件构建基础、 管理软件建设、建筑技术、实际考虑和软件构建工具。</p><h3 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h3><p>测试是一项旨在评估产品质量并通过识别缺陷来改进产品质量的活动。软件测试涉及在有限的测试用例集上针对预期行为动态验证程序的行为。这些测试用例是从（通常非常大的）执行域中选择的。软件测试KA包括软件测试的基础知识、测试技术、人机界面测试与评估、与测试有关的措施和实际考虑。</p><h3 id="软件维护"><a href="#软件维护" class="headerlink" title="软件维护"></a>软件维护</h3><p>软件维护包括增强现有功能，调整软件以在新的和修改的操作环境中运行，以及纠正缺陷。这些类别称为完善，自适应和纠正性软件维护。软件维护KA包括软件维护的基础知识（维护的性质和需求，维护类别，维护成本）; 软件维护中的关键问题（技术问题，管理问题，维护成本估算，软件维护测量）、维护过程、软件维护技术（程序理解，重新设计，逆向工程，重构，软件退役）、灾难恢复技术和软件维护工具。</p><h3 id="软件配置管理"><a href="#软件配置管理" class="headerlink" title="软件配置管理"></a>软件配置管理</h3><p>系统的配置是硬件，固件，软件或这些的组合的功能和/或物理特征。它还可以被视为根据特定构建过程组合的特定版本的硬件，固件或软件项的集合，以满足特定目的。因此，软件配置管理（SCM）是在不同时间点识别系统配置的规则，用于系统地控制配置的改变，以及在整个软件生命周期中维持配置的完整性和可追溯性。软件配置管理KA涵盖SCM过程的管理、软件配置识别，控制，状态核算，审计、 软件发布管理和交付。</p><h3 id="软件工程管理"><a href="#软件工程管理" class="headerlink" title="软件工程管理"></a>软件工程管理</h3><p>软件工程管理涉及规划，协调，测量，报告和控制项目或程序，以确保软件的开发和维护是系统化的，规范化的和量化的。软件工程管理KA涵盖了启动和范围定义（确定和协商要求，可行性分析以及要求的审查和修订）、软件项目计划（过程计划，工作量估算，成本和进度，资源分配，风险分析，质量计划）、软件项目制定（计量，报告和控制;收购和供应商合同管理）、产品验收、审查和分析项目绩效、项目结束和软件管理工具。</p><h3 id="软件工程过程"><a href="#软件工程过程" class="headerlink" title="软件工程过程"></a>软件工程过程</h3><p>软件工程KA关注软件生命周期过程的定义，实施，评估，测量，管理和改进。涵盖的主题包括流程实施和变更（流程基础架构，流程实施和变更模型以及软件流程管理）、流程定义（软件生命周期模型和流程，流程定义，流程适应和流程自动化的符号）、过程评估模型和方法、测量（过程测量，产品测量，测量技术和测量结果的质量）和软件处理工具。</p><h3 id="软件工程模型和方法"><a href="#软件工程模型和方法" class="headerlink" title="软件工程模型和方法"></a>软件工程模型和方法</h3><p>软件工程模型和方法KA解决了涵盖多个生命周期阶段的方法; 其他KAs涵盖特定生命周期阶段的特定方法。涵盖的主题包括建模（软件工程模型的原理和属性、语法与语义与不变量、前置条件、后置条件和不变量）、模型类型（信息，结构和行为模型）、 分析（分析正确性，完整性，一致性，质量和相互作用;可追溯性;以及权衡分析）、和软件开发方法（启发式方法，形式方法，原型方法和敏捷方法）。</p><h3 id="软件质量"><a href="#软件质量" class="headerlink" title="软件质量"></a>软件质量</h3><p>软件质量是许多SWEBOK V3 KAs中普遍存在的软件生命周期问题。此外，软件质量KA还包括软件质量的基础知识（软件工程文化，软件质量特性，软件质量的价值和成本以及软件质量改进）、软件质量管理流程（软件质量保证，验证和确认，审核和审核）和实际考虑（缺陷表征，软件质量测量和软件质量工具）。</p><h3 id="软件工程专业实践"><a href="#软件工程专业实践" class="headerlink" title="软件工程专业实践"></a>软件工程专业实践</h3><p>软件工程专业实践关注软件工程师必须具备的专业，负责和道德的软件工程知识，技能和态度。软件工程专业实践KA涵盖专业性（专业行为，专业协会，软件工程标准，雇佣合同和法律问题）、道德准则、小组动态（团队合作，认知问题复杂性，与利益相关者互动，处理不确定性和模糊性，处理多元文化环境） 和沟通技巧。</p><h3 id="软件工程经济学"><a href="#软件工程经济学" class="headerlink" title="软件工程经济学"></a>软件工程经济学</h3><p>软件工程经济学KA关注的是在业务环境中做出决策，以使技术决策与组织的业务目标保持一致。涵盖的主题包括软件工程经济学的基本原理（提案，现金流量，货币时间价值，计划视野，通货膨胀，折旧，替代和退休决策）、 非营利性决策（成本效益分析，优化分析）；估计，经济风险和不确定性（估算技术，风险决策和不确定性） 和多属性决策（价值和衡量尺度，补偿和非补偿技术）。</p><h3 id="计算基础"><a href="#计算基础" class="headerlink" title="计算基础"></a>计算基础</h3><p>计算基础KA涵盖了提供软件工程实践所需的计算背景的基础主题。涵盖的主题包括问题解决技术，抽象，算法和复杂性，编程基础，并行和分布式计算的基础知识，计算机组织，操作系统和网络通信。</p><h3 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h3><p>数学基础KA涵盖了提供软件工程实践所必需的数学背景的基础主题。涵盖的主题包括集合，关系和功能; 基本命题和谓词逻辑; 证明技术; 图形和树木; 离散概率; 语法和有限状态机和数论。</p><h3 id="工程基础"><a href="#工程基础" class="headerlink" title="工程基础"></a>工程基础</h3><p>工程基础KA涵盖了提供软件工程实践所必需的工程背景的基础主题。涵盖的主题包括经验方法和实验技术; 统计分析; 测量和指标; 工程设计; 仿真与建模和根本原因分析。</p><h2 id="5-CMMI"><a href="#5-CMMI" class="headerlink" title="5. CMMI"></a>5. CMMI</h2><h3 id="CMMI一级，完成级"><a href="#CMMI一级，完成级" class="headerlink" title="CMMI一级，完成级"></a>CMMI一级，完成级</h3><p>在完成级水平上，企业对项目的目标与要做的努力很清晰，项目的目标得以实现。但是由于任务的完成带有很大的偶然性，企业无法保证在实施同类项目的时候仍然能够完成任务。企业在一级上的项目实施对实施人员有很大的依赖性。</p><h3 id="CMMI二级，管理级"><a href="#CMMI二级，管理级" class="headerlink" title="CMMI二级，管理级"></a>CMMI二级，管理级</h3><p>在管理级水平上，企业在项目实施上能够遵守既定的计划与流程，有资源准备，权责到人，对相关的项目实施人员有相应的培训，对整个流程有监测与控制，并与上级单位对项目与流程进行审查。企业在二级水平上体现了对项目的一系列的管理程序。这一系列的管理手段排除了企业在一级时完成任务的随机性，保证了企业的所有项目实施都会得到成功。</p><h3 id="CMMI三级，定义级"><a href="#CMMI三级，定义级" class="headerlink" title="CMMI三级，定义级"></a>CMMI三级，定义级</h3><p>在定义级水平上，企业不仅能够对项目的实施有一整套的管理措施，并保障项目的完成；而且，企业能够根据自身的特殊情况以及自己的标准流程，将这套管理体系与流程予以制度化这样，企业不仅能够在同类的项目上生到成功的实施，在不同类的项目上一样能够得到成功的实施。科学的管理成为企业的一种文化，企业的组织财富。</p><h3 id="CMMI四级，量化管理级"><a href="#CMMI四级，量化管理级" class="headerlink" title="CMMI四级，量化管理级"></a>CMMI四级，量化管理级</h3><p>在量化管理级水平上，企业的项目管理不仅形成了一种制度，而且要实现数字化的管理。对管理流程要做到量化与数字化。通过量化技术来实现流程的稳定性，实现管理的精度，降低项目实施在质量上的波动。</p><h3 id="CMMI五级，优化级"><a href="#CMMI五级，优化级" class="headerlink" title="CMMI五级，优化级"></a>CMMI五级，优化级</h3><p>在优化级水平上，企业的项目管理达到了最高的境界。企业不仅能够通过信息手段与数字化手段来实现对项目的管理，而且能够充分利用信息资料，对企业在项目实施的过程中可能出现的次品予以预防。能够主动地改善流程，运用新技术，实现流程的优化。</p><h2 id="6-简述CMMI"><a href="#6-简述CMMI" class="headerlink" title="6. 简述CMMI"></a>6. 简述CMMI</h2><p>CMMI是美国国防部委托卡耐基－梅隆大学(Carnegie Mellon University)软件工程学院(Software Engineering Institute)开发出来的， 作为采购方评估供应方的过程能力与组织成熟度标准，也作为企业提高产品开发过程管理水品的参考。CMMI可以用于指导跨项目、部门或整个组织的过程改进，适用于航空航天、银行、硬件、软件、国防、汽车制造、电信等行业。CMMI是一个用于产品与服务开发的过程改进成熟度模型。它包含开发与维护活动的最佳执行方法，涵盖产品从构思到交付与维护的生命周期。</p><p>CMMI是美国国防部的一个设想，他们想把现在所有的以及将被发展出来的各种能力成熟度模型，集成到一个框架中去。这个框架有两个功能，第一，软件采购方法的改革；第二，建立一种从集成产品与过程发展的角度出发、包含健全的系统开发原则的过程改进。就软件而言， CMMI是SW-CMM的修订本。它兼收了SW-CMM 2.0版C稿草案和SPA中更合理、更科学和更周密的优点。SEI在发表CMMI-SE/SW 1.0版时，宣布大约用两年的时间完成从CMM到CMMI的过渡。CMMI成熟度级别:初始、管理、定义、定量管理和优化五个级别。版本2.0于2018年发布。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 系分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git Manual</title>
      <link href="/Git/GitManual/"/>
      <url>/Git/GitManual/</url>
      
        <content type="html"><![CDATA[<h4 id="安装以及配置"><a href="#安装以及配置" class="headerlink" title="安装以及配置"></a>安装以及配置</h4><p>Git是目前世界上最先进的分布式版本控制系统。在Windows安装git后，选择Git Bash，命令行输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">$ git config --global user.name &quot;wanggh8&quot;<br>$ git config --global user.email &quot;1299927852@qq.com&quot;<br></code></pre></td></tr></table></figure><p>名字和邮箱输入自己创建github时所用的</p><a id="more"></a> <h4 id="本地基本使用"><a href="#本地基本使用" class="headerlink" title="本地基本使用"></a>本地基本使用</h4><p>选择一个空目录，路径最好不包含中文，然后使用<code>git init</code>可以把这个目录变成Git可以管理的仓库，只会可以用<code>git add</code>命令将文件添加到仓库暂存区中，然后可以用<code>git commit</code>提交到版本库分支中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">$ git add readme.txt<br>$ git commit -m &quot;wrote a readme file&quot;<br></code></pre></td></tr></table></figure><p>之后可以使用给<code>git status</code> 查看结果，当前是否有新的更改以及更改是否提交，如果被修改了可以用<code>git diff</code>查看文件修改前后的不同，选择是否要保留更改。如果选择放弃更改使用命令<code>git checkout -- file</code>可以丢弃工作区的修改，同时命令<code>git reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉，重新放回工作区。<code>git log</code>命令可以显示从最近到最远的提交日志，可以加上<code>--pretty=oneline</code>让信息在一行显示。之后进行版本回退有两种 方式</p><ul><li>用<code>HEAD</code>表示当前版本，也就是最新的提交版本，上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，以此类推，如果较多可以用<code>HEAD~n</code>，然后使用命令<code>$ git reset --hard HEAD^</code>回退。</li><li>直接使用<code>$ git reset --hard 加上版本号</code>，一般输入版本号的前几位就可以了。</li></ul><p>在版本回溯中，git使用指针，将指针头指向真正应用的版本，当需要更改的时候只需要移动指针就可以了。</p><p>如果要删除某个文件的话就直接使用<code>rm</code>命令,不过此时并没有在版本库中删除，如果确实要从版本库中删除需要使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">$ git rm test.txt<br>$ git commit -m &quot;remove test.txt&quot;<br></code></pre></td></tr></table></figure><p>如果误删，则可以使用<code>git checkout -- test.txt</code>恢复到最新版本。</p><h4 id="分支与标签"><a href="#分支与标签" class="headerlink" title="分支与标签"></a>分支与标签</h4><ul><li><p>创建并切换分支:<code>$ git checkout -b name</code></p></li><li><p>查看当前分支:<code>git branch</code></p></li><li><p>切换分支:<code>git checkout name</code></p></li><li><p>合并指定分支到当前分支:<code>git merge</code></p></li><li><p>删除分支:<code>git branch -d &lt;name&gt;</code></p></li><li><p>新建一个标签:<code>git tag &lt;tagname&gt;</code></p></li><li><p>指定标签信息:<code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code></p></li><li><p>查看所有标签:<code>git tag</code></p></li></ul><h4 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h4><p>首先需要创建SSH Key，使用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">$ ssh-keygen -t rsa -C &quot;1299927852@qq.com&quot;<br></code></pre></td></tr></table></figure><p>可以在用户目录下看到.ssh目录，目录中有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，其中第一个是私钥，第二个是公钥，我们一般用的就是公钥。在github的setting的ssh keys界面加入自己的公钥，之后电脑就可以往github上推送了。</p><p>添加远程库，使github上的远程库与本地库同步，使用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">$ git remote add origin git@gitee.com:wanggh8&#x2F;resume.git<br></code></pre></td></tr></table></figure><p>第一次可以使用<code>git push -u origin master</code>命令，实际上是把当前分支<code>master</code>推送到远程。之后可以直接使用命令<code>git push origin master </code></p><p>从远程库克隆时，使用<code> git pull git@gitee.com:wanggh8/resume.git</code></p><p>使用码云时大部分只需要将github替换成gitee就可以了，可以同时关联两个远程库，但名字应该不同。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win10黑苹果安装</title>
      <link href="/IT/MacOSInstall/"/>
      <url>/IT/MacOSInstall/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>一个 8G 以上的U 盘（有的 U 盘标的是 8G，实际只有 7.X，实际容量小于 7.5G的会失败）</li><li>MacOS 镜像</li><li>Transmac</li><li>分区工具DiskGenius</li><li>EasyUEFI</li><li>引导EFI文件（clover）</li><li>Clover Configurator（可选）</li><li>VSCode（用于编辑一些配置文件）</li></ul><h2 id="制作启动U盘"><a href="#制作启动U盘" class="headerlink" title="制作启动U盘"></a>制作启动U盘</h2><p>插入U 盘，打开 TransMac。如果没有可以点右键刷新。鼠标右键单击 U 盘，然后单击“Format Disk for Mac”(这将删除 U 盘上的所有文件，并为 macOS 做好准备)。格式完后选 Restore with Disk Image, 选择自己下载的镜像，确认写入。写入完成后，可以看到EFI分区。如果没有的话，重新插拔一下U盘。如果提示格式化磁盘，点取消就好。之后把自带的EFI中的clover文件夹删除，把自己下的拉到相应位置，或者把EFI文件夹整个替换，具体看下的资源。</p><h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><p>分区的话可以采用WIn10自带的磁盘管理进行也可以采用DiskGenius</p><ul><li>在磁盘管理中，使用磁盘压缩出一定的大小，建议40G以上，之后进行新建磁盘，选择不要格式化这个卷，完成后弹出的弹窗让你格式化点击取消</li><li>在DG中过程大致相同，还是要选择不格式化，其他默认就好</li></ul><h2 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h2><ol><li>重启，进入BIOS菜单中修改启动项，将 U盘作为第一启动项呀</li><li>重启进入clover界面，选择Mac install，有时候可能会黑屏，在configure下进行设置，最好打开debug模式，可以看到错误或者有没有卡机</li><li>出现黑苹果后等待读条后，第一次会比较慢</li><li>进入选择语言界面选择简体中文</li><li>选择磁盘工具，找到自己的新建的安装盘，输入名称，抹掉为Mac OS扩展，固态硬盘的话采用APFS比较好</li><li>然后退出磁盘工具，选择安装，第一次跑进度条是转移数据，转移完后会重启。</li><li>之后是真正的安装</li><li>重启后选择安装好的磁盘分区启动，进入创建用户界面，就进入系统了</li></ol><h2 id="改硬盘启动"><a href="#改硬盘启动" class="headerlink" title="改硬盘启动"></a>改硬盘启动</h2><ol><li>在DG中，把刚刚的 EFI 文件夹里的 clover 文件夹拷贝到硬盘的ESP 分区中的EFI中</li><li>然后安装 EasyUEFI，打开，选择管理 EFI 启动项。</li><li>添加新的启动项，在类型选择 Linu x,  自己命名</li><li>选择浏览，找到你刚刚拷贝的ESP中的clover文件夹中的CLOVERX64.efi，选中确认</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> IT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Win10 Office</title>
      <link href="/Win10/Office2019/"/>
      <url>/Win10/Office2019/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p><strong>专业增强版（强烈推荐）：</strong></p><p><a href="http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/ProPlus2019Retail.img">http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/ProPlus2019Retail.img</a></p><p><strong>专业版：</strong></p><p><a href="http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/Professional2019Retail.img">http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/Professional2019Retail.img</a></p><p><strong>家庭学生版：</strong></p><p><a href="http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/HomeStudent2019Retail.img">http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/HomeStudent2019Retail.img</a></p><p><strong>家庭企业版：</strong></p><p><a href="http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/HomeBusiness2019Retail.img">http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/HomeBusiness2019Retail.img</a></p><p><strong>独立版（不推荐）：</strong></p><p><a href="http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/ProjectStd2019Retail.img">http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/ProjectStd2019Retail.img</a></p><p><a href="http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/ProjectPro2019Retail.img">http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/ProjectPro2019Retail.img</a></p><p><a href="http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/VisioStd2019Retail.img">http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/VisioStd2019Retail.img</a></p><p><a href="http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/VisioPro2019Retail.img">http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/VisioPro2019Retail.img</a></p><p><a href="http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/Access2019Retail.img">http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/Access2019Retail.img</a></p><p><a href="http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/Excel2019Retail.img">http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/Excel2019Retail.img</a></p><p><a href="http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/PowerPoint2019Retail.img">http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/PowerPoint2019Retail.img</a></p><p><a href="http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/Outlook2019Retail.img">http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/Outlook2019Retail.img</a></p><p><a href="http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/Publisher2019Retail.img">http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/Publisher2019Retail.img</a></p><p><a href="http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/Word2019Retail.img">http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/Word2019Retail.img</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> win10 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
